#!/usr/bin/env bash
# topic-utils.sh - Topic directory management utilities for .claude/ system
#
# Purpose: Topic directory creation and validation for LLM-based naming system
# Used by: /plan, /research, /debug, /optimize-claude commands
#
# Source guard: Prevent multiple sourcing
if [ -n "${TOPIC_UTILS_SOURCED:-}" ]; then
  return 0
fi
export TOPIC_UTILS_SOURCED=1
#
# DEPRECATION NOTICE (Spec 933):
#   The following functions are DEPRECATED for new code:
#     - get_next_topic_number() - Non-atomic, causes race conditions
#     - get_or_create_topic_number() - Non-atomic, causes duplicate topic numbers
#
#   For concurrent-safe topic allocation, use instead:
#     allocate_and_create_topic() from unified-location-detection.sh
#
#   These functions are retained for backward compatibility with existing callers
#   but should NOT be used in new code. See Spec 933 research reports for details
#   on the race condition that caused duplicate-numbered directories (820, 822, 923).
#
# Functions:
#   get_next_topic_number(specs_root)       - [DEPRECATED] Find max topic number and increment
#   get_or_create_topic_number(specs_root, topic_name) - [DEPRECATED] Idempotent but non-atomic
#   validate_topic_name_format(topic_name)  - Validate LLM-generated topic name format (^[a-z0-9_]{5,40}$)
#   create_topic_structure(topic_path)      - Create topic subdirectories with verification
#   find_matching_topic(topic_desc)         - Search for existing related topics (optional)
#
# Topic Naming:
#   Topic names are generated by the topic-naming-agent (Haiku LLM) which analyzes
#   user prompts and extracts semantic names. Commands invoke the agent, validate
#   the returned name with validate_topic_name_format(), and fall back to "no_name_error"
#   on any failure (with error logging). All 7 directory-creating commands use this system:
#   /plan, /research, /debug, /optimize-claude, /errors, /setup, /repair

set -eo pipefail  # Match workflow-initialization.sh: removed -u for defensive variable refs

# Extract significant words from user description for fallback slug generation
# Usage: extract_significant_words "I want to research authentication patterns"
# Returns: "research_authentication_patterns" (first 4 significant words, max 40 chars)
# Note: This is a fallback when LLM topic naming fails. Filters common words.
extract_significant_words() {
  local description="$1"

  # Common words to filter out (articles, prepositions, pronouns, etc.)
  local stopwords="the|a|an|and|or|but|in|on|at|to|for|of|with|by|from|up|about|into|through|during|before|after|above|below|between|among|under|over|again|further|then|once|here|there|when|where|why|how|all|both|each|few|more|most|other|some|such|no|nor|not|only|own|same|so|than|too|very|can|will|just|should|now|i|you|he|she|it|we|they|them|their|what|which|who|whom|this|that|these|those|am|is|are|was|were|be|been|being|have|has|had|do|does|did|would|could|may|might|must|shall"

  # Extract words: lowercase, remove punctuation, filter stopwords and paths
  local words=$(echo "$description" | \
    tr '[:upper:]' '[:lower:]' | \
    sed 's/[^a-z0-9 ]/ /g' | \
    tr -s ' ' '\n' | \
    grep -vE "^($stopwords)$" | \
    grep -vE '^[0-9]+$' | \
    grep -E '^[a-z][a-z0-9]{2,}$' | \
    head -4)

  # Join with underscores
  local slug=$(echo "$words" | tr '\n' '_' | sed 's/_$//')

  # If empty (all stopwords), default to "topic"
  if [ -z "$slug" ]; then
    slug="topic"
  fi

  # Truncate to 40 chars if needed
  slug="${slug:0:40}"

  # Remove trailing underscore if truncation created one
  slug="${slug%_}"

  echo "$slug"
}
export -f extract_significant_words

# DEPRECATED: Use allocate_and_create_topic() from unified-location-detection.sh instead
# This function is non-atomic and causes race conditions under concurrent access.
# Retained for backward compatibility only - do NOT use in new code.
#
# Get the next sequential topic number in the specs directory
# Usage: get_next_topic_number "/path/to/specs"
# Returns: "001" for empty directory, or next number (e.g., "006" if max is 005)
get_next_topic_number() {
  local specs_root="$1"

  # Find all directories matching NNN_* pattern and extract numbers
  local max_num
  max_num=$(ls -1d "${specs_root}"/[0-9][0-9][0-9]_* 2>/dev/null | \
    sed 's/.*\/\([0-9][0-9][0-9]\)_.*/\1/' | \
    sort -n | tail -1)

  # If no topics found, start at 001
  if [ -z "$max_num" ]; then
    echo "001"
  else
    # Increment the max number (use 10# to force decimal interpretation)
    printf "%03d" $((10#$max_num + 1))
  fi
}

# DEPRECATED: Use allocate_and_create_topic() from unified-location-detection.sh instead
# This function is non-atomic - while idempotent for exact matches, it causes race
# conditions for new topic creation under concurrent access.
# Retained for backward compatibility only - do NOT use in new code.
#
# Get topic number for a given topic name (idempotent - reuses existing if found)
# Usage: get_or_create_topic_number "/path/to/specs" "research_auth_patterns"
# Returns: Existing topic number if topic with matching name exists, otherwise next number
#
# This function solves the topic inconsistency issue where multiple bash blocks
# would increment the topic number on each invocation. Now it checks for existing
# topics first and reuses them if found.
get_or_create_topic_number() {
  local specs_root="$1"
  local topic_name="$2"

  # Check for existing topic with exact name match (pattern: NNN_topicname)
  local existing
  existing=$(ls -1d "${specs_root}"/[0-9][0-9][0-9]_"${topic_name}" 2>/dev/null | head -1 || echo "")

  if [ -n "$existing" ]; then
    # Extract and return the existing topic number
    basename "$existing" | sed 's/^\([0-9][0-9][0-9]\)_.*/\1/'
  else
    # No existing topic found - get next number
    get_next_topic_number "$specs_root"
  fi
}

# validate_topic_name_format: Validate topic name format
#
# Validates that a topic name meets the required format constraints.
# Used by commands after parsing agent response to ensure valid directory names.
#
# Arguments:
#   $1 - topic_name: Topic name string to validate
#
# Format Requirements:
#   - Lowercase letters (a-z), numbers (0-9), and underscores (_) only
#   - Length: 5-40 characters
#   - No consecutive underscores
#   - No leading/trailing underscores
#
# Returns:
#   0 if valid format
#   1 if invalid format
#
# Example:
#   validate_topic_name_format "jwt_auth_refactor"  # Returns 0 (valid)
#   validate_topic_name_format "Invalid-Name!"      # Returns 1 (invalid)
#   validate_topic_name_format "jwt"                # Returns 1 (too short)
#   validate_topic_name_format "a__b"               # Returns 1 (consecutive underscores)
#
validate_topic_name_format() {
  local topic_name="$1"

  # Check basic regex: lowercase letters, numbers, underscores only, 5-40 chars
  if ! echo "$topic_name" | grep -Eq '^[a-z0-9_]{5,40}$'; then
    return 1
  fi

  # Check for consecutive underscores
  if echo "$topic_name" | grep -q '__'; then
    return 1
  fi

  # Check for leading underscore
  if echo "$topic_name" | grep -q '^_'; then
    return 1
  fi

  # Check for trailing underscore
  if echo "$topic_name" | grep -q '_$'; then
    return 1
  fi

  return 0
}

# Create the topic directory with lazy subdirectory creation
# Usage: create_topic_structure "/path/to/specs/082_topic_name"
# Creates: Only the topic root directory
# Returns: 0 on success, 1 on failure
#
# Note: Subdirectories (reports/, plans/, summaries/, debug/, scripts/, outputs/)
#       are created on-demand when files are written. This prevents empty directories.
#
# Verification: Checks that topic root directory exists after creation
create_topic_structure() {
  local topic_path="$1"

  # Create only the topic root directory
  mkdir -p "$topic_path"

  # Verification checkpoint (required by Verification and Fallback pattern)
  if [ ! -d "$topic_path" ]; then
    echo "ERROR: Failed to create topic directory: $topic_path" >&2
    return 1
  fi

  return 0
}

# Find existing topics that match a given description
# Usage: find_matching_topic "authentication patterns"
# Returns: List of matching topic directories (one per line)
#
# Optional function for future use (intelligent topic merging)
# Currently not used by /supervise Phase 0 optimization
find_matching_topic() {
  local topic_desc="$1"
  local specs_root="${2:-${CLAUDE_CONFIG}/.claude/specs}"

  # Extract keywords from description (split on spaces, lowercase)
  local keywords
  keywords=$(echo "$topic_desc" | tr '[:upper:]' '[:lower:]' | tr ' ' '\n' | sort -u)

  # Search for matching directory names
  local matches=()
  while IFS= read -r topic_dir; do
    local topic_name
    topic_name=$(basename "$topic_dir" | sed 's/^[0-9][0-9][0-9]_//')

    # Check if any keyword appears in topic name
    for keyword in $keywords; do
      if [[ "$topic_name" == *"$keyword"* ]]; then
        matches+=("$topic_dir")
        break
      fi
    done
  done < <(ls -1d "${specs_root}"/[0-9][0-9][0-9]_* 2>/dev/null || true)

  # Return matches (if any)
  if [ ${#matches[@]} -gt 0 ]; then
    printf "%s\n" "${matches[@]}"
  fi
}

# Usage examples:
#
# Example 1: Get next topic number
#   NEXT_NUM=$(get_next_topic_number "/path/to/specs")
#   echo "Next topic: $NEXT_NUM"  # Output: "083"
#
# Example 2: Validate topic name format
#   if validate_topic_name_format "jwt_auth_refactor"; then
#     echo "Valid topic name"
#   else
#     echo "Invalid topic name format"
#   fi
#
# Example 3: Create topic root (subdirectories created on-demand)
#   TOPIC_PATH="/path/to/specs/083_auth_research"
#   if create_topic_structure "$TOPIC_PATH"; then
#     echo "Topic root created successfully"
#     # Subdirectories created when files are written
#   else
#     echo "Failed to create topic root" >&2
#     exit 1
#   fi
#
# Example 4: Find matching topics
#   MATCHES=$(find_matching_topic "authentication")
#   if [ -n "$MATCHES" ]; then
#     echo "Found existing topics:"
#     echo "$MATCHES"
#   fi
