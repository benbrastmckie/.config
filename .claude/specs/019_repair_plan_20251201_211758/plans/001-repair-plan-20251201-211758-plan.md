# /plan Command Error Fixes Implementation Plan

## Metadata
- **Date**: 2025-12-01
- **Feature**: Fix /plan command bash syntax and state persistence errors
- **Scope**: Repair critical runtime errors blocking /plan command execution
- **Estimated Phases**: 4
- **Estimated Hours**: 3
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Status**: [COMPLETE]
- **Structure Level**: 0
- **Complexity Score**: 28.0
- **Research Reports**:
  - [Error Analysis Report](/home/benjamin/.config/.claude/specs/019_repair_plan_20251201_211758/reports/001-plan-errors-repair.md)

## Overview

This plan addresses three critical runtime errors in the `/plan` command that cause exit code 2 (bash syntax error) and exit code 127 (unbound variable error). The errors affect all research-and-plan workflows and prevent proper state persistence.

**Error Summary**:
1. **Bash Syntax Error (Exit 2)**: Incorrectly escaped negation operator `\!` in path validation conditionals
2. **State Persistence Error (Exit 127)**: JSON array passed to `append_workflow_state_bulk` function expecting KEY=value format
3. **Topic Naming Agent Failures**: Intermittent agent output validation failures (degrades to fallback)

## Research Summary

Analysis of 33 errors from `/plan` command execution (from 935 total errors) revealed:
- **Pattern 1** (Critical): Bash negation operator `!` escaped as `\!` in `[[` conditionals causes "conditional binary operator expected" syntax error at lines 340 (plan.md) and 311 (research.md)
- **Pattern 2** (Critical): `REPORT_PATHS_JSON` created via `jq -s .` produces JSON array, then passed to `append_workflow_state_bulk` which expects KEY=value format, triggering unbound variable at state-persistence.sh:518 (54.5% of errors)
- **Pattern 3** (Medium): Topic naming agent fails to create output file or returns invalid format in 33.3% of executions

Root causes:
1. History expansion directive `set +H` or markdown-to-bash conversion escapes `!` unnecessarily in `[[` test syntax
2. Type mismatch between JSON array format (REPORT_PATHS_JSON) and KEY=value expectation (append_workflow_state_bulk)
3. Agent timeout or validation gaps in hard barrier pattern for topic naming

## Success Criteria
- [ ] /plan command executes without exit code 2 (bash syntax error)
- [ ] /plan command executes without exit code 127 (unbound variable error)
- [ ] State persistence successfully stores research report paths
- [ ] Negation operator syntax validated in bash blocks (bash -n check passes)
- [ ] Research-and-plan workflow completes end-to-end with proper state persistence
- [ ] Error log shows zero new execution_error or state_error entries for /plan after fixes
- [ ] Topic naming agent diagnostics provide actionable debugging data on failures

## Technical Design

### Architecture Overview

**Fix Strategy**:
1. **Bash Syntax Fix** (Critical, Low Effort): Find-and-replace `[[ \! ` → `[[ ! ` in plan.md and research.md
2. **State Persistence Fix** (Critical, Medium Effort): Convert REPORT_PATHS_JSON from JSON array to space-separated string format compatible with append_workflow_state_bulk
3. **Agent Diagnostics Enhancement** (Medium, Medium Effort): Add detailed logging and validation feedback for topic naming agent failures

### Component Changes

**Files Modified**:
- `.claude/commands/plan.md` (lines 340, 1121-1130)
- `.claude/commands/research.md` (line 311)
- `.claude/lib/core/state-persistence.sh` (defensive validation, optional)

**State Persistence Strategy**:
- Replace `REPORT_PATHS_JSON=$(echo "$REPORT_PATHS" | jq -R . | jq -s .)` with space-separated format
- Use `REPORT_PATHS_LIST=$(echo "$REPORT_PATHS" | tr '\n' ' ')` for simple scalar format
- Update bulk append to use `REPORT_PATHS_LIST=$REPORT_PATHS_LIST`

**Validation Approach**:
- Extract bash blocks from modified commands and validate with `bash -n`
- Test /plan command with simple feature request to verify state persistence
- Review error log after test run to confirm zero new errors

## Implementation Phases

### Phase 1: Fix Bash Negation Operator Syntax [COMPLETE]
dependencies: []

**Objective**: Remove backslash escapes from negation operators in bash conditionals to fix exit code 2 syntax errors

**Complexity**: Low

**Tasks**:
- [x] Fix negation operator in plan.md line 340: `[[ \! "$TOPIC_NAME_FILE" =~ ^/ ]]` → `[[ ! "$TOPIC_NAME_FILE" =~ ^/ ]]`
- [x] Fix negation operator in research.md line 311: `[[ \! "$TOPIC_NAME_FILE" =~ ^/ ]]` → `[[ ! "$TOPIC_NAME_FILE" =~ ^/ ]]`
- [x] Verify no other instances of `[[ \! ` pattern exist in .claude/commands/ (search completed - only found in comments)
- [x] Validate bash syntax of modified blocks: `bash -n <(sed -n '/```bash/,/```/p' plan.md | grep -v '```')`

**Testing**:
```bash
# Extract and validate bash syntax from modified commands
for cmd in plan.md research.md; do
  echo "Validating $cmd..."
  sed -n '/```bash/,/```/p' ".claude/commands/$cmd" | grep -v '```' | bash -n
  if [ $? -eq 0 ]; then
    echo "✓ $cmd bash syntax valid"
  else
    echo "✗ $cmd has syntax errors"
    exit 1
  fi
done
```

**Expected Duration**: 0.5 hours

### Phase 2: Convert REPORT_PATHS_JSON to Scalar Format [COMPLETE]
dependencies: [1]

**Objective**: Replace JSON array state persistence with space-separated string format to fix exit code 127 unbound variable errors

**Complexity**: Medium

**Tasks**:
- [x] Change plan.md line 1123 from `REPORT_PATHS_JSON=$(echo "$REPORT_PATHS" | jq -R . | jq -s .)` to `REPORT_PATHS_LIST=$(echo "$REPORT_PATHS" | tr '\n' ' ')`
- [x] Update plan.md line 1129 from `REPORT_PATHS_JSON=$REPORT_PATHS_JSON` to `REPORT_PATHS_LIST=$REPORT_PATHS_LIST`
- [x] Update variable name in any downstream code that reads REPORT_PATHS_JSON from state (search and verify)
- [x] Add comment explaining scalar format requirement for append_workflow_state_bulk
- [x] Verify plan-architect agent doesn't depend on JSON format (grep agent file)

**Testing**:
```bash
# Test state persistence with scalar format
cd /home/benjamin/.config
/plan "test feature for state persistence validation" --complexity 1

# Verify state file contains REPORT_PATHS_LIST in correct format
STATE_FILE=$(ls -t .claude/tmp/state_*.sh | head -1)
if grep -q "REPORT_PATHS_LIST=" "$STATE_FILE"; then
  echo "✓ State persistence using scalar format"
  # Verify no warnings about invalid KEY=value
  if ! grep -q "WARNING: Skipping invalid line" .claude/output/plan-output.md; then
    echo "✓ No state persistence warnings"
  else
    echo "✗ State persistence warnings still present"
    exit 1
  fi
else
  echo "✗ REPORT_PATHS_LIST not found in state"
  exit 1
fi
```

**Expected Duration**: 1 hour

### Phase 3: Enhance Topic Naming Agent Diagnostics [COMPLETE]
dependencies: [1, 2]

**Objective**: Add detailed diagnostics and validation feedback for topic naming agent failures to reduce 33.3% agent_error rate

**Complexity**: Medium

**Tasks**:
- [x] Add pre-invocation checks in plan.md topic naming block: verify agent file exists, check model availability
- [x] Add post-invocation diagnostics: log execution time, file existence, file size, validation failure reasons
- [x] Enhance error logging with context fields: execution_time, file_exists, file_size, validation_failure_reason
- [x] Add retry logic with 2s backoff (max 2 retries) for agent failures
- [x] Update research.md with same diagnostic enhancements (maintain consistency)
- [x] Document agent failure reasons in error log for debugging

**Testing**:
```bash
# Test agent diagnostics with forced failure scenario
cd /home/benjamin/.config

# Run /plan command and check for enhanced diagnostics
/plan "test feature for agent diagnostics" --complexity 1

# Verify enhanced error logging if agent fails
ERROR_LOG=".claude/data/logs/errors.jsonl"
LATEST_AGENT_ERROR=$(tail -50 "$ERROR_LOG" | jq -r 'select(.error_type == "agent_error" and .command == "/plan") | select(.timestamp == (now | strftime("%Y-%m-%d")))' | head -1)

if [ -n "$LATEST_AGENT_ERROR" ]; then
  echo "Agent error detected, checking diagnostics..."
  echo "$LATEST_AGENT_ERROR" | jq .
  # Verify new diagnostic fields present
  if echo "$LATEST_AGENT_ERROR" | jq -e '.details.execution_time' >/dev/null; then
    echo "✓ Enhanced diagnostics present"
  else
    echo "✗ Missing diagnostic fields"
  fi
fi
```

**Expected Duration**: 1 hour

### Phase 4: Update Error Log Status [COMPLETE]
dependencies: [1, 2, 3]

**Objective**: Mark all errors fixed by this implementation as RESOLVED in error log

**Complexity**: Low

**Tasks**:
- [x] Identify all error IDs from Pattern 1 (bash syntax) and Pattern 2 (state persistence) in errors.jsonl
- [x] Add RESOLVED status field to each error entry with resolution_date and resolution_plan
- [x] Update error log schema to support RESOLVED status tracking
- [x] Create summary report of resolved errors by pattern

**Testing**:
```bash
# Verify error resolution tracking
ERROR_LOG="/home/benjamin/.config/.claude/data/logs/errors.jsonl"

# Count resolved errors from this repair
RESOLVED_COUNT=$(jq -r 'select(.status == "RESOLVED" and .resolution_plan == "019_repair_plan_20251201_211758") | .error_id' "$ERROR_LOG" | wc -l)

echo "Resolved $RESOLVED_COUNT errors from repair plan"

# Verify no new execution_error or state_error for /plan
NEW_ERRORS=$(jq -r --arg date "$(date +%Y-%m-%d)" 'select(.command == "/plan" and .error_type == ("execution_error", "state_error") and (.timestamp | startswith($date)) and (.status != "RESOLVED"))' "$ERROR_LOG" | wc -l)

if [ "$NEW_ERRORS" -eq 0 ]; then
  echo "✓ No new errors after fixes"
else
  echo "✗ $NEW_ERRORS new errors detected"
  exit 1
fi
```

**Expected Duration**: 0.5 hours

## Testing Strategy

### Unit Testing
- Bash syntax validation using `bash -n` on extracted bash blocks
- State persistence format validation with append_workflow_state_bulk
- Agent diagnostic field presence validation in error log

### Integration Testing
- End-to-end /plan command execution with research-and-plan workflow
- State file verification for correct REPORT_PATHS_LIST format
- Error log verification for zero new execution_error or state_error entries

### Regression Testing
- Re-run previously failing /plan commands from error log
- Verify no exit code 2 or exit code 127 errors
- Compare error counts before/after fixes

### Test Scenarios
1. **Scenario 1: Path Validation** - /plan command with non-absolute path (should error gracefully, not with syntax error)
2. **Scenario 2: State Persistence** - /plan with multiple research reports (verify all paths persisted correctly)
3. **Scenario 3: Agent Failure** - /plan with invalid user input (verify enhanced diagnostics in error log)

## Documentation Requirements

### Update Documentation
- Add fix details to .claude/docs/troubleshooting/ (new file: plan-command-errors.md)
- Update .claude/docs/reference/standards/code-standards.md with negation operator syntax guideline
- Document state persistence scalar format requirement in state-persistence.sh header comments

### No New Documentation Files
Following documentation standards, update existing docs rather than creating new ones where possible.

## Dependencies

### External Dependencies
- bash (for syntax validation)
- jq (used in existing code, not removed)
- state-persistence.sh library (modified defensively)

### Internal Dependencies
- Error logging infrastructure (errors.jsonl)
- Workflow state machine (for status tracking)
- Hard barrier pattern (for agent invocation)

### Prerequisite Conditions
- Error log exists at /home/benjamin/.config/.claude/data/logs/errors.jsonl
- State persistence library loaded and functional
- /plan and /research commands present in .claude/commands/

## Risk Mitigation

### Risk 1: Breaking Downstream Code
- **Mitigation**: Search all .claude/ files for REPORT_PATHS_JSON variable usage before renaming
- **Rollback**: Backup plan.md and research.md before modifications

### Risk 2: State Persistence Side Effects
- **Mitigation**: Test with simple /plan command first, verify state file format before complex workflows
- **Rollback**: Revert to JSON format if scalar format causes issues (low probability based on analysis)

### Risk 3: Agent Diagnostic Overhead
- **Mitigation**: Limit diagnostic logging to error cases only (no overhead on success)
- **Rollback**: Remove retry logic if it causes timeout issues (keep diagnostics)
