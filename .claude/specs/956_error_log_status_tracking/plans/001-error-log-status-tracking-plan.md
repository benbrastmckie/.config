# Error Log Status Tracking Implementation Plan

## Metadata
- **Date**: 2025-11-29 (Revised: 2025-11-29)
- **Feature**: Complete Error Log Status Lifecycle
- **Scope**: Ensure repair plans include error status update phase via /repair command enhancement (NO /build changes)
- **Estimated Phases**: 2
- **Estimated Hours**: 1.5
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Status**: [COMPLETE]
- **Structure Level**: 0
- **Complexity Score**: 12
- **Research Reports**:
  - [Error Status Lifecycle Research](/home/benjamin/.config/.claude/specs/956_error_log_status_tracking/reports/001_error_status_lifecycle_research.md)
  - [Elegant Solution Research](/home/benjamin/.config/.claude/specs/956_error_log_status_tracking/reports/002_elegant_solution_research.md)

## Overview

The current repair workflow marks errors as `FIX_PLANNED` when a repair plan is created, but there is no mechanism to update the status to `RESOLVED` after fixes are implemented. This creates stale error log entries that remain in `FIX_PLANNED` status indefinitely.

**Key Design Decision**: Rather than adding complexity to `/build` to detect repair plans, the elegant solution is to have `/repair` include specific instructions in its plan-architect prompt that result in an "Update Error Log Status" phase being added to all repair-generated plans. This keeps:
- `/build` generic and unchanged (works with all plans)
- Error log lifecycle concern scoped entirely to `/repair`
- Non-repair plans unaffected

## Research Summary

Key findings:

- **Infrastructure exists**: `update_error_status()` function and `ERROR_STATUS_RESOLVED` constant are defined but unused
- **Gap identified**: The `/repair` command's prompt to plan-architect doesn't include error status update instructions
- **Elegant solution**: Enhance `/repair`'s Task prompt to plan-architect to request an error status update phase

## Success Criteria

- [ ] `/repair` command includes repair-specific instructions in plan-architect prompt
- [ ] Helper function `mark_errors_resolved_for_plan()` added to error-handling.sh
- [ ] Plans generated by `/repair` include "Update Error Log Status" as final phase
- [ ] `/build` command remains unchanged
- [ ] Non-repair plans (from `/plan`) are unaffected

## Technical Design

### Error Status Lifecycle Flow

```
Error Logged → ERROR status (automatic)
     ↓
/repair → FIX_PLANNED status + plan_path link (existing)
     ↓
/repair generates plan WITH error status update phase (NEW)
     ↓
/build [repair-plan] → executes error status update phase → RESOLVED status
```

### Solution Architecture

The change is entirely within `/repair`'s Task invocation to plan-architect:

```
Current /repair prompt to plan-architect:
  - Feature Description
  - Output Path
  - Research Reports
  - Workflow Type
  - Operation Mode

Enhanced /repair prompt adds:
  - REPAIR-SPECIFIC REQUIREMENT: Include "Update Error Log Status" phase
```

This results in repair plans containing:
```markdown
### Phase N: Update Error Log Status [NOT STARTED]
dependencies: [all previous phases]

Tasks:
- [ ] Verify fixes are working
- [ ] Run: mark_errors_resolved_for_plan "$PLAN_PATH"
- [ ] Verify no FIX_PLANNED errors remain
```

## Implementation Phases

### Phase 1: Add mark_errors_resolved_for_plan Function [COMPLETE]
dependencies: []

**Objective**: Add helper function to error-handling.sh for bulk resolving errors by plan path

**Complexity**: Low

Tasks:
- [x] Read error-handling.sh to locate error status update section (file: .claude/lib/core/error-handling.sh, lines 1090-1250)
- [x] Add `mark_errors_resolved_for_plan()` function after `mark_errors_fix_planned()`:
  ```bash
  # mark_errors_resolved_for_plan: Update all FIX_PLANNED errors linked to a plan to RESOLVED
  # Usage: mark_errors_resolved_for_plan <plan_path>
  # Returns: Number of resolved entries (stdout), 0 on no matches
  # Example: mark_errors_resolved_for_plan "/path/to/repair-plan.md"
  mark_errors_resolved_for_plan() {
    local plan_path="${1:-}"

    if [[ -z "$plan_path" ]]; then
      echo "ERROR: mark_errors_resolved_for_plan requires plan_path argument" >&2
      return 1
    fi

    local log_file="${ERROR_LOG_FILE:-$ERROR_LOG_DIR/errors.jsonl}"

    if [[ ! -f "$log_file" ]]; then
      echo "0"
      return 0
    fi

    local count=0
    local temp_file="${log_file}.tmp.$$"
    local now=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    while IFS= read -r line; do
      local entry_plan=$(echo "$line" | jq -r '.repair_plan_path // ""')
      local entry_status=$(echo "$line" | jq -r '.status // "ERROR"')

      if [[ "$entry_plan" == "$plan_path" ]] && [[ "$entry_status" == "FIX_PLANNED" ]]; then
        echo "$line" | jq --arg status "RESOLVED" --arg ts "$now" \
          '.status = $status | .status_updated_at = $ts' >> "$temp_file"
        ((count++))
      else
        echo "$line" >> "$temp_file"
      fi
    done < "$log_file"

    mv "$temp_file" "$log_file"
    echo "$count"
  }
  ```
- [x] Add export statement for the new function (around line 2082)

Testing:
```bash
# Test with existing repair plan
source .claude/lib/core/error-handling.sh
mark_errors_resolved_for_plan "/home/benjamin/.config/.claude/specs/941_debug_errors_repair/plans/001-debug-errors-repair-plan.md"

# Verify no FIX_PLANNED errors remain for that plan
query_errors --status FIX_PLANNED | jq -r '.repair_plan_path' | grep -c "941_debug_errors_repair" || echo "0 remaining"
```

**Expected Duration**: 0.5 hours

### Phase 2: Enhance /repair Plan-Architect Prompt [COMPLETE]
dependencies: [1]

**Objective**: Add repair-specific instructions to /repair's Task invocation to plan-architect

**Complexity**: Low

Tasks:
- [x] Read /repair command to locate plan-architect Task invocation (file: .claude/commands/repair.md, lines 765-788)
- [x] Locate the existing prompt content within the Task block
- [x] Add REPAIR-SPECIFIC REQUIREMENT section after "Operation Mode" line:
  ```
  **REPAIR-SPECIFIC REQUIREMENT**:
  Since this is a repair plan addressing logged errors, you MUST include a final phase
  titled 'Update Error Log Status' as the last phase (after all fix phases) with:

  dependencies: [all previous phases]

  **Objective**: Update error log entries from FIX_PLANNED to RESOLVED

  Tasks:
  - [x] Verify all fixes are working (tests pass, no new errors generated)
  - [x] Update error log entries to RESOLVED status:
    \`\`\`bash
    source .claude/lib/core/error-handling.sh
    RESOLVED_COUNT=$(mark_errors_resolved_for_plan "${PLAN_PATH}")
    echo "Resolved $RESOLVED_COUNT error log entries"
    \`\`\`
  - [x] Verify no FIX_PLANNED errors remain for this plan:
    \`\`\`bash
    REMAINING=$(query_errors --status FIX_PLANNED | jq -r '.repair_plan_path' | grep -c "$(basename "$(dirname "$(dirname "${PLAN_PATH}")")")" || echo "0")
    [ "$REMAINING" -eq 0 ] && echo "All errors resolved" || echo "WARNING: $REMAINING errors still FIX_PLANNED"
    \`\`\`
  ```
- [x] Verify the prompt is properly formatted within the Task block
- [x] Test that /repair generates plans with the new phase

Testing:
```bash
# Run /repair with dry-run to see what plan would contain
/repair --command /test --dry-run 2>&1

# After implementation, verify new repair plans include error status phase
/repair --since 1h
cat [generated-plan-path] | grep -A20 "Update Error Log Status"
```

**Expected Duration**: 1 hour

## Testing Strategy

### Unit Tests
- Test `mark_errors_resolved_for_plan()` with mock error log
- Test error status transition from FIX_PLANNED to RESOLVED
- Verify function handles missing/empty log file gracefully

### Integration Tests
- Run `/repair` and verify generated plan includes "Update Error Log Status" phase
- Execute generated repair plan with `/build` and verify phase executes
- Verify errors transition to RESOLVED after plan completion

### Manual Validation
1. Run `/repair --command /debug` to create new repair plan
2. Inspect generated plan for "Update Error Log Status" phase
3. Check error log shows FIX_PLANNED entries: `query_errors --status FIX_PLANNED`
4. Implement fixes via `/build [plan-path]`
5. Verify errors now show RESOLVED: `query_errors --status RESOLVED`

### Non-Regression Tests
- Run `/plan "test feature"` and verify generated plan does NOT include error status phase
- Verify `/build` works unchanged with non-repair plans

## Documentation Requirements

- Update `.claude/docs/concepts/patterns/error-handling.md` with complete error lifecycle
- Document `mark_errors_resolved_for_plan()` function usage

## Dependencies

### Prerequisites
- Access to .claude/lib/core/error-handling.sh
- Access to .claude/commands/repair.md

### External Dependencies
- jq for JSON processing (already required)

## Files Changed

| File | Change | Why |
|------|--------|-----|
| `.claude/lib/core/error-handling.sh` | Add `mark_errors_resolved_for_plan()` | Helper function for resolving errors |
| `.claude/commands/repair.md` | Enhance plan-architect prompt | Include error status update phase in repair plans |

## Files NOT Changed

| File | Why No Change |
|------|---------------|
| `.claude/commands/build.md` | No repair detection needed - plans include update phase explicitly |
| `.claude/agents/plan-architect.md` | Already handles any phase content in prompts |
| `.claude/commands/plan.md` | Non-repair plans don't need error status updates |

## Risk Assessment

### Low Risk
- Adding new function is additive, doesn't affect existing functionality
- Prompt enhancement only affects plans generated by /repair
- Error status update is non-destructive (RESOLVED is valid final state)

### Rollback Strategy
- New function can be removed without affecting existing error logging
- Repair prompt enhancement can be reverted if issues discovered
- No other commands affected by these changes
