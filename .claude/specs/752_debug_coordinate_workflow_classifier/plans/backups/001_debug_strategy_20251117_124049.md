# Debug Strategy Plan: Coordinate Command Workflow Classifier State Persistence

## Executive Summary

This debug strategy addresses critical failures in the `/coordinate` command's Phase 0.1 (Workflow Classification) where the workflow-classifier agent fails to persist the `CLASSIFICATION_JSON` variable to workflow state. The root cause is an architectural mismatch: the agent is configured with `allowed-tools: None` but instructed to execute bash commands for state persistence, which is impossible.

**Strategy Overview**: Implement a phased approach starting with immediate critical fixes (P0) to restore functionality, followed by enhanced diagnostics (P1), and concluding with architectural improvements and documentation (P2).

**Expected Outcome**: Complete resolution of state persistence failures with improved error diagnostics and long-term maintainability.

## Priority Fixes

### P0 - Critical (Blocking all coordinate workflows)

**Fix 1.1**: Remove impossible state persistence instructions from workflow-classifier agent
- **File**: `/home/benjamin/.config/.claude/agents/workflow-classifier.md`
- **Impact**: Eliminates contradictory instructions causing agent to skip state persistence
- **Effort**: 15 minutes
- **Risk**: Low - removes impossible requirement

**Fix 1.2**: Move state persistence to coordinate command post-agent invocation
- **File**: `/home/benjamin/.config/.claude/commands/coordinate.md`
- **Impact**: Ensures state persistence occurs in correct execution context
- **Effort**: 30 minutes
- **Risk**: Low - aligns with execution model

### P1 - High (Improves diagnostics and prevents future failures)

**Fix 2.1**: Add variable validation to load_workflow_state()
- **File**: `/home/benjamin/.config/.claude/lib/state-persistence.sh`
- **Impact**: Fail-fast detection of missing critical variables with better diagnostics
- **Effort**: 20 minutes
- **Risk**: Low - backward compatible, optional validation

**Fix 2.2**: Update coordinate.md to use variable validation
- **File**: `/home/benjamin/.config/.claude/commands/coordinate.md`
- **Impact**: Immediate detection when CLASSIFICATION_JSON missing from state
- **Effort**: 10 minutes
- **Risk**: Low - improves error messages

**Fix 2.3**: Add state file content dump to error messages
- **File**: `/home/benjamin/.config/.claude/lib/state-persistence.sh`
- **Impact**: Shows actual state file contents when validation fails
- **Effort**: 5 minutes
- **Risk**: Low - diagnostic improvement only

### P2 - Medium (Long-term improvements)

**Fix 3.1**: Migrate to JSON checkpoints for classification data
- **Files**: Multiple (state-persistence.sh, coordinate.md)
- **Impact**: Better handling of structured JSON data, atomic writes
- **Effort**: 45 minutes
- **Risk**: Low - follows existing checkpoint pattern

**Fix 3.2**: Document Task tool execution isolation patterns
- **File**: `/home/benjamin/.config/.claude/docs/concepts/bash-block-execution-model.md`
- **Impact**: Prevents similar architectural mismatches in future
- **Effort**: 30 minutes
- **Risk**: Low - documentation only

**Fix 3.3**: Create agent behavioral file validator
- **Files**: New script in `.claude/scripts/`
- **Impact**: Catches contradictions between allowed-tools and instructions
- **Effort**: 60 minutes
- **Risk**: Low - validation tool

**Fix 3.4**: Standardize state file location patterns
- **Files**: Multiple (deprecate `.claude/data/workflows/*.state` pattern)
- **Impact**: Eliminates confusion between temp and persistent state
- **Effort**: 30 minutes
- **Risk**: Low - cleanup only

## Implementation Phases

### Phase 1: Critical Fixes (P0)

**Objective**: Restore coordinate command functionality immediately

**Duration**: 45 minutes

**Steps**:

1. **Remove state persistence from workflow-classifier.md** (15 min)
   - Delete lines 530-587 from `/home/benjamin/.config/.claude/agents/workflow-classifier.md`
   - Update agent description to clarify it only returns classification
   - Verification: Agent file no longer contains bash block instructions

2. **Update coordinate.md to extract and save classification** (30 min)
   - Add bash block immediately after Task tool invocation (after line 213)
   - Extract CLASSIFICATION_JSON from agent response signal
   - Parse `CLASSIFICATION_COMPLETE: {JSON}` pattern
   - Validate JSON with jq
   - Save to state using append_workflow_state()
   - Verify successful save with load and validation
   - Verification: State file contains CLASSIFICATION_JSON export

**Implementation Details for Step 2**:

```markdown
## Phase 0.1: Workflow Classification

**EXECUTE NOW**: USE the Task tool to invoke workflow-classifier agent:

Task {
  subagent_type: "general-purpose"
  description: "Classify workflow intent for orchestration"
  model: "haiku"
  timeout: 30000
  prompt: "
    Read and follow ALL behavioral guidelines from:
    ${CLAUDE_PROJECT_DIR}/.claude/agents/workflow-classifier.md

    **Workflow-Specific Context**:
    - Workflow Description: $SAVED_WORKFLOW_DESC
    - Command Name: coordinate

    **CRITICAL**: Return structured JSON classification.

    Execute classification following all guidelines in behavioral file.
    Return: CLASSIFICATION_COMPLETE: {JSON classification object}
  "
}

**IMMEDIATELY AFTER Task completes**, extract and save classification:

```bash
#!/usr/bin/env bash
set +H
set -euo pipefail

# Standard 13: CLAUDE_PROJECT_DIR detection
if [ -z "${CLAUDE_PROJECT_DIR:-}" ]; then
  CLAUDE_PROJECT_DIR="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
  export CLAUDE_PROJECT_DIR
fi

# Load state persistence library
LIB_DIR="${CLAUDE_PROJECT_DIR}/.claude/lib"
source "${LIB_DIR}/state-persistence.sh"

# Re-load workflow state
COORDINATE_STATE_ID_FILE="${CLAUDE_PROJECT_DIR}/.claude/tmp/coordinate_state_id.txt"
WORKFLOW_ID=$(cat "$COORDINATE_STATE_ID_FILE")
load_workflow_state "$WORKFLOW_ID"

# CRITICAL: Extract classification JSON from agent response above
# The agent returns: CLASSIFICATION_COMPLETE: {JSON object}
# Extract the JSON portion after the signal

# NOTE: This extraction step requires the coordinator (Claude) to parse
# the Task tool output and substitute the actual JSON here.
# The agent's response signal format is: CLASSIFICATION_COMPLETE: {...}

# COORDINATOR: Replace <EXTRACT_FROM_TASK_OUTPUT> with actual JSON from agent response
CLASSIFICATION_JSON='<EXTRACT_FROM_TASK_OUTPUT>'

# Validate JSON before saving
if ! echo "$CLASSIFICATION_JSON" | jq empty 2>/dev/null; then
  echo "ERROR: Invalid JSON in classification result" >&2
  echo "Received: $CLASSIFICATION_JSON" >&2
  exit 1
fi

# Save to state
append_workflow_state "CLASSIFICATION_JSON" "$CLASSIFICATION_JSON"

# Verify saved successfully
load_workflow_state "$WORKFLOW_ID"
if [ -z "${CLASSIFICATION_JSON:-}" ]; then
  echo "ERROR: Failed to save CLASSIFICATION_JSON to state" >&2
  exit 1
fi

echo "✓ Classification saved to state successfully"
echo "  Workflow type: $(echo "$CLASSIFICATION_JSON" | jq -r '.workflow_type')"
echo "  Research complexity: $(echo "$CLASSIFICATION_JSON" | jq -r '.research_complexity')"
```
```
```

**Testing Verification**:

```bash
# Test 1: Simple research workflow
/coordinate "research authentication patterns"
# Expected:
# - Classification completes successfully
# - CLASSIFICATION_JSON saved to state
# - workflow_type = "research-only"
# - No errors in Phase 0.1

# Test 2: Full implementation workflow
/coordinate "implement user registration feature"
# Expected:
# - workflow_type = "full-implementation"
# - research_complexity >= 2
# - State persists correctly

# Test 3: Debug workflow
/coordinate "debug the login form validation"
# Expected:
# - workflow_type = "debug-only"
# - State machine initialized for debug scope
```

**Success Criteria**:
- [ ] Coordinate command completes Phase 0.1 without errors
- [ ] CLASSIFICATION_JSON successfully saved to state file
- [ ] State file located at correct path (`.claude/tmp/workflow_coordinate_*.sh`)
- [ ] JSON validation passes
- [ ] Workflow proceeds to Phase 0.2 (State Machine Initialization)

**Rollback Plan**:
- Revert coordinate.md to current version
- Restore workflow-classifier.md lines 530-587
- Document failure reason
- Consider alternative Fix 2 (allowed-tools: Bash)

### Phase 2: Enhanced Diagnostics (P1)

**Objective**: Improve error detection and debugging experience

**Duration**: 35 minutes

**Steps**:

1. **Add variable validation to load_workflow_state()** (20 min)
   - Update function signature to accept optional required variables
   - Add validation loop to check each required variable exists
   - Generate detailed error with missing variables list
   - Add state file content dump to error output
   - Return exit code 3 for validation failures
   - Verification: Test with missing variables triggers proper error

2. **Update coordinate.md to use validation** (10 min)
   - Change all `load_workflow_state "$WORKFLOW_ID"` calls
   - Add required variables list: `load_workflow_state "$WORKFLOW_ID" false "CLASSIFICATION_JSON"`
   - Update other critical variables (STATE_MACHINE_CONFIG, etc.)
   - Verification: Missing CLASSIFICATION_JSON triggers enhanced error

3. **Test enhanced diagnostics** (5 min)
   - Create test state file without CLASSIFICATION_JSON
   - Run coordinate command and verify error message quality
   - Confirm state file contents displayed in error
   - Verification: Error message shows exact missing variables and file contents

**Implementation Details for Step 1**:

```bash
# In /home/benjamin/.config/.claude/lib/state-persistence.sh
# Update load_workflow_state() function (lines 191-233)

load_workflow_state() {
  local workflow_id="${1:-$$}"
  local is_first_block="${2:-false}"
  shift 2 2>/dev/null || true  # Remove first two args, ignore if none left
  local required_vars=("$@")  # Remaining args are required variable names

  local state_file="${CLAUDE_PROJECT_DIR:-$HOME}/.claude/tmp/workflow_${workflow_id}.sh"

  if [ -f "$state_file" ]; then
    # State file exists - source it to restore variables
    source "$state_file"

    # NEW: Validate required variables if specified
    if [ ${#required_vars[@]} -gt 0 ]; then
      local missing_vars=()
      for var_name in "${required_vars[@]}"; do
        # Use indirect reference to check if variable is set and non-empty
        if [ -z "${!var_name:-}" ]; then
          missing_vars+=("$var_name")
        fi
      done

      if [ ${#missing_vars[@]} -gt 0 ]; then
        echo "" >&2
        echo "❌ CRITICAL ERROR: Required variables missing from workflow state" >&2
        echo "" >&2
        echo "Missing variables: ${missing_vars[*]}" >&2
        echo "State file: $state_file" >&2
        echo "" >&2
        echo "State file contents:" >&2
        echo "─────────────────────────────────────────" >&2
        cat "$state_file" >&2
        echo "─────────────────────────────────────────" >&2
        echo "" >&2
        echo "Diagnostic:" >&2
        echo "  - State file was sourced successfully" >&2
        echo "  - But required variables were not found in the file" >&2
        echo "  - This indicates the component responsible for saving state failed" >&2
        echo "  - Check the bash block execution prior to this load" >&2
        echo "" >&2
        return 3  # Exit code 3 = validation error
      fi
    fi

    return 0
  else
    # Spec 672 Phase 3: Distinguish expected vs unexpected missing state files
    if [ "$is_first_block" = "true" ]; then
      # Expected case: First bash block of workflow, state file doesn't exist yet
      init_workflow_state "$workflow_id" >/dev/null
      return 1
    else
      # CRITICAL ERROR: Subsequent bash block, state file should exist but doesn't
      echo "" >&2
      echo "❌ CRITICAL ERROR: Workflow state file not found" >&2
      echo "" >&2
      echo "Context:" >&2
      echo "  Expected state file: $state_file" >&2
      echo "  Workflow ID: $workflow_id" >&2
      echo "  Block type: Subsequent block (is_first_block=false)" >&2
      # ... (existing diagnostic output continues)
      return 2  # Exit code 2 = configuration error
    fi
  fi
}
```

**Testing Verification**:

```bash
# Test: Variable validation detects missing state
#!/usr/bin/env bash
source /home/benjamin/.config/.claude/lib/state-persistence.sh

# Create test state without CLASSIFICATION_JSON
TEST_ID="test_validation_$$"
STATE_FILE=$(init_workflow_state "$TEST_ID")
append_workflow_state "OTHER_VAR" "test_value"

# Should fail with clear error showing CLASSIFICATION_JSON missing
load_workflow_state "$TEST_ID" false "CLASSIFICATION_JSON"
EXIT_CODE=$?

if [ $EXIT_CODE -eq 3 ]; then
  echo "✓ Test passed: Missing variable correctly detected"
else
  echo "✗ Test failed: Expected exit code 3, got $EXIT_CODE"
fi

# Cleanup
rm -f "$STATE_FILE"
```

**Success Criteria**:
- [ ] load_workflow_state() supports optional variable validation
- [ ] Missing variables trigger exit code 3
- [ ] Error message lists all missing variables
- [ ] State file contents displayed in error output
- [ ] Backward compatible (validation optional)

**Rollback Plan**:
- Revert state-persistence.sh to current version
- Remove validation parameters from coordinate.md
- Document performance impact if any

### Phase 3: Architectural Improvements and Documentation (P2)

**Objective**: Long-term maintainability and prevention of similar issues

**Duration**: 2 hours 45 minutes

**Steps**:

1. **Migrate to JSON checkpoints for classification** (45 min)
   - Create convenience function for classification checkpoints
   - Update coordinate.md to save classification as JSON checkpoint
   - Update state loading to try checkpoint first, fall back to state variable
   - Add checkpoint cleanup to workflow completion handlers
   - Verification: Classification stored as atomic JSON file

2. **Document Task tool execution isolation** (30 min)
   - Create or update `.claude/docs/concepts/bash-block-execution-model.md`
   - Add section on Task tool execution isolation
   - Provide examples of correct state persistence patterns
   - Document anti-patterns (agent bash in isolated context)
   - Verification: Documentation reviewed and committed

3. **Create agent behavioral file validator** (60 min)
   - Create `/home/benjamin/.config/.claude/scripts/validate-agent-behavioral-file.sh`
   - Check allowed-tools matches bash execution instructions
   - Validate model appropriate for allowed tools
   - Check timeout aligns with expected tool usage
   - Add to pre-commit hooks or CI if applicable
   - Verification: Validator catches workflow-classifier contradiction

4. **Standardize state file locations** (30 min)
   - Add deprecation warning if `.claude/data/workflows/*.state` detected
   - Update any legacy references to new `.claude/tmp/workflow_*.sh` pattern
   - Document standard in state-persistence.sh header comment
   - Add cleanup of legacy location to state initialization
   - Verification: No references to legacy location remain

**Implementation Details for Step 1 (JSON Checkpoints)**:

```bash
# In /home/benjamin/.config/.claude/lib/state-persistence.sh
# Add new convenience function after save_json_checkpoint()

save_classification_checkpoint() {
  local classification_json="$1"
  local checkpoint_name="${2:-workflow_classification}"

  # Validate JSON before saving
  if ! echo "$classification_json" | jq empty 2>/dev/null; then
    echo "ERROR: Invalid JSON in classification" >&2
    return 1
  fi

  # Save as JSON checkpoint (atomic write)
  save_json_checkpoint "$checkpoint_name" "$classification_json"

  # Also save to bash state for backward compatibility
  append_workflow_state "CLASSIFICATION_JSON" "$classification_json"
}

load_classification_checkpoint() {
  local checkpoint_name="${1:-workflow_classification}"

  # Try JSON checkpoint first (preferred method)
  local classification_json
  classification_json=$(load_json_checkpoint "$checkpoint_name")

  # If checkpoint exists and valid, return it
  if [ "$classification_json" != "{}" ] && [ -n "$classification_json" ]; then
    echo "$classification_json"
    return 0
  fi

  # Fall back to bash state variable (legacy)
  if [ -n "${CLASSIFICATION_JSON:-}" ]; then
    echo "$CLASSIFICATION_JSON"
    return 0
  fi

  # Neither method found classification
  echo "{}"
  return 1
}
```

**Implementation Details for Step 3 (Agent Validator)**:

```bash
#!/usr/bin/env bash
# /home/benjamin/.config/.claude/scripts/validate-agent-behavioral-file.sh

set -euo pipefail

AGENT_FILE="${1:?Usage: $0 <agent-file.md>}"

if [ ! -f "$AGENT_FILE" ]; then
  echo "ERROR: Agent file not found: $AGENT_FILE" >&2
  exit 1
fi

echo "Validating agent behavioral file: $AGENT_FILE"

# Extract frontmatter
FRONTMATTER=$(sed -n '/^---$/,/^---$/p' "$AGENT_FILE" | sed '1d;$d')
ALLOWED_TOOLS=$(echo "$FRONTMATTER" | grep "^allowed-tools:" | cut -d: -f2 | xargs)

# Check for bash execution instructions in body
BASH_INSTRUCTIONS=$(grep -c "USE the Bash tool" "$AGENT_FILE" || true)
BASH_CODE_BLOCKS=$(grep -c '```bash' "$AGENT_FILE" || true)

echo "  Allowed tools: $ALLOWED_TOOLS"
echo "  Bash instructions: $BASH_INSTRUCTIONS"
echo "  Bash code blocks: $BASH_CODE_BLOCKS"

# Validate: if allowed-tools is "None", should not have bash instructions
if [ "$ALLOWED_TOOLS" = "None" ] && [ "$BASH_INSTRUCTIONS" -gt 0 ]; then
  echo "❌ VALIDATION FAILED: Agent has allowed-tools: None but contains bash execution instructions"
  echo "  This is contradictory - agent cannot execute bash commands"
  echo "  Fix: Either change allowed-tools to include Bash, or remove bash instructions"
  exit 1
fi

if [ "$ALLOWED_TOOLS" = "None" ] && [ "$BASH_CODE_BLOCKS" -gt 0 ]; then
  echo "⚠️  WARNING: Agent has allowed-tools: None but contains bash code blocks"
  echo "  Agent may not be able to execute these code blocks"
fi

echo "✓ Agent behavioral file validation passed"
exit 0
```

**Testing Verification for Step 1**:

```bash
# Test JSON checkpoint migration
source /home/benjamin/.config/.claude/lib/state-persistence.sh

TEST_ID="test_checkpoint_$$"
init_workflow_state "$TEST_ID"

TEST_JSON='{"workflow_type":"research-only","confidence":0.95,"research_complexity":2}'

# Save using new checkpoint function
save_classification_checkpoint "$TEST_JSON"

# Load using new checkpoint function
LOADED_JSON=$(load_classification_checkpoint)

if [ "$LOADED_JSON" = "$TEST_JSON" ]; then
  echo "✓ Checkpoint save/load test passed"
else
  echo "✗ Checkpoint test failed"
  echo "Expected: $TEST_JSON"
  echo "Got: $LOADED_JSON"
fi
```

**Testing Verification for Step 3**:

```bash
# Test validator catches contradictions
/home/benjamin/.config/.claude/scripts/validate-agent-behavioral-file.sh \
  /home/benjamin/.config/.claude/agents/workflow-classifier.md

# Should fail with validation error (before fixes applied)
# After Phase 1 fixes, should pass validation
```

**Success Criteria**:
- [ ] Classification stored as atomic JSON checkpoint
- [ ] Task tool isolation documented with examples
- [ ] Agent validator detects behavioral file contradictions
- [ ] State file locations standardized across codebase
- [ ] All documentation updated and committed

**Rollback Plan**:
- JSON checkpoints: Revert to bash state variables only
- Documentation: Archive in draft folder
- Validator: Remove from scripts directory
- Location standardization: Keep existing patterns

## Testing Strategy

### Unit Tests

**Test Suite 1: State Persistence Library**

```bash
#!/usr/bin/env bash
# /home/benjamin/.config/.claude/tests/test-state-persistence-validation.sh

source /home/benjamin/.config/.claude/lib/state-persistence.sh

echo "Testing load_workflow_state() variable validation..."

# Test 1: Load with validation should succeed when variable exists
TEST_ID="test_pass_$$"
STATE_FILE=$(init_workflow_state "$TEST_ID")
append_workflow_state "TEST_VAR" "test_value"

if load_workflow_state "$TEST_ID" false "TEST_VAR"; then
  echo "✓ Test 1 passed: Variable validation succeeded"
else
  echo "✗ Test 1 failed: Variable validation failed unexpectedly"
  exit 1
fi

# Test 2: Load with missing variable should fail with exit code 3
TEST_ID2="test_fail_$$"
STATE_FILE2=$(init_workflow_state "$TEST_ID2")
append_workflow_state "OTHER_VAR" "other_value"

load_workflow_state "$TEST_ID2" false "MISSING_VAR" 2>/dev/null
EXIT_CODE=$?

if [ $EXIT_CODE -eq 3 ]; then
  echo "✓ Test 2 passed: Missing variable detected with correct exit code"
else
  echo "✗ Test 2 failed: Expected exit code 3, got $EXIT_CODE"
  exit 1
fi

# Test 3: Multiple variables validation
TEST_ID3="test_multi_$$"
STATE_FILE3=$(init_workflow_state "$TEST_ID3")
append_workflow_state "VAR1" "value1"
append_workflow_state "VAR2" "value2"

if load_workflow_state "$TEST_ID3" false "VAR1" "VAR2"; then
  echo "✓ Test 3 passed: Multiple variable validation succeeded"
else
  echo "✗ Test 3 failed: Multiple variable validation failed"
  exit 1
fi

# Cleanup
rm -f "$STATE_FILE" "$STATE_FILE2" "$STATE_FILE3"

echo "✓ All state persistence validation tests passed"
```

**Test Suite 2: Classification JSON Handling**

```bash
#!/usr/bin/env bash
# /home/benjamin/.config/.claude/tests/test-classification-json-escaping.sh

source /home/benjamin/.config/.claude/lib/state-persistence.sh

echo "Testing classification JSON escaping..."

TEST_ID="test_json_$$"
STATE_FILE=$(init_workflow_state "$TEST_ID")

# Complex JSON with quotes, nested objects, arrays
TEST_JSON='{"workflow_type":"research-and-plan","confidence":0.92,"research_topics":[{"name":"Topic 1","description":"Description with \"quotes\""}],"nested":{"deep":{"value":"test"}}}'

append_workflow_state "CLASSIFICATION_JSON" "$TEST_JSON"
load_workflow_state "$TEST_ID"

# Verify JSON round-trips correctly and is valid
if echo "$CLASSIFICATION_JSON" | jq empty 2>/dev/null; then
  echo "✓ JSON escaping test passed - valid JSON after round-trip"
else
  echo "✗ JSON escaping test failed - invalid JSON after round-trip"
  echo "Original: $TEST_JSON"
  echo "Loaded: ${CLASSIFICATION_JSON:-<not set>}"
  exit 1
fi

# Verify content matches
ORIGINAL_TYPE=$(echo "$TEST_JSON" | jq -r '.workflow_type')
LOADED_TYPE=$(echo "$CLASSIFICATION_JSON" | jq -r '.workflow_type')

if [ "$ORIGINAL_TYPE" = "$LOADED_TYPE" ]; then
  echo "✓ JSON content preservation test passed"
else
  echo "✗ JSON content changed during round-trip"
  exit 1
fi

rm -f "$STATE_FILE"

echo "✓ All JSON escaping tests passed"
```

### Integration Tests

**Test Suite 3: End-to-End Workflow Classification**

```bash
#!/usr/bin/env bash
# /home/benjamin/.config/.claude/tests/test-coordinate-classification-e2e.sh

echo "Testing end-to-end workflow classification..."

# Test 1: Research workflow
echo "Test 1: Research workflow classification"
# Note: This requires manual execution or Claude invocation
# /coordinate "research authentication patterns"
# Verify:
# - CLASSIFICATION_JSON saved to state
# - workflow_type = "research-only"
# - State file exists at .claude/tmp/workflow_coordinate_*.sh

# Test 2: Implementation workflow
echo "Test 2: Implementation workflow classification"
# /coordinate "implement user registration feature"
# Verify:
# - workflow_type = "full-implementation"
# - research_complexity >= 2

# Test 3: Debug workflow
echo "Test 3: Debug workflow classification"
# /coordinate "debug the login validation bug"
# Verify:
# - workflow_type = "debug-only"

echo "✓ Manual verification required for integration tests"
echo "  Run /coordinate with different workflow descriptions"
echo "  Verify CLASSIFICATION_JSON persists correctly"
```

### Regression Tests

**Test Suite 4: State File Location Verification**

```bash
#!/usr/bin/env bash
# /home/benjamin/.config/.claude/tests/test-state-file-locations.sh

echo "Testing state file location standards..."

# Verify correct location pattern
CORRECT_PATTERN="/home/benjamin/.config/.claude/tmp/workflow_*.sh"
INCORRECT_PATTERN="/home/benjamin/.config/.claude/data/workflows/*.state"

# Check for files in correct location (expected after workflow runs)
if ls ${CORRECT_PATTERN} 2>/dev/null | head -1 >/dev/null; then
  echo "✓ State files found in correct location: .claude/tmp/"
else
  echo "ℹ️  No active state files (expected if no workflows running)"
fi

# Check for files in incorrect location (should not exist)
if ls ${INCORRECT_PATTERN} 2>/dev/null | head -1 >/dev/null; then
  echo "⚠️  WARNING: Legacy state files found in .claude/data/workflows/"
  echo "   These should be migrated or cleaned up"
else
  echo "✓ No legacy state files in incorrect location"
fi

echo "✓ State file location tests complete"
```

### Verification Checklist

After implementing each phase, verify:

**Phase 1 Verification**:
- [ ] workflow-classifier.md has no bash execution instructions
- [ ] coordinate.md extracts classification from Task output
- [ ] CLASSIFICATION_JSON saved to state successfully
- [ ] State file contains proper export statement
- [ ] Workflow proceeds past Phase 0.1 without errors
- [ ] Test workflows: research, implement, debug all work

**Phase 2 Verification**:
- [ ] load_workflow_state() accepts variable validation parameters
- [ ] Missing variables trigger exit code 3
- [ ] Error messages show state file contents
- [ ] coordinate.md uses validation for CLASSIFICATION_JSON
- [ ] Test with intentionally missing variable shows clear error

**Phase 3 Verification**:
- [ ] Classification checkpoint functions implemented
- [ ] Documentation covers Task tool isolation patterns
- [ ] Agent validator script detects contradictions
- [ ] No legacy state file location references remain
- [ ] All tests pass

## Rollback Plan

### Phase 1 Rollback

If critical fixes cause issues:

1. **Identify failure point**:
   - Review coordinate_output.md for new error messages
   - Check state file location and contents
   - Verify Task tool output format

2. **Revert changes**:
   ```bash
   cd /home/benjamin/.config
   git checkout HEAD -- .claude/agents/workflow-classifier.md
   git checkout HEAD -- .claude/commands/coordinate.md
   ```

3. **Alternative approach**:
   - Consider Fix 2 (allowed-tools: Bash) instead
   - Update workflow-classifier.md frontmatter only
   - Keep state persistence in agent

4. **Document decision**:
   - Record why Fix 1 failed
   - Note any Task tool output parsing issues
   - Update debug report with findings

### Phase 2 Rollback

If validation enhancements cause issues:

1. **Check for false positives**:
   - Review if validation too strict
   - Verify variable existence check logic
   - Test with various state file formats

2. **Revert if needed**:
   ```bash
   git checkout HEAD -- .claude/lib/state-persistence.sh
   git checkout HEAD -- .claude/commands/coordinate.md
   ```

3. **Partial rollback option**:
   - Keep validation code but disable by default
   - Remove validation parameters from coordinate.md
   - Make validation opt-in only

### Phase 3 Rollback

If long-term improvements cause issues:

1. **Assess impact**:
   - JSON checkpoints: Check file permissions, disk space
   - Documentation: No rollback needed (harmless)
   - Validator: Check for false positives
   - Location standardization: Verify no broken references

2. **Selective rollback**:
   - Can rollback individual improvements independently
   - Keep documentation even if code reverted
   - Disable validator if too strict

3. **Recovery steps**:
   ```bash
   # Revert specific file
   git checkout HEAD -- <problematic-file>

   # Or revert entire phase
   git revert <phase-3-commit>
   ```

## Success Metrics

### Immediate Success (Phase 1)

- **Primary**: Coordinate command completes Phase 0.1 without state persistence errors
- **Quantitative**: 100% success rate for test workflows (research, implement, debug)
- **Time**: Workflow classification completes in <20 seconds (includes Haiku inference)
- **Error Rate**: Zero CLASSIFICATION_JSON unbound variable errors

### Medium-term Success (Phase 2)

- **Diagnostic Quality**: Error messages include state file contents
- **Detection Speed**: Missing variables detected immediately (fail-fast)
- **Developer Experience**: Clear, actionable error messages
- **False Positive Rate**: Zero false positives from validation

### Long-term Success (Phase 3)

- **Maintainability**: New agents avoid state persistence contradictions
- **Documentation Coverage**: Task tool isolation patterns documented with examples
- **Code Quality**: Agent validator integrated into development workflow
- **Architecture Consistency**: Single state file location pattern across codebase

## Risk Assessment

### Phase 1 Risks

**Risk**: Task tool output format changes
- **Probability**: Low
- **Impact**: High (breaks classification extraction)
- **Mitigation**: Add robust parsing with error handling; test multiple workflow types
- **Contingency**: Fall back to Fix 2 (allowed-tools: Bash)

**Risk**: JSON extraction from Task output fails
- **Probability**: Medium
- **Impact**: High
- **Mitigation**: Add validation and clear error messages
- **Contingency**: Implement inline classification (Fix 5 from root cause analysis)

### Phase 2 Risks

**Risk**: Variable validation too strict
- **Probability**: Low
- **Impact**: Medium (false positive errors)
- **Mitigation**: Test thoroughly with edge cases
- **Contingency**: Make validation opt-in only

**Risk**: Performance degradation from validation
- **Probability**: Very Low
- **Impact**: Low (1-2ms per validation)
- **Mitigation**: Benchmark before/after
- **Contingency**: Optimize validation loop

### Phase 3 Risks

**Risk**: JSON checkpoint migration breaks backward compatibility
- **Probability**: Low
- **Impact**: Medium
- **Mitigation**: Implement fallback to bash state variables
- **Contingency**: Keep dual persistence during transition

**Risk**: Agent validator false positives
- **Probability**: Medium
- **Impact**: Low (developer annoyance)
- **Mitigation**: Make validator advisory only (warnings, not errors)
- **Contingency**: Add exceptions list for known valid cases

## Timeline

### Immediate (Week 1)

**Day 1**: Phase 1 implementation and testing
- Morning: Remove state persistence from agent, update coordinate.md
- Afternoon: Test with multiple workflow types
- Evening: Document any issues, prepare rollback if needed

**Day 2**: Phase 1 verification and stabilization
- Test edge cases (quoted keywords, negations, complex descriptions)
- Monitor for any runtime issues
- Commit changes if stable

### Near-term (Week 1)

**Day 3**: Phase 2 implementation
- Morning: Enhance load_workflow_state() with validation
- Afternoon: Update coordinate.md to use validation
- Test validation error messages

**Day 4**: Phase 2 testing and refinement
- Test with intentionally broken state files
- Verify error message quality
- Commit changes

### Medium-term (Week 2)

**Day 5-7**: Phase 3 implementation
- Day 5: JSON checkpoint migration
- Day 6: Documentation and agent validator
- Day 7: Location standardization and final testing

**Day 8**: Review and cleanup
- Run full test suite
- Update documentation
- Final commit and close debug spec

## Appendix A: Implementation Commands

### Phase 1 Quick Commands

```bash
# Remove state persistence from agent
cd /home/benjamin/.config
sed -i '530,587d' .claude/agents/workflow-classifier.md

# Edit coordinate.md (manual - add extraction bash block after line 213)
# Use your preferred editor

# Test
/coordinate "research authentication patterns"
```

### Phase 2 Quick Commands

```bash
# Backup before editing
cp .claude/lib/state-persistence.sh .claude/lib/state-persistence.sh.backup

# Edit state-persistence.sh to add validation
# (Manual editing required - see implementation details above)

# Test validation
bash /home/benjamin/.config/.claude/tests/test-state-persistence-validation.sh
```

### Phase 3 Quick Commands

```bash
# Create validator script
touch .claude/scripts/validate-agent-behavioral-file.sh
chmod +x .claude/scripts/validate-agent-behavioral-file.sh
# (Add script content from implementation details)

# Run validator on all agents
for agent in .claude/agents/*.md; do
  .claude/scripts/validate-agent-behavioral-file.sh "$agent"
done
```

## Appendix B: Root Cause Summary

**Primary Root Cause**: Architectural mismatch between Task tool execution isolation and bash-based state persistence expectations.

**Contributing Factors**:
1. Agent configured with `allowed-tools: None` but instructed to execute bash commands
2. State persistence library assumes single execution context
3. No variable-level validation in load_workflow_state()
4. Unclear state file location standards (two patterns exist)

**Key Insight**: Task tool creates subprocess boundaries that prevent environment variable transfer. State persistence must occur in the parent command context, not in isolated agent contexts.

**Long-term Solution**: Document execution isolation patterns and prevent similar architectural mismatches through validation and better agent behavioral file guidelines.

## Appendix C: Alternative Solutions Not Pursued

### Alternative 1: Inline Classification (Not Recommended)

Moving classification logic entirely into coordinate.md bash blocks would eliminate agent dependency but loses semantic analysis capabilities from LLM. Keyword matching is less accurate for edge cases (quotes, negations, complex intent).

**Decision**: Keep LLM classification for quality, fix state persistence architecture instead.

### Alternative 2: Agent with Bash Tool (Higher Risk)

Changing workflow-classifier to `allowed-tools: Bash` would allow agent to execute state persistence, but Task tool isolation may still prevent access to parent STATE_FILE variable. Higher risk of same failure in different form.

**Decision**: Move state persistence to parent context (lower risk, clearer architecture).

### Alternative 3: Shared Memory or IPC (Over-Engineering)

Using shared memory, named pipes, or other IPC mechanisms for agent-parent communication would add significant complexity for minimal benefit. File-based state persistence is sufficient and follows established patterns.

**Decision**: Keep file-based approach, fix the architectural mismatch.

---

**Plan Status**: READY FOR IMPLEMENTATION
**Created**: 2025-11-17
**Spec**: 752_debug_coordinate_workflow_classifier
**Plan**: 001_debug_strategy.md
**Total Estimated Time**: 3 hours 20 minutes across 3 phases
