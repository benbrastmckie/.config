# /revise Command Error Repair Plan

## Metadata
- **Date**: 2025-11-29
- **Feature**: Repair /revise workflow errors
- **Scope**: Fix xargs quote handling, state persistence, function references, and regex escaping issues
- **Estimated Phases**: 6
- **Estimated Hours**: 7
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Status**: [COMPLETE]
- **Structure Level**: 0
- **Complexity Score**: 42.0
- **Research Reports**:
  - [Error Analysis Report](/home/benjamin/.config/.claude/specs/972_repair_revise_20251129_165201/reports/001-error-analysis.md)
  - [Gap Analysis Report](/home/benjamin/.config/.claude/specs/972_repair_revise_20251129_165201/reports/002-revision-gap-analysis.md)

## Overview

This plan addresses critical errors in the /revise command workflow that cause 100% failure rate for recent executions. Gap analysis reveals the most critical issue is xargs quote handling errors that block execution when user input contains single quotes. Additional failure modes include: STATE_FILE not set during state transitions (40%), nonexistent function calls (20%), sed regex errors with unescaped special characters (30%), and premature state ID file cleanup. The xargs quote handling error is a blocking error not captured in the original error log analysis and must be addressed first.

## Research Summary

Error analysis and gap analysis reports identified the following critical patterns:

**From Observed Execution (Gap Analysis)**:
- **xargs quote handling error (CRITICAL)**: Lines 133, 149, 157, 209 use `| xargs` for whitespace trimming, which breaks when user input contains single quotes (e.g., "user's feedback")
- **State ID file cleanup timing**: Block 6 cleans up STATE_ID_FILE prematurely (lines 1214-1216) before error handlers may need WORKFLOW_ID

**From Error Log Analysis**:
- **Pattern 1 (40%)**: STATE_FILE not set during sm_transition calls - indicates load_workflow_state not called before state transitions
- **Pattern 2 (20%)**: save_completed_states_to_state function not found (exit code 127) - function does not exist in state-persistence.sh library
- **Pattern 3 (30%)**: sed regex errors at line 209 - EXISTING_PLAN_PATH contains unescaped special characters before regex escaping at line 208

Root cause analysis confirms:
1. **xargs is not quote-safe** - breaks on single/double quotes in user input (BLOCKING ERROR)
2. Subprocess isolation pattern violated (state not loaded before sm_transition)
3. Function name mismatch or removal from state-persistence.sh library
4. Regex escaping happens too late in the workflow (after first usage)
5. STATE_ID_FILE cleanup prevents error handlers from accessing WORKFLOW_ID

Recommended approach: Replace xargs with bash parameter trimming (highest priority), add defensive STATE_FILE validation, remove nonexistent function calls, move regex escaping earlier, defer state ID file cleanup, and add comprehensive state load verification.

## Success Criteria
- [ ] All xargs usages replaced with quote-safe bash parameter trimming (lines 133, 149, 157, 209)
- [ ] /revise command handles single quotes in revision descriptions without errors
- [ ] All sm_transition calls have STATE_FILE validation guards
- [ ] All save_completed_states_to_state calls removed or replaced with correct function
- [ ] EXISTING_PLAN_PATH escaped immediately after extraction (before line 209 usage)
- [ ] All bash blocks calling sm_transition first call load_workflow_state
- [ ] STATE_ID_FILE cleanup deferred or removed to preserve WORKFLOW_ID for error handlers
- [ ] Error log entries marked RESOLVED after successful fix verification
- [ ] /revise command executes successfully end-to-end with quote-containing inputs

## Technical Design

### Architecture Changes

**Quote-Safe Whitespace Trimming (CRITICAL)**:
Replace all `| xargs` usage with bash parameter expansion for quote-safe whitespace trimming. The current pattern breaks when user input contains single quotes (e.g., "revise plan based on user's feedback"). This is a blocking error that prevents command execution entirely.

Pattern replacement:
```bash
# BEFORE (quote-unsafe)
VAR=$(echo "$VAR" | sed 's/pattern//' | xargs)

# AFTER (quote-safe)
VAR=$(echo "$VAR" | sed 's/pattern//')
VAR="${VAR#"${VAR%%[![:space:]]*}"}"  # Trim leading whitespace
VAR="${VAR%"${VAR##*[![:space:]]}"}"  # Trim trailing whitespace
```

Affects lines 133, 149, 157, 209 in revise.md.

**State ID File Cleanup Deferral**:
Remove premature cleanup of STATE_ID_FILE at Block 6 completion (lines 1214-1216). The cleanup happens before error handlers may need WORKFLOW_ID for diagnostic purposes. Let system cleanup handle tmp/ directory files, or move cleanup to EXIT trap that fires after all error handling completes.

**State Transition Safety Layer**:
Add defensive checks before every sm_transition call to ensure STATE_FILE is set. This prevents 40% of logged errors by catching subprocess isolation violations early.

**Function Compatibility Layer**:
Remove calls to save_completed_states_to_state (function does not exist in state-persistence.sh v1.5.0+). Analysis shows this function is called at lines 552, 717, 907, 1092 but no such function exists in the library. Since state machine already persists completed states, these calls are likely redundant or vestigial.

**Regex Escaping Reordering**:
Move EXISTING_PLAN_PATH escaping from line 208 to immediately after extraction at line 191. This ensures ESCAPED_PLAN_PATH is available for first sed usage at line 209.

**State Load Verification**:
Add reusable verification function to validate STATE_FILE, required variables, and state file existence after load_workflow_state calls.

### Component Interaction

```
Block 2 (Validation)
  ↓
  [NEW] Parse flags with quote-safe trimming (lines 133, 149, 157)
  ↓
  Extract EXISTING_PLAN_PATH (line 191)
  ↓
  [NEW] Escape immediately after extraction
  ↓
  [NEW] Extract REVISION_DETAILS with quote-safe trimming (line 209)
  ↓
  Use ESCAPED_PLAN_PATH in sed (line 209)

Block 3 (Init)
  ↓
  Source libraries
  ↓
  Initialize state machine
  ↓
  save_workflow_state

Block 4a, 5a, 6 (Execution)
  ↓
  load_workflow_state
  ↓
  [NEW] verify_state_loaded (defensive check)
  ↓
  [NEW] Validate STATE_FILE before sm_transition
  ↓
  sm_transition (safe)

Block 6 (Completion)
  ↓
  print_artifact_summary
  ↓
  [NEW] Skip STATE_ID_FILE cleanup (preserve for error handlers)
  ↓
  exit 0
```

## Implementation Phases

### Phase 0: Replace xargs with Quote-Safe Trimming [COMPLETE]
dependencies: []

**Objective**: Replace all quote-unsafe xargs usage with bash parameter expansion to handle single quotes in user input

**Complexity**: Low

Tasks:
- [x] Replace xargs at line 133 (--complexity flag stripping):
  ```bash
  # BEFORE
  REVISION_DESCRIPTION=$(echo "$REVISION_DESCRIPTION" | sed 's/--complexity[[:space:]]*[1-4]//' | xargs)

  # AFTER
  REVISION_DESCRIPTION=$(echo "$REVISION_DESCRIPTION" | sed 's/--complexity[[:space:]]*[1-4]//')
  REVISION_DESCRIPTION="${REVISION_DESCRIPTION#"${REVISION_DESCRIPTION%%[![:space:]]*}"}"
  REVISION_DESCRIPTION="${REVISION_DESCRIPTION%"${REVISION_DESCRIPTION##*[![:space:]]}"}"
  ```
- [x] Replace xargs at line 149 (--dry-run flag stripping):
  ```bash
  # BEFORE
  REVISION_DESCRIPTION=$(echo "$REVISION_DESCRIPTION" | sed 's/--dry-run//' | xargs)

  # AFTER
  REVISION_DESCRIPTION=$(echo "$REVISION_DESCRIPTION" | sed 's/--dry-run//')
  REVISION_DESCRIPTION="${REVISION_DESCRIPTION#"${REVISION_DESCRIPTION%%[![:space:]]*}"}"
  REVISION_DESCRIPTION="${REVISION_DESCRIPTION%"${REVISION_DESCRIPTION##*[![:space:]]}"}"
  ```
- [x] Replace xargs at line 157 (--file flag stripping):
  ```bash
  # BEFORE
  REVISION_DESCRIPTION=$(echo "$REVISION_DESCRIPTION" | sed 's/--file[[:space:]]*[^[:space:]]*//' | xargs)

  # AFTER
  REVISION_DESCRIPTION=$(echo "$REVISION_DESCRIPTION" | sed 's/--file[[:space:]]*[^[:space:]]*//')
  REVISION_DESCRIPTION="${REVISION_DESCRIPTION#"${REVISION_DESCRIPTION%%[![:space:]]*}"}"
  REVISION_DESCRIPTION="${REVISION_DESCRIPTION%"${REVISION_DESCRIPTION##*[![:space:]]}"}"
  ```
- [x] Replace xargs at line 209 (REVISION_DETAILS extraction):
  ```bash
  # BEFORE
  REVISION_DETAILS=$(echo "$REVISION_DESCRIPTION" | sed "s|.*$ESCAPED_PLAN_PATH||" | xargs) || true

  # AFTER
  REVISION_DETAILS=$(echo "$REVISION_DESCRIPTION" | sed "s|.*$ESCAPED_PLAN_PATH||") || true
  REVISION_DETAILS="${REVISION_DETAILS#"${REVISION_DETAILS%%[![:space:]]*}"}"
  REVISION_DETAILS="${REVISION_DETAILS%"${REVISION_DETAILS##*[![:space:]]}"}"
  ```
- [x] Add comment explaining replacement: "# Use bash parameter expansion instead of xargs for quote-safe trimming"
- [x] Test with single quotes in revision description: `"revise plan at ./test.md based on user's feedback"`
- [x] Test with double quotes: `"revise plan at ./test.md based on \"new requirements\""`
- [x] Verify whitespace trimming still works correctly

Testing:
```bash
# Test single quote handling
TEST_INPUT="revise plan at ./test.md based on user's feedback"
REVISION_DESCRIPTION="$TEST_INPUT"
# After replacement, should not error with "xargs: unmatched single quote"

# Test double quote handling
TEST_INPUT='revise plan at ./test.md based on "new requirements"'
REVISION_DESCRIPTION="$TEST_INPUT"
# Should handle double quotes correctly

# Test whitespace trimming
TEST_INPUT="  revise plan at ./test.md   "
REVISION_DESCRIPTION=$(echo "$TEST_INPUT" | sed 's/revise/update/')
REVISION_DESCRIPTION="${REVISION_DESCRIPTION#"${REVISION_DESCRIPTION%%[![:space:]]*}"}"
REVISION_DESCRIPTION="${REVISION_DESCRIPTION%"${REVISION_DESCRIPTION##*[![:space:]]}"}"
echo "[$REVISION_DESCRIPTION]"
# Should show [update plan at ./test.md] without leading/trailing spaces
```

**Expected Duration**: 0.5 hours

### Phase 1: Remove Nonexistent Function Calls [COMPLETE]
dependencies: []

**Objective**: Eliminate all calls to save_completed_states_to_state which does not exist in state-persistence.sh library

**Complexity**: Low

Tasks:
- [x] Search for all save_completed_states_to_state calls in revise.md (lines 552, 717, 907, 1092)
- [x] Verify function does not exist in state-persistence.sh library (already confirmed)
- [x] Remove or comment out all four function calls (lines 552, 717, 907, 1092)
- [x] Add comment explaining removal: "# Removed: save_completed_states_to_state does not exist in library"
- [x] Verify state machine already persists completed states (no functionality loss)

Testing:
```bash
# Verify function doesn't exist in library
grep -n "save_completed_states_to_state" /home/benjamin/.config/.claude/lib/core/state-persistence.sh
# Should return no matches

# Verify removal from revise.md
grep -n "save_completed_states_to_state" /home/benjamin/.config/.claude/commands/revise.md
# Should return no matches after removal
```

**Expected Duration**: 0.5 hours

### Phase 2: Move Regex Escaping Earlier [COMPLETE]
dependencies: []

**Objective**: Escape EXISTING_PLAN_PATH immediately after extraction to prevent sed errors at line 209

**Complexity**: Low

Tasks:
- [x] Locate EXISTING_PLAN_PATH extraction at line 191 in Block 2
- [x] Move regex escaping code from line 208 to immediately after line 191 (new line 192)
- [x] Rename variable to ESCAPED_PLAN_PATH for clarity
- [x] Update sed usage at line 209 to use ESCAPED_PLAN_PATH instead of EXISTING_PLAN_PATH
- [x] Add validation that EXISTING_PLAN_PATH is non-empty before escaping
- [x] Verify escaping handles all special regex characters: [.*^$()+?{|]

Testing:
```bash
# Test with plan path containing special characters
TEST_PATH=".claude/specs/123_test.fix/plans/001_plan.md"
ESCAPED=$(printf '%s\n' "$TEST_PATH" | sed 's/[[\.*^$()+?{|]/\\&/g')
echo "Original: $TEST_PATH"
echo "Escaped: $ESCAPED"
# Should show escaped dots and slashes
```

**Expected Duration**: 1 hour

### Phase 3: Add STATE_FILE Validation Before Transitions [COMPLETE]
dependencies: []

**Objective**: Add defensive STATE_FILE checks before every sm_transition call to prevent subprocess isolation violations

**Complexity**: Medium

Tasks:
- [x] Identify all sm_transition calls in revise.md (lines 503, 840, 1160)
- [x] Add STATE_FILE validation guard before each sm_transition:
  ```bash
  if [ -z "${STATE_FILE:-}" ]; then
    log_command_error "state_error" "STATE_FILE not set before sm_transition" "bash_block_N" \
      "$(jq -n --arg workflow "$WORKFLOW_ID" '{workflow_id: $workflow}')"
    echo "ERROR: STATE_FILE not set. Call load_workflow_state first." >&2
    exit 1
  fi
  ```
- [x] Test validation triggers correctly when STATE_FILE unset
- [x] Verify error log captures diagnostic information (workflow_id, bash_block)
- [x] Ensure validation does not trigger false positives when STATE_FILE is set

Testing:
```bash
# Test STATE_FILE validation (should fail)
unset STATE_FILE
# Run sm_transition call - should exit with error message

# Test with STATE_FILE set (should succeed)
export STATE_FILE="/tmp/test_state.json"
# Run sm_transition call - should proceed normally
```

**Expected Duration**: 1.5 hours

### Phase 4: Add Comprehensive State Load Verification [COMPLETE]
dependencies: [3]

**Objective**: Create reusable verification function to validate state load success and required variables

**Complexity**: Medium

Tasks:
- [x] Add verify_state_loaded function to revise.md after library sourcing (Block 3)
  ```bash
  verify_state_loaded() {
    local required_vars="$1"  # Space-separated list

    if [ -z "${STATE_FILE:-}" ]; then
      echo "ERROR: STATE_FILE not set after load_workflow_state" >&2
      return 1
    fi

    if [ ! -f "$STATE_FILE" ]; then
      echo "ERROR: State file not found: $STATE_FILE" >&2
      return 1
    fi

    for var in $required_vars; do
      local var_value="${!var:-}"
      if [ -z "$var_value" ]; then
        echo "ERROR: Required variable $var not restored after state load" >&2
        return 1
      fi
    done

    return 0
  }
  ```
- [x] Call verify_state_loaded after each load_workflow_state (lines 420, 636, 757, 993, 1145)
- [x] Define required variables per block:
  - Block 4a: EXISTING_PLAN_PATH REVISION_DETAILS RESEARCH_COMPLEXITY
  - Block 5a: EXISTING_PLAN_PATH REVISION_DETAILS RESEARCH_REPORTS
  - Block 6: EXISTING_PLAN_PATH REVISION_DETAILS REVISED_PLAN_PATH
- [x] Test verification catches missing variables
- [x] Verify bash 4+ compatibility (uses ${!var} indirect expansion)

Testing:
```bash
# Test with missing variable (should fail)
unset EXISTING_PLAN_PATH
verify_state_loaded "EXISTING_PLAN_PATH REVISION_DETAILS" || echo "Caught missing variable"

# Test with all variables set (should succeed)
export EXISTING_PLAN_PATH="/path/to/plan.md"
export REVISION_DETAILS="test revision"
verify_state_loaded "EXISTING_PLAN_PATH REVISION_DETAILS" && echo "Verification passed"
```

**Expected Duration**: 2 hours

### Phase 5: Defer State ID File Cleanup [COMPLETE]
dependencies: [0, 1, 2, 3, 4]

**Objective**: Remove premature STATE_ID_FILE cleanup to preserve WORKFLOW_ID for error handlers

**Complexity**: Low

Tasks:
- [x] Locate STATE_ID_FILE cleanup in Block 6 at lines 1214-1216
- [x] Remove or comment out the cleanup block:
  ```bash
  # BEFORE (lines 1214-1216)
  if [ -f "$STATE_ID_FILE" ]; then
    rm -f "$STATE_ID_FILE" 2>/dev/null || true
  fi

  # AFTER (remove or comment out)
  # Note: STATE_ID_FILE cleanup omitted to preserve WORKFLOW_ID for error handlers
  # System cleanup handles tmp/ directory files automatically
  ```
- [x] Add comment explaining why cleanup is deferred
- [x] Verify error handlers can still access WORKFLOW_ID after command completion
- [x] Test that tmp/ directory cleanup doesn't cause issues (files are small, system cleanup sufficient)
- [x] Alternative: Move cleanup to EXIT trap if needed (lower priority option)

Testing:
```bash
# Run /revise command and verify STATE_ID_FILE persists after completion
/revise "revise plan at ./test.md based on test"
# Check STATE_ID_FILE still exists
ls -la ~/.config/.claude/tmp/revise_state_id.txt
# Should exist and contain WORKFLOW_ID

# Verify error handlers can access it
cat ~/.config/.claude/tmp/revise_state_id.txt
# Should show workflow ID
```

**Expected Duration**: 0.5 hours

### Phase 6: Update Error Log Status and Final Validation [COMPLETE]
dependencies: [0, 1, 2, 3, 4, 5]

**Objective**: Mark resolved errors in error log, verify no FIX_PLANNED errors remain, and validate all fixes work end-to-end

**Complexity**: Low

Tasks:
- [x] Verify all fixes from Phases 0-5 are working in test execution
- [x] Test with quote-containing input to ensure Phase 0 fix works:
  ```bash
  /revise "revise plan at .claude/specs/test/plans/001.md based on user's feedback"
  ```
- [x] Use mark_errors_resolved_for_plan to update error status:
  ```bash
  source "${CLAUDE_PROJECT_DIR}/.claude/lib/core/error-handling.sh"
  mark_errors_resolved_for_plan "/home/benjamin/.config/.claude/specs/972_repair_revise_20251129_165201/plans/001-repair-revise-20251129-165201-plan.md"
  ```
- [x] Query error log to verify updates: `/errors --command /revise --status RESOLVED --limit 10`
- [x] Confirm no FIX_PLANNED errors remain for /revise command: `/errors --command /revise --status FIX_PLANNED`
- [x] Document repair completion in plan metadata (update Status to [COMPLETE])
- [x] Run comprehensive end-to-end /revise tests to validate all errors resolved

Testing:
```bash
# Check error log before marking resolved
/errors --command /revise --status FIX_PLANNED --limit 20

# Mark errors resolved
bash -c 'source .claude/lib/core/error-handling.sh; mark_errors_resolved_for_plan ".claude/specs/972_repair_revise_20251129_165201/plans/001-repair-revise-20251129-165201-plan.md"'

# Verify status updates
/errors --command /revise --status RESOLVED --limit 20
/errors --command /revise --status FIX_PLANNED --limit 5
# Should show 0 FIX_PLANNED errors
```

**Expected Duration**: 1 hour

## Testing Strategy

### Unit Testing
Each phase includes inline testing commands to verify isolated changes:
- Phase 0: Quote handling tests (single quotes, double quotes, whitespace trimming)
- Phase 1: Grep verification that function calls removed
- Phase 2: Shell-based regex escaping validation
- Phase 3: STATE_FILE validation trigger tests
- Phase 4: verify_state_loaded function behavior tests
- Phase 5: STATE_ID_FILE persistence verification

### Integration Testing
End-to-end /revise workflow testing after Phase 5 completion:
1. Create test plan file: `.claude/specs/test_revise/plans/001_test.md`
2. Test with quote-containing input (critical test for Phase 0 fix):
   ```bash
   /revise "revise plan at .claude/specs/test_revise/plans/001_test.md based on user's feedback"
   ```
3. Test with standard input:
   ```bash
   /revise "revise plan at .claude/specs/test_revise/plans/001_test.md based on test insights"
   ```
4. Verify workflow completes without errors for both tests
5. Check error log shows no new ERROR status entries for /revise
6. Validate revised plan has backup created
7. Confirm state machine reaches "complete" state
8. Verify STATE_ID_FILE persists after completion

### Error Log Validation
Query error log before and after repair:
```bash
# Before repair
/errors --command /revise --since 7d --summary
# Should show 10 errors with state_error and execution_error types

# After repair
/errors --command /revise --since 1h --summary
# Should show 0 new errors
```

### Regression Testing
Test edge cases that previously caused errors:
1. **Single quotes in input** (Phase 0 fix): `/revise "revise plan at ./test.md based on user's feedback"`
2. **Double quotes in input** (Phase 0 fix): `/revise 'revise plan at ./test.md based on "new requirements"'`
3. Plan path with special characters: `.claude/specs/123_test.fix/plans/001_plan.md`
4. Empty revision description (should fail gracefully with clear error)
5. Missing STATE_FILE before sm_transition (should be caught by validation)
6. Subprocess isolation (verify state loaded in each bash block)
7. STATE_ID_FILE availability after completion (Phase 5 fix)

## Documentation Requirements

### Code Comments
- Add inline comments explaining why xargs replaced with bash parameter expansion
- Document quote-safety requirement for user input handling
- Add inline comments explaining STATE_FILE validation purpose
- Document why save_completed_states_to_state was removed
- Note regex escaping moved earlier to prevent sed errors
- Explain verify_state_loaded function contract
- Document why STATE_ID_FILE cleanup is deferred

### Error Log Documentation
- Update error-handling.md with examples of STATE_FILE validation errors
- Document mark_errors_resolved_for_plan usage for repair workflows
- Add troubleshooting section for subprocess isolation pattern
- Document xargs quote handling error pattern and resolution

### Command Guide Updates
- Update revise-command-guide.md with fix details
- Add troubleshooting section for common error patterns
- Document quote-safe input handling requirements (Phase 0 fix)
- Document defensive state validation requirements
- Note function compatibility changes (save_completed_states_to_state removal)
- Add note about STATE_ID_FILE persistence for error handlers

## Dependencies

### External Dependencies
- state-persistence.sh library v1.5.0+ (verify function availability)
- workflow-state-machine.sh library v2.0.0+ (sm_transition function)
- error-handling.sh library (mark_errors_resolved_for_plan function)

### Library Version Validation
```bash
# Verify library versions meet requirements
source .claude/lib/core/library-version-check.sh
check_library_version "state-persistence.sh" "1.5.0"
check_library_version "workflow-state-machine.sh" "2.0.0"
```

### File Dependencies
- revise.md (command file to be modified)
- state-persistence.sh (verify function exports)
- workflow-state-machine.sh (sm_transition implementation)
- error-handling.sh (error logging functions)

## Risk Mitigation

### Backup Strategy
- Create backup of revise.md before modifications: `revise.md.backup.20251129`
- Commit changes after each phase completion
- Test rollback procedure if errors increase

### Validation Gates
- Phase 0: Quote-safe trimming must handle single quotes, double quotes, and special characters
- Phase 1: Function removal must not break any working functionality
- Phase 2: Regex escaping must handle all special characters correctly
- Phase 3: STATE_FILE validation must not create false positives
- Phase 4: verify_state_loaded must work in all bash block contexts
- Phase 5: STATE_ID_FILE deferral must not cause tmp/ directory bloat

### Rollback Plan
If errors increase after repair:
1. Restore from backup: `cp revise.md.backup.20251129 revise.md`
2. Review error log for new error patterns
3. Create new repair plan with updated root cause analysis
4. Mark current repair plan as superseded
