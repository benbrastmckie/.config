# /build Errors Repair Plan

## Metadata
- **Date**: 2025-11-29
- **Feature**: /build Command Error Repair
- **Scope**: Fix unresolved /build command errors and implement preventative measures
- **Estimated Phases**: 7
- **Estimated Hours**: 9.5
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Status**: [COMPLETE]
- **Complexity Score**: 68.0
- **Structure Level**: 0
- **Research Reports**:
  - [Error Analysis Report](/home/benjamin/.config/.claude/specs/976_repair_build_20251129_180227/reports/001-error-analysis.md)
  - [Build Output Revision Insights](/home/benjamin/.config/.claude/specs/976_repair_build_20251129_180227/reports/002-build-output-revision-insights.md)

## Overview

This repair plan addresses 27 logged errors from the /build command, with focus on the 5 unresolved ERROR status entries and the systemic issues that caused them. The error analysis reveals three primary failure patterns: execution errors (59%), state transition errors (37%), and parse errors (3%). While 78% of errors have been marked RESOLVED, indicating previous repair efforts, recurring patterns suggest underlying issues that need comprehensive fixes.

The plan implements fixes for:
1. **Defensive programming gaps** - Missing file/variable validation causing execution errors
2. **State machine transition violations** - Invalid transitions and uninitialized state variables
3. **Library sourcing issues** - Functions called before libraries are sourced (historical, now resolved)
4. **Parameter validation gaps** - Library functions called with insufficient parameters (NEW - from build output analysis)
5. **Error prevention infrastructure** - Pre-flight validation and regression tests

## Research Summary

Analysis of 27 /build command errors spanning 9 days (2025-11-21 to 2025-11-30) reveals:

**Error Distribution**:
- execution_error: 16 errors (59%) - file operations, variable initialization, test timeouts
- state_error: 10 errors (37%) - invalid transitions, uninitialized STATE_FILE
- parse_error: 1 error (4%) - context estimation failures

**Status Distribution**:
- RESOLVED: 21 errors (78%) - previous repair efforts successful
- ERROR: 5 errors (19%) - require immediate attention
- FIX_PLANNED: 1 error (4%) - repair in progress

**Root Causes Identified**:
1. **Library Sourcing Issues** (22% of errors) - `save_completed_states_to_state` function not available (exit code 127)
2. **State Machine Violations** (37% of errors) - Invalid transitions (implement→complete, debug→document), STATE_FILE not initialized
3. **Defensive Programming Gaps** (30% of errors) - Missing file existence checks, unvalidated variables, no timeout handling
4. **Parameter Validation Gaps** (NEW) - Library functions receiving insufficient parameters causing unbound variable errors (error-handling.sh:592)
5. **Error Recovery Tracking** - 78% resolved rate indicates repair workflow is effective but needs regression prevention

**New Findings from Build Output Analysis**:
- Build execution revealed unbound variable error at error-handling.sh:592 ($7 parameter missing)
- Error indicates `estimate_context_for_agents` or similar function called with insufficient parameters
- Build completed successfully despite error, suggesting graceful fallback but highlighting defensive programming gap
- This error pattern was not captured in the initial error log analysis (timing or coverage gap)

**Key Recommendations**:
- Add pre-flight validation to catch initialization errors early
- Enforce strict state machine sequences with early validation
- Implement defensive file/variable checks throughout
- Add parameter count validation to library functions (NEW)
- Verify error logging coverage in all bash blocks (NEW)
- Create regression test suite to prevent recurrence
- Document state machine requirements comprehensively

## Success Criteria

- [ ] All 5 unresolved ERROR status errors are fixed and marked RESOLVED
- [ ] Pre-flight validation catches initialization errors before workflow execution
- [ ] State machine transitions validated at entry points, not just in sm_transition
- [ ] File existence and variable initialization validated before use
- [ ] Parameter count validated in all library functions expecting 3+ parameters
- [ ] Unbound variable error at error-handling.sh:592 is fixed and prevented
- [ ] Error logging coverage verified in all /build bash blocks
- [ ] Regression test suite prevents recurrence of resolved error patterns
- [ ] No new errors generated during repair implementation
- [ ] All fixes pass existing test suite
- [ ] Error log updated with RESOLVED status for fixed errors

## Technical Design

### Architecture Overview

The repair follows a layered approach:

**Layer 1: Pre-Flight Validation** (prevent errors before execution)
- Validate library sourcing and function availability
- Check STATE_FILE initialization requirements
- Verify PLAN_FILE argument validity

**Layer 2: Defensive Programming** (graceful handling during execution)
- File existence checks before grep/read operations
- Variable initialization validation before use
- Parameter count validation in library functions
- Timeout handling for long-running operations
- Fallback behavior for non-critical operations

**Layer 3: State Machine Enforcement** (correct workflow sequencing)
- Early STATE_FILE validation in sm_transition
- Phase entry point validation (before invoking sm_transition)
- Strict sequence enforcement: implement→test→complete
- Idempotent same-state transitions (early-exit)

**Layer 4: Regression Prevention** (ensure fixes remain effective)
- Test cases for each resolved error pattern
- Pre-commit hook integration
- Automated regression tests in CI
- Documentation of expected behavior

### Component Interactions

```
/build command startup
    ↓
Pre-Flight Validation
    ├─ Library sourcing check → FAIL FAST if missing
    ├─ Function existence check → FAIL FAST if not found
    └─ STATE_FILE readiness check → FAIL FAST if conditions not met
    ↓
Block 1: Setup + State Init
    ├─ init_workflow_state → creates STATE_FILE
    ├─ Defensive check: STATE_FILE exists after init
    └─ sm_init with validation
    ↓
Block 2: Implementer-Coordinator
    ├─ Phase entry validation (before sm_transition)
    ├─ Defensive file checks before operations
    └─ Variable validation before use
    ↓
Block 3: Verification
    ├─ Defensive directory existence checks
    ├─ Defensive file count validation
    └─ Summary content validation
```

### Key Design Decisions

1. **Pre-flight over inline**: Catch errors before workflow starts rather than mid-execution
2. **Defensive by default**: All file/variable operations wrapped in existence/validation checks
3. **Fail-fast pattern**: Invalid state detected early with clear error messages
4. **Layered validation**: Both state machine and phase entry points validate transitions
5. **Non-breaking fixes**: All changes backward compatible with existing workflows

## Implementation Phases

### Phase 1: Pre-Flight Validation Infrastructure [COMPLETE]
dependencies: []

**Objective**: Implement comprehensive pre-flight validation to catch initialization errors before workflow execution begins

**Complexity**: Medium

**Tasks**:
- [x] Create `validate_build_prerequisites()` function in build.md Block 1
- [x] Add library sourcing validation (state-persistence.sh, workflow-state-machine.sh, error-handling.sh)
- [x] Add function existence check using `declare -F save_completed_states_to_state`
- [x] Add STATE_FILE initialization readiness check (not that it exists yet, but that load_workflow_state will be called)
- [x] Add PLAN_FILE argument validation (file exists, is readable)
- [x] Call validation function immediately after library sourcing in Block 1
- [x] Add clear error messages with troubleshooting hints for each validation failure
- [x] Test validation with missing libraries (expect fail-fast behavior)
- [x] Test validation with invalid PLAN_FILE (expect fail-fast behavior)

**Testing**:
```bash
# Test pre-flight validation catches missing libraries
cd /home/benjamin/.config
# Temporarily rename library to test detection
mv .claude/lib/workflow/workflow-state-machine.sh .claude/lib/workflow/workflow-state-machine.sh.backup
bash -c "source .claude/commands/build.md" 2>&1 | grep -q "workflow-state-machine.sh"
RESULT=$?
mv .claude/lib/workflow/workflow-state-machine.sh.backup .claude/lib/workflow/workflow-state-machine.sh
[ $RESULT -eq 0 ] && echo "PASS: Pre-flight catches missing library" || echo "FAIL"

# Test pre-flight validation catches invalid PLAN_FILE
bash -c "echo '/build /nonexistent/plan.md' | source .claude/commands/build.md" 2>&1 | grep -q "Plan file not found"
[ $? -eq 0 ] && echo "PASS: Pre-flight catches invalid plan" || echo "FAIL"
```

**Expected Duration**: 2 hours

### Phase 2: State Machine Early Validation [COMPLETE]
dependencies: [1]

**Objective**: Add STATE_FILE validation at sm_transition entry and enforce strict state sequences

**Complexity**: High

**Tasks**:
- [x] Add STATE_FILE existence check at beginning of sm_transition() in workflow-state-machine.sh
- [x] Add clear error message: "STATE_FILE not set during sm_transition - load_workflow_state not called"
- [x] Update STATE_TRANSITIONS table to remove implement→complete shortcut (enforce test phase)
- [x] Add debug→document as valid transition if not already present
- [x] Document idempotent same-state transition behavior in function header
- [x] Add phase entry validation in implementer-coordinator.md before calling sm_transition
- [x] Add validation helper: `validate_state_transition_allowed "$FROM_STATE" "$TO_STATE"`
- [x] Test STATE_FILE validation with uninitialized state (expect error, not crash)
- [x] Test state sequence enforcement (implement→complete should fail)
- [x] Test idempotent transitions (test→test should succeed with early-exit)

**Testing**:
```bash
# Test STATE_FILE validation in sm_transition
cd /home/benjamin/.config
source .claude/lib/core/state-persistence.sh 2>/dev/null
source .claude/lib/workflow/workflow-state-machine.sh 2>/dev/null

# Attempt transition without STATE_FILE set
unset STATE_FILE
sm_transition "implement" "test" 2>&1 | grep -q "STATE_FILE not set"
[ $? -eq 0 ] && echo "PASS: sm_transition validates STATE_FILE" || echo "FAIL"

# Test strict sequence enforcement
WORKFLOW_ID="test_$(date +%s)"
STATE_FILE=$(init_workflow_state "$WORKFLOW_ID")
sm_init "test_plan.md" "test" "full-implementation" "1" "[]"
sm_transition "implement" "Starting test" 2>&1
# This should fail - implement cannot go to complete directly
sm_transition "complete" "Invalid shortcut" 2>&1 | grep -q "Invalid state transition"
[ $? -eq 0 ] && echo "PASS: Enforces implement→test→complete sequence" || echo "FAIL"
```

**Expected Duration**: 3 hours

### Phase 3: Defensive File and Variable Validation [COMPLETE]
dependencies: [1]

**Objective**: Add defensive checks for file existence and variable initialization throughout /build command

**Complexity**: Medium

**Tasks**:
- [x] Add file existence check before SUMMARY_FILE grep operations in build.md verification block
- [x] Add STATE_FILE validation before PLAN_FILE extraction: `[[ -f "$STATE_FILE" ]] || fail`
- [x] Add SUMMARIES_DIR existence check with mkdir -p fallback in verification
- [x] Add variable validation before use: `[[ -n "$PLAN_FILE" ]] || fail`
- [x] Add timeout handling for test command execution (pattern: `timeout 300s command || handle_timeout`)
- [x] Add fallback values for non-critical operations (e.g., context estimation defaults to 50%)
- [x] Wrap all grep operations in defensive pattern: `grep pattern file || true` where appropriate
- [x] Add error logging for defensive check failures using log_command_error
- [x] Test with missing SUMMARY_FILE (expect graceful error, not crash)
- [x] Test with empty STATE_FILE (expect validation error, not extraction failure)

**Testing**:
```bash
# Test defensive file checks
cd /home/benjamin/.config
# Create test environment
TEST_DIR=$(mktemp -d)
trap "rm -rf $TEST_DIR" EXIT

# Test missing SUMMARY_FILE handling
SUMMARIES_DIR="$TEST_DIR/summaries"
mkdir -p "$SUMMARIES_DIR"
# Should not crash when no summaries exist
bash -c "
  SUMMARIES_DIR='$SUMMARIES_DIR'
  SUMMARY_COUNT=\$(find \"\$SUMMARIES_DIR\" -name \"*.md\" -type f 2>/dev/null | wc -l)
  if [ \"\$SUMMARY_COUNT\" -eq 0 ]; then
    echo 'PASS: Defensive check caught missing summaries'
    exit 0
  fi
" && echo "Defensive check working" || echo "FAIL: Crashed on missing files"

# Test empty STATE_FILE handling
EMPTY_STATE="$TEST_DIR/empty_state.sh"
touch "$EMPTY_STATE"
bash -c "
  STATE_FILE='$EMPTY_STATE'
  [[ -f \"\$STATE_FILE\" ]] || { echo 'File not found'; exit 1; }
  PLAN_FILE=\$(grep \"^PLAN_FILE=\" \"\$STATE_FILE\" | cut -d'=' -f2- || echo '')
  [[ -n \"\$PLAN_FILE\" ]] || { echo 'PASS: Detected empty PLAN_FILE'; exit 0; }
  exit 1
" && echo "Variable validation working" || echo "FAIL"
```

**Expected Duration**: 2 hours

### Phase 4: Parameter Validation in Library Functions [COMPLETE]
dependencies: [1]

**Objective**: Add defensive parameter count validation to library functions to prevent unbound variable errors

**Complexity**: Low

**Tasks**:
- [x] Identify all library functions in error-handling.sh expecting 3+ parameters
- [x] Fix error at error-handling.sh:592 by identifying affected function (likely estimate_context_for_agents)
- [x] Add parameter count validation at function entry with clear error messages
- [x] Add parameter validation to estimate_context_for_agents function
- [x] Add parameter validation to log_command_error if it expects 7+ parameters
- [x] Add parameter validation to other multi-parameter functions in error-handling.sh
- [x] Identify call sites in /build command that may pass insufficient parameters
- [x] Fix call sites to pass all required parameters
- [x] Test functions with insufficient parameters (expect graceful error, not unbound variable crash)
- [x] Verify build output no longer shows error-handling.sh:592 error
- [x] Audit other library files for multi-parameter functions needing validation

**Testing**:
```bash
# Test parameter validation in error-handling.sh
cd /home/benjamin/.config
source .claude/lib/core/error-handling.sh 2>/dev/null

# Test estimate_context_for_agents with insufficient parameters
estimate_context_for_agents "plan.md" "agent" 2>&1 | grep -q "Expected.*parameters"
[ $? -eq 0 ] && echo "PASS: Parameter validation working" || echo "FAIL"

# Test that error returns non-zero exit code
estimate_context_for_agents "plan.md" "agent" >/dev/null 2>&1
[ $? -ne 0 ] && echo "PASS: Function returns error on validation failure" || echo "FAIL"

# Run /build to verify no unbound variable errors
# (Should not see: error-handling.sh: line 592: $7: unbound variable)
```

**Expected Duration**: 1.5 hours

### Phase 5: Regression Test Suite Implementation [COMPLETE]
dependencies: [2, 3, 4]

**Objective**: Create automated regression tests for all resolved error patterns to prevent recurrence

**Complexity**: High

**Tasks**:
- [x] Create test file: `.claude/tests/integration/test_build_error_patterns.sh`
- [x] Add test case: `save_completed_states_to_state` function availability after library sourcing
- [x] Add test case: STATE_FILE initialized before first sm_transition call
- [x] Add test case: implement→test→complete sequence enforced (implement→complete blocked)
- [x] Add test case: debug→document transition allowed
- [x] Add test case: File existence checks prevent grep failures
- [x] Add test case: Variable validation prevents empty variable usage
- [x] Add test case: Parameter count validation in library functions (NEW)
- [x] Add test case: estimate_context_for_agents rejects insufficient parameters (NEW)
- [x] Add test case: Pre-flight validation catches missing libraries
- [x] Add test case: Pre-flight validation catches invalid PLAN_FILE
- [x] Integrate regression tests with pre-commit hook (optional for /build fixes)
- [x] Add test documentation with expected behavior for each pattern
- [x] Run regression tests to verify all tests pass
- [x] Add regression test suite to CI pipeline (if applicable)

**Testing**:
```bash
# Run complete regression test suite
cd /home/benjamin/.config
bash .claude/tests/integration/test_build_error_patterns.sh

# Expected output:
# ✓ Test 1: save_completed_states_to_state function available
# ✓ Test 2: STATE_FILE initialized before transitions
# ✓ Test 3: implement→test→complete sequence enforced
# ✓ Test 4: debug→document transition allowed
# ✓ Test 5: File existence checks prevent crashes
# ✓ Test 6: Variable validation prevents empty usage
# ✓ Test 7: Parameter count validation in library functions
# ✓ Test 8: estimate_context_for_agents parameter validation
# ✓ Test 9: Pre-flight catches missing libraries
# ✓ Test 10: Pre-flight catches invalid plan file
#
# All 10 regression tests passed
```

**Expected Duration**: 2.5 hours

### Phase 6: Documentation and State Machine Reference [COMPLETE]
dependencies: [2]

**Objective**: Document state machine transition requirements and valid sequences to prevent future violations

**Complexity**: Low

**Tasks**:
- [x] Create documentation file: `.claude/docs/reference/state-machine-transitions.md`
- [x] Document 8 core states with descriptions
- [x] Document valid state transition table with ASCII diagram
- [x] Document required sequences (e.g., implement→test→complete)
- [x] Document conditional transitions (test→debug if failed, test→document if passed)
- [x] Document idempotent transition behavior (same-state transitions)
- [x] Add examples of valid transition sequences
- [x] Add examples of invalid transition sequences with error messages
- [x] Reference documentation in /build command comments
- [x] Update CLAUDE.md to reference state machine documentation
- [x] Add troubleshooting section for common state transition errors

**Testing**:
```bash
# Verify documentation exists and is complete
cd /home/benjamin/.config
[ -f .claude/docs/reference/state-machine-transitions.md ] && echo "PASS: Documentation created" || echo "FAIL"

# Verify required sections present
grep -q "## Core States" .claude/docs/reference/state-machine-transitions.md && echo "PASS: Core states documented" || echo "FAIL"
grep -q "## State Transition Table" .claude/docs/reference/state-machine-transitions.md && echo "PASS: Transition table documented" || echo "FAIL"
grep -q "## Required Sequences" .claude/docs/reference/state-machine-transitions.md && echo "PASS: Sequences documented" || echo "FAIL"
grep -q "## Examples" .claude/docs/reference/state-machine-transitions.md && echo "PASS: Examples included" || echo "FAIL"
```

**Expected Duration**: 1 hour

### Phase 7: Update Error Log Status [COMPLETE]
dependencies: [1, 2, 3, 4, 5, 6]

**Objective**: Update error log entries from FIX_PLANNED to RESOLVED after verifying all fixes are working

**Complexity**: Low

**Tasks**:
- [x] Verify all fixes are working (run full test suite)
- [x] Verify no new errors generated during repair implementation
- [x] Run /build command with test plan to verify fixes prevent errors
- [x] Update error log entries to RESOLVED status using mark_errors_resolved_for_plan
- [x] Verify no FIX_PLANNED errors remain for this plan
- [x] Generate final repair report showing before/after error counts
- [x] Document lessons learned for future repair workflows

**Testing**:
```bash
# Verify all fixes implemented and working
cd /home/benjamin/.config

# Test pre-flight validation
echo "Testing pre-flight validation..."
bash .claude/tests/integration/test_build_error_patterns.sh | grep -q "Test 7.*passed"
[ $? -eq 0 ] && echo "✓ Pre-flight validation working" || echo "✗ FAIL"

# Test state machine validation
echo "Testing state machine validation..."
bash .claude/tests/integration/test_build_error_patterns.sh | grep -q "Test 3.*passed"
[ $? -eq 0 ] && echo "✓ State machine validation working" || echo "✗ FAIL"

# Test defensive programming
echo "Testing defensive checks..."
bash .claude/tests/integration/test_build_error_patterns.sh | grep -q "Test 5.*passed"
[ $? -eq 0 ] && echo "✓ Defensive programming working" || echo "✗ FAIL"

# Update error log status
echo "Updating error log status..."
source .claude/lib/core/error-handling.sh
RESOLVED_COUNT=$(mark_errors_resolved_for_plan "/home/benjamin/.config/.claude/specs/976_repair_build_20251129_180227/plans/001-repair-build-20251129-180227-plan.md")
echo "Resolved $RESOLVED_COUNT error log entries"

# Verify no FIX_PLANNED errors remain
REMAINING=$(jq -r 'select(.status == "FIX_PLANNED" and .plan_path == "/home/benjamin/.config/.claude/specs/976_repair_build_20251129_180227/plans/001-repair-build-20251129-180227-plan.md") | .id' .claude/data/logs/errors.jsonl 2>/dev/null | wc -l)
[ "$REMAINING" -eq 0 ] && echo "✓ All errors resolved" || echo "✗ FAIL: $REMAINING errors remain"
```

**Expected Duration**: 0.5 hours

## Testing Strategy

### Unit Testing
- Test each validation function independently
- Test state machine transitions with mock state files
- Test defensive checks with missing files and empty variables
- Test pre-flight validation with various error conditions

### Integration Testing
- Test /build command end-to-end with test plan
- Test error scenarios that previously caused failures
- Test regression suite covers all resolved error patterns
- Test that fixes don't introduce new errors

### Regression Testing
- Create `.claude/tests/integration/test_build_error_patterns.sh`
- Cover all 7 error patterns identified in analysis (6 original + 1 new from build output)
- Run tests on every /build command modification
- Add to CI pipeline for continuous validation

### Test Coverage Requirements
- Pre-flight validation: 100% coverage (all validation paths tested)
- State machine transitions: 90% coverage (all valid and invalid transitions)
- Defensive programming: 85% coverage (all critical file/variable checks)
- Parameter validation: 100% coverage (all multi-parameter library functions)
- Regression tests: 100% coverage (all 7 resolved error patterns)

## Documentation Requirements

### Files to Update
- `.claude/commands/build.md` - Add pre-flight validation, defensive checks
- `.claude/lib/workflow/workflow-state-machine.sh` - Add STATE_FILE validation, update transitions
- `.claude/lib/core/error-handling.sh` - Add parameter count validation to multi-parameter functions
- `.claude/docs/reference/state-machine-transitions.md` - Create comprehensive state machine reference
- `CLAUDE.md` - Add reference to state machine documentation
- `.claude/tests/integration/test_build_error_patterns.sh` - Create regression test suite

### Documentation Standards
- All validation functions must have clear error messages
- Parameter validation must indicate expected vs received parameter counts
- State machine transitions must be documented with examples
- Regression tests must document expected behavior
- Each defensive check must explain what it prevents
- Troubleshooting section for common errors

## Dependencies

### External Dependencies
- jq (for error log JSON processing)
- bash 4.0+ (for associative arrays in state machine)
- git (for project directory detection)

### Internal Dependencies
- `.claude/lib/core/state-persistence.sh` (v1.5.0+) - State file management
- `.claude/lib/workflow/workflow-state-machine.sh` (v2.0.0+) - State machine implementation
- `.claude/lib/core/error-handling.sh` (latest) - Error logging and reporting
- `.claude/lib/plan/checkbox-utils.sh` (latest) - Progress tracking

### Phase Dependencies
Phase dependencies enable wave-based parallel execution:
- Wave 1: Phase 1 (Pre-flight validation - no dependencies)
- Wave 2: Phases 2, 3, and 4 (State machine, defensive programming, parameter validation - depend on Phase 1)
- Wave 3: Phase 5 (Regression tests - depends on Phases 2, 3, and 4)
- Wave 4: Phase 6 (Documentation - depends on Phase 2)
- Wave 5: Phase 7 (Error log update - depends on all previous phases)

## Risk Assessment

### High-Priority Risks
1. **State machine changes break existing workflows** - Mitigation: Extensive testing, backward compatibility checks
2. **Defensive checks introduce performance overhead** - Mitigation: Only add checks on critical paths, use efficient validation
3. **Regression tests miss edge cases** - Mitigation: Review all 27 errors, create tests for each pattern

### Medium-Priority Risks
1. **Pre-flight validation too strict** - Mitigation: Clear error messages, graceful degradation where possible
2. **Documentation becomes outdated** - Mitigation: Link validation in pre-commit hooks
3. **Test suite maintenance burden** - Mitigation: Keep tests simple, automate execution

### Low-Priority Risks
1. **Error log corruption during status updates** - Mitigation: Atomic writes, backup before modification
2. **New error patterns emerge** - Mitigation: Continuous monitoring, iterative improvement

## Rollback Plan

If any phase introduces regressions:

1. **Immediate**: Revert changes in affected file using git
2. **Investigation**: Run existing test suite to identify failures
3. **Fix Forward**: Adjust implementation to resolve regression
4. **Re-test**: Verify regression resolved before proceeding

Rollback commands:
```bash
# Revert specific file
git checkout HEAD -- .claude/commands/build.md

# Revert library changes
git checkout HEAD -- .claude/lib/workflow/workflow-state-machine.sh

# Verify tests pass after revert
bash .claude/tests/integration/test_build_*.sh
```

## Success Metrics

- **Error Reduction**: All 5 ERROR status entries → RESOLVED (100% resolution)
- **New Error Pattern Fixed**: Unbound variable error at error-handling.sh:592 eliminated
- **Regression Prevention**: 0 recurrences of resolved error patterns in 30 days
- **Test Coverage**: 90%+ coverage for modified code paths (including parameter validation)
- **Documentation Completeness**: All state transitions documented with examples
- **Performance Impact**: <5% overhead from defensive checks
- **Code Quality**: Pass all linters and pre-commit hooks
- **Parameter Validation**: All library functions with 3+ parameters have defensive checks

## Appendix: Error Pattern Summary

### Pattern 1: Missing Function - save_completed_states_to_state
- **Status**: [COMPLETE]
- **Fix**: Function exists in workflow-state-machine.sh, was library sourcing issue
- **Prevention**: Pre-flight validation checks function availability

### Pattern 2: Invalid State Transition - implement → complete
- **Status**: [COMPLETE]
- **Fix**: Enforce implement→test→complete sequence
- **Prevention**: Update STATE_TRANSITIONS table, add phase entry validation

### Pattern 3: Invalid State Transition - debug → document
- **Status**: [COMPLETE]
- **Fix**: Add debug→document as valid transition
- **Prevention**: Document valid transitions, update state machine

### Pattern 4: Bash Execution Errors - General
- **Status**: [COMPLETE]
- **Fix**: Add defensive file/variable checks throughout
- **Prevention**: Defensive programming pattern, pre-flight validation

### Pattern 5: State File Not Set
- **Status**: [COMPLETE]
- **Fix**: Add STATE_FILE validation in sm_transition entry
- **Prevention**: Pre-flight check for initialization readiness

### Pattern 6: Invalid Self-Transition
- **Status**: [COMPLETE]
- **Fix**: Document idempotent transition behavior
- **Prevention**: Clear documentation of state machine semantics

### Pattern 7: Parameter Count Validation - Unbound Variable in Library Functions (NEW)
- **Status**: [COMPLETE]
- **Location**: error-handling.sh:592
- **Error**: "$7: unbound variable" (exit code 127)
- **Affected Function**: Likely `estimate_context_for_agents` or similar multi-parameter function
- **Fix**: Add parameter count validation at function entry for all functions expecting 3+ parameters
- **Prevention**:
  - Defensive parameter count checks with clear error messages
  - Fix call sites passing insufficient parameters
  - Add regression tests for parameter validation
- **Impact**: Non-fatal (build continued) but indicates defensive programming gap
- **Priority**: Medium (improves robustness and error clarity)
