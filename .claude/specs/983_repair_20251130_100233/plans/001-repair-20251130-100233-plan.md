# Error Repair Implementation Plan

## Metadata
- **Date**: 2025-12-01 (Revised)
- **Feature**: Error Log Analysis and Repair
- **Scope**: Fix 140 logged errors across 7 error patterns affecting 10 commands
- **Estimated Phases**: 5
- **Estimated Hours**: 8
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Status**: [IN PROGRESS]
- **Research Reports**:
  - [Error Analysis Report](../reports/001_error_analysis.md)
  - [Simplification Analysis](../reports/002_simplification_analysis.md)
- **Structure Level**: 0
- **Complexity Score**: 45.0
- **Revision Notes**: Simplified from 7 phases (24h) to 5 phases (8h) using existing infrastructure

## Overview

This plan addresses 140 logged errors identified through error log analysis spanning 2025-11-21 to 2025-11-30. The errors are concentrated in 7 patterns affecting 10 commands, with execution errors (51%), state management issues (20%), and agent failures (15%) representing the majority. The repair focuses on systemic fixes that will resolve multiple error instances through architectural improvements rather than individual error patching.

Key repair objectives (simplified approach using existing infrastructure):
1. Fix library sourcing issues using existing linter (31 errors, 22%)
2. Add state validation using existing sm_validate_state() (37 errors, 26%)
3. Add agent timeout configuration via environment variables (18 errors, 13%)
4. Add path validation using existing validate_absolute_path() (13 errors, 9%)

## Research Summary

The error analysis report reveals that exit code 127 ("command not found") errors represent the most frequent execution failure pattern, indicating missing function definitions or incomplete library sourcing. State machine transition errors and STATE_FILE initialization issues constitute 26% of all errors, pointing to systemic initialization order problems. Agent failures are split between production (topic naming, 11 errors) and test scenarios (agent tests, 7 errors), with different root causes requiring distinct fixes.

Root cause analysis identified four systemic issues:
1. **Library Sourcing**: Functions not available in execution context - **EXISTING TOOL**: `check-library-sourcing.sh` linter
2. **State Machine Initialization**: Commands attempting transitions before STATE_FILE is set - **EXISTING TOOL**: `sm_validate_state()` function
3. **Agent Reliability**: Topic naming agent not producing output files - **SIMPLE FIX**: Timeout environment variable
4. **Input Validation**: User-provided paths not validated - **EXISTING TOOL**: `validate_absolute_path()` in validation-utils.sh

**Simplification Analysis**: The original plan proposed creating 3 new libraries that duplicate existing functionality. The revised plan uses existing infrastructure to achieve 93% error resolution with 67% less effort.

## Success Criteria

- [ ] Exit code 127 errors reduced to zero (31 errors resolved)
- [ ] State machine transition errors reduced to zero (37 errors resolved)
- [ ] Agent timeout errors reduced by 90% (16+ of 18 errors resolved)
- [ ] Input validation errors reduced to zero (13 errors resolved)
- [ ] Error log entries marked RESOLVED (99 total errors targeted, 93% of original scope)

## Technical Design

### Architecture Changes (Minimal - Uses Existing Infrastructure)

**1. Library Sourcing Fixes (No New Libraries)**
- Use existing `check-library-sourcing.sh` linter to identify violations
- Fix violations by adding fail-fast handlers to critical library sourcing
- No new libraries needed - existing linter is complete

**2. State Validation (No New Wrappers)**
- Use existing `sm_validate_state()` function in workflow-state-machine.sh
- Add sm_validate_state() calls after load_workflow_state() in affected commands
- No new wrapper needed - existing validation function is complete

**3. Agent Timeout Configuration (Simple Env Vars)**
- Add `AGENT_TIMEOUT` environment variable (default: 30s)
- Add `AGENT_TEST_TIMEOUT` environment variable (default: 3s)
- No retry logic needed - simple timeout increase addresses root cause

**4. Path Validation (Use Existing Library)**
- Use existing `validate_absolute_path()` from validation-utils.sh
- Source validation-utils.sh in affected commands
- No new library needed - existing validation function is complete

### Component Interactions

```
Command Entry Point
  ↓
Input Validation (existing: validation-utils.sh)
  ↓
State Machine Validation (existing: sm_validate_state())
  ↓
Library Sourcing (verified by: check-library-sourcing.sh)
  ↓
Command Logic
  ↓
Agent Invocation with Timeout (env var: AGENT_TIMEOUT)
  ↓
Error Logging (existing)
```

### File Modifications

Commands requiring library sourcing fixes (run linter, fix violations):
- `.claude/commands/build.md` (6 errors)
- `.claude/commands/plan.md` (8 errors)
- `.claude/commands/debug.md` (4 errors)
- `.claude/commands/research.md` (2 errors)
- `.claude/commands/revise.md` (2 errors)
- `.claude/commands/errors.md` (1 error)

Commands requiring state machine validation (add sm_validate_state() call):
- `.claude/commands/repair.md` (9 errors)
- `.claude/commands/revise.md` (4 errors)
- `.claude/commands/build.md` (3 errors)
- `.claude/commands/research.md` (2 errors)
- `.claude/commands/plan.md` (1 error)

Commands requiring path validation (add validate_absolute_path() call):
- `.claude/commands/convert-docs.md` (5 errors)
- `.claude/commands/plan.md` (3 errors)
- `.claude/commands/research.md` (2 errors)

**No new libraries to create** - all functionality exists in:
- `.claude/scripts/lint/check-library-sourcing.sh` (sourcing validation)
- `.claude/lib/workflow/workflow-state-machine.sh` (sm_validate_state)
- `.claude/lib/workflow/validation-utils.sh` (validate_absolute_path)

## Implementation Phases

### Phase 1: Fix Library Sourcing Violations [NOT STARTED]
dependencies: []

**Objective**: Use existing linter to identify and fix library sourcing violations

**Complexity**: Low

Tasks:
- [ ] Run `check-library-sourcing.sh` linter on all commands
- [ ] Fix bare suppression violations (add fail-fast handlers)
- [ ] Fix missing defensive function checks
- [ ] Update `/build` command (6 exit code 127 errors)
- [ ] Update `/plan` command (8 exit code 127 errors)
- [ ] Update `/debug` command (4 exit code 127 errors)
- [ ] Update `/research` command (2 exit code 127 errors)
- [ ] Update `/revise` command (2 exit code 127 errors)
- [ ] Update `/errors` command (1 exit code 127 error)
- [ ] Verify with linter (all violations resolved)

**Fix Pattern**:
```bash
# BEFORE (violation):
source lib/core/state-persistence.sh 2>/dev/null

# AFTER (fixed):
source lib/core/state-persistence.sh 2>/dev/null || {
  echo "ERROR: Cannot load state-persistence.sh"
  exit 1
}
```

Testing:
```bash
# Run existing linter
bash .claude/scripts/lint/check-library-sourcing.sh

# Verify no exit code 127 errors
/errors --type execution_error --since 1h | jq -r 'select(.context.exit_code == 127)'
```

**Expected Duration**: 2 hours

### Phase 2: Add State and Path Validation [NOT STARTED]
dependencies: [1]

**Objective**: Use existing validation functions to fix state and path errors

**Complexity**: Low

Tasks:
- [ ] Add `sm_validate_state()` to `/repair` command (9 state errors)
- [ ] Add `sm_validate_state()` to `/revise` command (4 STATE_FILE errors)
- [ ] Add `sm_validate_state()` to `/build` command (3 state errors)
- [ ] Add `sm_validate_state()` to `/research` command (2 STATE_FILE errors)
- [ ] Add `sm_validate_state()` to `/plan` command (1 state error)
- [ ] Add `validate_absolute_path()` to `/convert-docs` command (5 validation errors)
- [ ] Add `validate_absolute_path()` to `/plan` command (3 validation errors)
- [ ] Add `validate_absolute_path()` to `/research` command (2 validation errors)
- [ ] Add inline array validation where needed

**Fix Pattern**:
```bash
# After load_workflow_state:
sm_validate_state || {
  echo "ERROR: State machine validation failed"
  exit 1
}

# For path validation:
source "${CLAUDE_PROJECT_DIR}/.claude/lib/workflow/validation-utils.sh" 2>/dev/null || exit 1
validate_absolute_path "$INPUT_DIR" true || exit 1
```

Testing:
```bash
# Verify no state errors
/errors --type state_error --since 1h

# Verify no validation errors
/errors --type validation_error --since 1h
```

**Expected Duration**: 2 hours

### Phase 3: Agent Timeout Configuration [NOT STARTED]
dependencies: []

**Objective**: Add timeout environment variables for agent invocations

**Complexity**: Low

Tasks:
- [ ] Add `AGENT_TIMEOUT` env var support (default: 30s)
- [ ] Add `AGENT_TEST_TIMEOUT` env var support (default: 3s)
- [ ] Update test harness to use `AGENT_TEST_TIMEOUT`
- [ ] Use existing `validate_agent_artifact()` for output validation

**Fix Pattern**:
```bash
# In agent invocation:
AGENT_TIMEOUT="${AGENT_TIMEOUT:-30}"
timeout "${AGENT_TIMEOUT}s" invoke_topic_namer "$DESC" > "$OUTPUT"

# Validate output:
validate_agent_artifact "$OUTPUT" 10 "topic name file" || exit 1
```

Testing:
```bash
export AGENT_TIMEOUT=30
export AGENT_TEST_TIMEOUT=3
/errors --type agent_error --since 1h
```

**Expected Duration**: 1 hour

### Phase 4: Verification [NOT STARTED]
dependencies: [1, 2, 3]

**Objective**: Verify all fixes working, no regressions

**Complexity**: Low

Tasks:
- [ ] Run comprehensive test suite
- [ ] Query error log to verify error reduction
- [ ] Generate before/after comparison report
- [ ] Verify exit code 127 errors reduced to zero (31 targeted)
- [ ] Verify state errors reduced to zero (37 targeted)
- [ ] Verify agent errors reduced by 90% (16+ of 18 targeted)
- [ ] Verify validation errors reduced to zero (13 targeted)

Testing:
```bash
echo "Exit code 127 (before: 31):"
/errors --type execution_error | jq -r 'select(.context.exit_code == 127)' | wc -l

echo "State errors (before: 37):"
/errors --type state_error | wc -l

echo "Agent errors (before: 18):"
/errors --type agent_error | wc -l

echo "Validation errors (before: 13):"
/errors --type validation_error | wc -l
```

**Expected Duration**: 2 hours

### Phase 5: Update Error Log Status [NOT STARTED]
dependencies: [4]

**Objective**: Mark resolved errors in error log

**Complexity**: Low

Tasks:
- [ ] Verify all fixes passing tests
- [ ] Update error log entries to RESOLVED status
- [ ] Verify no FIX_PLANNED errors remain

Testing:
```bash
source .claude/lib/core/error-handling.sh
mark_errors_resolved_for_plan "/home/benjamin/.config/.claude/specs/983_repair_20251130_100233/plans/001-repair-20251130-100233-plan.md"

/errors --status FIX_PLANNED | jq -r 'select(.repair_plan_path | contains("983_repair"))'
```

**Expected Duration**: 1 hour

## Testing Strategy

### Linter Validation
- Run `check-library-sourcing.sh` before and after fixes
- Verify all violations resolved (exit code 0)

### Error Log Verification
- Query error log to verify error counts reduced
- Compare before/after by error type

### Command Testing
- Test affected commands with --dry-run flag
- Verify no new errors generated

## Documentation Requirements

**No new documentation required** - using existing infrastructure:
- Library sourcing documented in existing linter
- State validation documented in workflow-state-machine.sh
- Path validation documented in validation-utils.sh

Optional updates (low priority):
- Update testing docs with AGENT_TEST_TIMEOUT env var

## Dependencies

### External Dependencies
- jq (for error log querying)

### Internal Dependencies (Existing Libraries)
- `check-library-sourcing.sh` - Linter for sourcing violations
- `workflow-state-machine.sh` - sm_validate_state() function
- `validation-utils.sh` - validate_absolute_path() function
- `error-handling.sh` - Error logging and resolution tracking

### Phase Dependencies
- Phase 2 depends on Phase 1 (validation requires sourcing fixes)
- Phase 3 can proceed in parallel with Phases 1-2 (timeout config is independent)
- Phase 4 depends on Phases 1-3 (verification requires all fixes)
- Phase 5 depends on Phase 4 (error log update requires verification)

## Risk Management

### Technical Risks
- **Risk**: Adding fail-fast handlers may expose hidden issues
  - **Mitigation**: Run linter and test commands with --dry-run before deploying
  - **Rollback**: Changes are additive (fail-fast handlers), easy to revert

- **Risk**: Fixes may not resolve all error instances
  - **Mitigation**: Phase 4 verification with before/after comparison
  - **Rollback**: Document remaining errors for follow-up

### Low Risk Design
This simplified plan has **lower risk** than the original because:
1. **No new libraries** - Using existing, tested infrastructure
2. **No architectural changes** - Adding validation calls, not refactoring
3. **Incremental fixes** - Can test and verify each command independently
4. **Easy rollback** - All changes are additive, easy to revert

## Notes

### Complexity Score Calculation (Revised)
```
Score = (tasks × 1.0) + (phases × 5.0) + (hours × 0.5) + (dependencies × 2.0)
Score = (20 × 1.0) + (5 × 5.0) + (8 × 0.5) + (4 × 2.0)
Score = 20 + 25 + 4 + 8
Score = 57.0 (down from 123.0)
```

Note: Reduced from Tier 2 (123.0) to Tier 1 (57.0) through simplification.

### Implementation Notes
- Apply fixes incrementally per command with testing after each change
- All phases use existing infrastructure - no new code to debug
- Phase 3 (timeout config) can proceed in parallel with Phases 1-2

### Simplification Summary
| Metric | Original | Revised | Change |
|--------|----------|---------|--------|
| Phases | 7 | 5 | -29% |
| Hours | 24 | 8 | -67% |
| New Libraries | 3 | 0 | -100% |
| Tasks | 56 | 20 | -64% |
| Complexity | 123.0 | 57.0 | -54% |
| Errors Resolved | 106 | 99 | -7% |
