# Repair Plan: Fix Bash Syntax Errors, State Persistence Violations, and Agent Reliability

## Metadata
- **Date**: 2025-12-01 (Revised: 2025-12-01)
- **Feature**: Error Pattern Remediation - /plan Command Reliability
- **Scope**: Fix 27 logged errors across 4 root causes (bash syntax, state persistence, library availability, agent timeout)
- **Estimated Phases**: 6
- **Estimated Hours**: 14
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Status**: [COMPLETE]
- **Structure Level**: 0
- **Complexity Score**: 85.0
- **Research Reports**:
  - [Error Analysis Report](/home/benjamin/.config/.claude/specs/992_repair_plan_20251201_123734/reports/001-plan-errors-repair.md)
  - [Standards Alignment Analysis](/home/benjamin/.config/.claude/specs/992_repair_plan_20251201_123734/reports/002-plan-revision-standards-alignment.md)

## Overview

This plan addresses critical runtime failures in the /plan command workflow identified through error log analysis. The 27 logged errors stem from four root causes: preprocessing-unsafe bash patterns (exit code 2), state persistence type violations (corrupted state files), missing library function validation (exit code 127), and agent timeout/reliability issues (40% of failures). This repair systematically fixes each pattern to restore workflow reliability and prevent recurrence through linting and validation infrastructure.

## Research Summary

Analysis of 27 /plan command errors revealed critical patterns requiring immediate remediation:

**Pattern 1: Bash Syntax Error (4% - Critical Severity)**
- Escaped negation operator `\!` in conditional causes exit code 2
- Violates preprocessing-safe pattern requirement
- Immediate workflow failure with no recovery

**Pattern 2: State Persistence Type Violations (4% + cascading effects)**
- JSON arrays passed to append_workflow_state corrupt state files
- Bash cannot parse JSON syntax, causing unbound variable errors
- Requires type validation at API boundary

**Pattern 3: Library Function Availability (29% - High Severity)**
- Functions called before libraries sourced or without validation
- Exit code 127 errors are unrecoverable and cryptic
- Requires pre-flight validation after library sourcing

**Pattern 4: Agent Timeout/Reliability (40% - Highest Frequency)**
- 1s timeout too aggressive for production agents
- No retry mechanism for transient failures
- Fallback naming strategy too generic

These patterns indicate systemic issues in error handling, state management, and agent reliability requiring comprehensive fixes.

## Success Criteria

- [ ] All bash conditionals use unescaped `!` operator (no `\!` patterns)
- [ ] State persistence rejects JSON/array values with clear error messages
- [ ] Pre-flight validation confirms library functions available after sourcing
- [ ] Topic naming agent success rate >90% over 20 invocations
- [ ] Zero exit code 2 errors (bash syntax)
- [ ] Zero exit code 127 errors (function not found)
- [ ] Agent timeout errors reduced by >80% (from 11 to <3)
- [ ] All fixes validated by integration tests
- [ ] Error log entries updated to RESOLVED status
- [ ] Linter detects and prevents regression of fixed patterns

## Technical Design

### Architecture Changes

**1. Bash Conditional Syntax Fix**
- Replace `\!` with `!` in all `[[ ]]` conditionals
- Run existing lint-bash-conditionals.sh to validate
- Add test case to prevent regression

**2. State Persistence Type Validation**
- Add input validation to append_workflow_state function
- Reject JSON objects/arrays with `^[\[\{]` regex pattern
- Add helper function append_workflow_state_array for array conversion
- Document scalar-only contract in library header

**3. Pre-flight Library Function Validation**
- Use existing validate_workflow_prerequisites from validation-utils.sh (created 2025-12-01)
- Validate required functions exist after sourcing (declare -F check)
- Export STATE_FILE immediately after init_workflow_state
- Remove non-portable /etc/bashrc sourcing

**4. Agent Reliability Improvements**
- Benchmark agent response times and set timeout based on P95 + 2s buffer
- Add retry mechanism (max 2 retries, exponential backoff)
- Improve fallback naming: timestamp + sanitized prompt prefix
- Add agent performance logging

### Component Interactions

```
┌─────────────────────────────────────────────────────────────┐
│ /plan Command Workflow                                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ Block 1: Path Pre-calculation                              │
│   ├─ Fix: Replace \! with ! in conditionals               │
│   └─ Validate: lint-bash-conditionals.sh                   │
│                                                             │
│ Block 2: Library Sourcing                                  │
│   ├─ Source: state-persistence.sh, workflow-state-machine  │
│   ├─ Source: validation-utils.sh (existing library)        │
│   ├─ USE: validate_workflow_prerequisites() (existing)     │
│   ├─ init_workflow_state()                                 │
│   └─ NEW: export STATE_FILE (immediate)                    │
│                                                             │
│ Block 3: State Persistence                                 │
│   ├─ NEW: Type validation in append_workflow_state()       │
│   ├─ Fix: Convert JSON arrays to space-separated strings   │
│   └─ Validate: Scalar-only values                          │
│                                                             │
│ Block 4: Topic Naming Agent                                │
│   ├─ Benchmark: Measure P95 response time                  │
│   ├─ Fix: Set timeout to P95 + 2s buffer (data-driven)    │
│   ├─ NEW: Retry logic (max 2, exponential backoff)        │
│   ├─ NEW: Improved fallback naming                         │
│   └─ NEW: Performance logging                              │
│                                                             │
│ Block 5: Agent Delegation                                  │
│   └─ (No changes - validation complete)                    │
└─────────────────────────────────────────────────────────────┘
```

### Dependencies and Prerequisites

**Internal Dependencies**:
- `.claude/lib/core/state-persistence.sh` - Type validation changes
- `.claude/lib/workflow/validation-utils.sh` - Existing validation function (validate_workflow_prerequisites)
- `.claude/commands/plan.md` - Multiple block fixes
- `.claude/scripts/validate-all-standards.sh` - Existing validation infrastructure
- `.claude/tests/utilities/lint-bash-conditionals.sh` - Existing linter

**External Dependencies**: None

**Tool Requirements**:
- bash 4.0+ (for declare -f validation)
- jq (for JSON validation in tests)
- grep, sed (for conditional pattern search/replace)

## Implementation Phases

### Phase 1: Fix Bash Conditional Syntax Error [COMPLETE]
dependencies: []

**Objective**: Verify and fix bash conditional patterns causing exit code 2 errors (research shows linter explicitly allows `[[ ! ... ]]` syntax)

**Complexity**: Low

**Tasks**:
- [x] **VERIFY ERROR FIRST**: Reproduce exit code 2 error with `[[ \! ... ]]` pattern
  ```bash
  # Create test script with escaped negation
  echo '[[ \! -f /tmp/test ]] && echo "safe"' > /tmp/test_conditional.sh
  bash /tmp/test_conditional.sh
  # Expected: If this succeeds, \! is NOT the problem
  ```
- [x] Review lint_bash_conditionals.sh documentation (file: `.claude/tests/utilities/lint_bash_conditionals.sh`, lines 1-18)
  - Linter explicitly documents `[[ ! ... ]]` as SAFE
  - Only flags history expansion issues (`!!` in unquoted strings)
- [x] Search for actual error source in error logs
  ```bash
  jq -r 'select(.error_type == "parse_error") | select(.exit_code == "2")' .claude/data/logs/errors.jsonl
  ```
- [x] **IF VERIFICATION CONFIRMS**: Replace `[[ \! ... ]]` with `[[ ! ... ]]`
  ```bash
  grep -n '\[\[ \\! ' .claude/commands/plan.md
  # Only proceed with replacement if error reproduced
  ```
- [x] Search for same pattern in other commands (if fix needed)
  ```bash
  grep -rn '\[\[ \\! ' .claude/commands/
  ```
- [x] Run lint-bash-conditionals.sh to verify compliance
  ```bash
  bash .claude/scripts/lint-bash-conditionals.sh
  ```

**Testing**:
```bash
# Test current pattern behavior
TOPIC_NAME_FILE="relative/path"
[[ \! "$TOPIC_NAME_FILE" =~ ^/ ]] && echo "Pattern works: $?"
[[ ! "$TOPIC_NAME_FILE" =~ ^/ ]] && echo "Pattern works: $?"

# Run existing linter (should pass with either syntax)
bash .claude/scripts/lint-bash-conditionals.sh

# Verify no exit code 2 errors after fix
/plan "test feature" --dry-run
```

**Expected Duration**: 1.5 hours (increased for verification)

---

### Phase 2: Add State Persistence Type Validation [COMPLETE]
dependencies: []

**Objective**: Verify and prevent JSON/array corruption in state files (research suggests actual usage needs verification first)

**Complexity**: Medium

**Tasks**:
- [x] **VERIFY ACTUAL USAGE**: Search for JSON arrays being passed to append_workflow_state
  ```bash
  # Search all commands for potential JSON array usage
  grep -rn 'append_workflow_state.*\[' .claude/commands/
  # Expected: Identify actual callsites (if any) before implementing validation
  ```
- [x] **REPRODUCE CORRUPTION**: Create test case showing JSON array corruption
  ```bash
  # Test if append_workflow_state actually accepts/corrupts JSON
  source .claude/lib/core/state-persistence.sh 2>/dev/null
  STATE_FILE=$(mktemp)
  export STATE_FILE
  append_workflow_state "TEST_ARRAY" '["item1", "item2"]'
  # Verify: Does this corrupt state file or fail gracefully?
  ```
- [x] Review state persistence error logs for corruption evidence
  ```bash
  jq -r 'select(.error_type == "state_error")' .claude/data/logs/errors.jsonl | grep -i "array\|json"
  ```
- [x] **IF VERIFICATION CONFIRMS**: Add input validation to append_workflow_state (file: `.claude/lib/core/state-persistence.sh`, line ~400)
  ```bash
  # Reject JSON objects/arrays
  if [[ "$value" =~ ^[\[\{] ]]; then
    echo "ERROR: append_workflow_state only supports scalar values" >&2
    echo "ERROR: Use space-separated strings instead of JSON arrays" >&2
    log_command_error "state_error" "Type validation failed: JSON detected" "value=$value"
    return 1
  fi
  ```
- [x] Add helper function append_workflow_state_array (file: `.claude/lib/core/state-persistence.sh`)
  ```bash
  append_workflow_state_array() {
    local key="$1"
    shift
    append_workflow_state "$key" "$*"
  }
  ```
- [x] Document scalar-only contract in library header (file: `.claude/lib/core/state-persistence.sh`)
- [x] Update callsites to use helper function (if validation needed)
- [x] Add unit test for type validation (file: `.claude/tests/lib/test_state_persistence_type_validation.sh`)

**Testing**:
```bash
# Test JSON rejection
source .claude/lib/core/state-persistence.sh 2>/dev/null
STATE_FILE=$(mktemp)
export STATE_FILE

# Should fail with clear error
if append_workflow_state "TEST_KEY" '["array"]' 2>&1 | grep -q "only supports scalar values"; then
  echo "✓ Type validation working"
else
  echo "✗ Type validation failed"
  exit 1
fi

# Test array helper
append_workflow_state_array "PATHS" "/path/one" "/path/two" "/path/three"
grep -q "PATHS=/path/one /path/two /path/three" "$STATE_FILE" || exit 1

rm "$STATE_FILE"
```

**Expected Duration**: 2 hours

---

### Phase 3: Add Pre-flight Library Function Validation [COMPLETE]
dependencies: []

**Objective**: Use existing validation infrastructure to prevent exit code 127 errors (validation-utils.sh already provides this functionality)

**Complexity**: Low (reduced from Medium - using existing infrastructure)

**Tasks**:
- [x] **USE EXISTING VALIDATION**: Source validation-utils.sh library (file: `.claude/lib/workflow/validation-utils.sh`)
  ```bash
  # This library was created 2025-12-01 and already provides validate_workflow_prerequisites()
  source "${CLAUDE_PROJECT_DIR}/.claude/lib/workflow/validation-utils.sh" 2>/dev/null || {
    echo "ERROR: Failed to source validation-utils.sh" >&2
    exit 1
  }
  ```
- [x] Add validation calls in /plan after library sourcing (file: `.claude/commands/plan.md`)
  ```bash
  # After sourcing all libraries
  source "${CLAUDE_PROJECT_DIR}/.claude/lib/core/state-persistence.sh" 2>/dev/null || exit 1
  source "${CLAUDE_PROJECT_DIR}/.claude/lib/core/workflow-state-machine.sh" 2>/dev/null || exit 1

  # Validate required workflow functions exist
  validate_workflow_prerequisites || exit 1
  ```
- [x] Review validate_workflow_prerequisites implementation (file: `.claude/lib/workflow/validation-utils.sh`, lines 61-103)
  - Checks: sm_init, sm_transition, append_workflow_state, load_workflow_state, save_completed_states_to_state
  - Uses `declare -F` pattern for function checking
  - Logs validation_error to centralized error log
  - Returns clear error messages
- [x] Ensure STATE_FILE exported immediately after init_workflow_state (file: `.claude/commands/plan.md`)
  ```bash
  STATE_FILE=$(init_workflow_state "$WORKFLOW_ID")
  export STATE_FILE  # CRITICAL: Export immediately
  ```
- [x] Remove /etc/bashrc sourcing if present (file: `.claude/commands/plan.md`)
- [x] Add integration test verifying validation-utils.sh usage (file: `.claude/tests/integration/test_plan_validation.sh`)

**Testing**:
```bash
# Test existing validation function
source .claude/lib/workflow/validation-utils.sh 2>/dev/null
source .claude/lib/core/state-persistence.sh 2>/dev/null
source .claude/lib/core/workflow-state-machine.sh 2>/dev/null

# Should succeed with all libraries loaded
validate_workflow_prerequisites || exit 1

# Should fail with missing functions (simulate)
unset -f append_workflow_state
if validate_workflow_prerequisites 2>&1 | grep -q "Missing required workflow functions"; then
  echo "✓ Validation detects missing functions"
else
  echo "✗ Validation failed to detect missing functions"
  exit 1
fi

# Verify integration in /plan command
/plan "test feature" --dry-run
# Should fail gracefully if libraries missing (not exit code 127)
```

**Expected Duration**: 1.5 hours (reduced from 2 hours - no new function creation)

---

### Phase 4: Improve Topic Naming Agent Reliability [COMPLETE]
dependencies: []

**Objective**: Increase agent success rate to >90% through data-driven timeout tuning, retry logic, and improved fallback naming

**Complexity**: Medium

**Tasks**:
- [x] **BENCHMARK AGENT RESPONSE TIMES**: Measure actual performance before setting timeout
  ```bash
  # Run topic naming agent 50 times and measure response times
  for i in {1..50}; do
    start=$(date +%s%N)
    # Invoke topic naming agent with test prompt
    end=$(date +%s%N)
    echo "$((($end - $start) / 1000000)) ms" >> /tmp/agent_timings.txt
  done

  # Calculate 95th percentile
  sort -n /tmp/agent_timings.txt | awk 'NR==int(0.95*50) {print "P95: " $0}'
  ```
- [x] **SET TIMEOUT BASED ON P95 + BUFFER**: Use data-driven approach (not arbitrary 10s)
  ```bash
  # Example: If P95 = 7000ms, set timeout to P95 + 2s buffer = 9s
  # Document rationale in comments
  AGENT_TIMEOUT=$((P95_MS / 1000 + 2))  # P95 + 2s buffer
  ```
- [x] Update agent timeout in /plan command (file: `.claude/commands/plan.md`, agent invocation)
  ```bash
  # Old: AGENT_TIMEOUT=1 (too aggressive)
  # New: AGENT_TIMEOUT=9 (example based on P95=7s)
  # Rationale: P95 response time + 2s buffer for reliability
  ```
- [x] Add retry mechanism with exponential backoff (file: `.claude/commands/plan.md`)
  ```bash
  invoke_topic_naming_agent() {
    local max_retries=2
    local retry_count=0

    while [ $retry_count -le $max_retries ]; do
      # Invoke agent via Task tool
      # Check if output file exists
      if [ -f "$TOPIC_NAME_FILE" ]; then
        return 0
      fi

      retry_count=$((retry_count + 1))
      if [ $retry_count -le $max_retries ]; then
        echo "WARNING: Agent retry $retry_count/$max_retries" >&2
        sleep $((retry_count * 2))  # Exponential backoff: 2s, 4s
      fi
    done

    return 1
  }
  ```
- [x] Improve fallback naming strategy (file: `.claude/commands/plan.md`)
  ```bash
  # Old: FALLBACK_NAME="no_name"
  # New:
  TIMESTAMP=$(date +%Y%m%d_%H%M%S)
  SANITIZED_PROMPT=$(echo "$FEATURE_DESCRIPTION" | head -c 30 | tr -cs '[:alnum:]_' '_')
  FALLBACK_NAME="${TIMESTAMP}_${SANITIZED_PROMPT}"
  ```
- [x] Add agent performance logging (file: `.claude/commands/plan.md`)
  ```bash
  START_TIME=$(date +%s)
  # ... agent invocation ...
  END_TIME=$(date +%s)
  DURATION=$((END_TIME - START_TIME))
  echo "Agent response time: ${DURATION}s" >> "$LOG_FILE"
  ```
- [x] Add integration test for retry logic (file: `.claude/tests/integration/test_agent_retry.sh`)

**Testing**:
```bash
# Test timeout increase (manual verification)
# Run /plan and observe agent wait time is >1s

# Test retry logic (simulate agent failure)
# Mock agent that fails first time, succeeds second time
# Verify retry mechanism activates

# Test improved fallback naming
FEATURE_DESCRIPTION="Add JWT authentication with refresh tokens"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
SANITIZED_PROMPT=$(echo "$FEATURE_DESCRIPTION" | head -c 30 | tr -cs '[:alnum:]_' '_')
FALLBACK_NAME="${TIMESTAMP}_${SANITIZED_PROMPT}"

# Verify format: YYYYMMDD_HHMMSS_Add_JWT_authentication_with_r
echo "$FALLBACK_NAME" | grep -qE '^[0-9]{8}_[0-9]{6}_[A-Za-z0-9_]+$' || exit 1
```

**Expected Duration**: 3 hours

---

### Phase 5: Validation and Integration Testing [COMPLETE]
dependencies: [1, 2, 3, 4]

**Objective**: Verify all fixes using existing validation infrastructure and comprehensive integration tests

**Complexity**: Medium

**Tasks**:
- [x] **USE EXISTING VALIDATION INFRASTRUCTURE**: Run validate-all-standards.sh
  ```bash
  # Run all validators (comprehensive standards check)
  bash .claude/scripts/validate-all-standards.sh --all

  # Run specific validators for repair areas
  bash .claude/scripts/validate-all-standards.sh --sourcing      # Library sourcing
  bash .claude/scripts/validate-all-standards.sh --conditionals  # Bash conditionals
  ```
- [x] Run existing linters to verify fixes
  ```bash
  # Bash conditionals (Phase 1 fix)
  bash .claude/tests/utilities/lint_bash_conditionals.sh

  # Library sourcing (Phase 3 fix)
  bash .claude/scripts/lint/check-library-sourcing.sh

  # Error suppression patterns (Phase 2 fix)
  bash .claude/scripts/lint/lint_error_suppression.sh
  ```
- [x] Create integration test for repair-specific scenarios (file: `.claude/tests/integration/test_repair_fixes.sh`)
  - Test bash conditionals with various path formats (if Phase 1 applied fix)
  - Test state persistence with JSON rejection (if Phase 2 applied validation)
  - Test library validation using validate_workflow_prerequisites (Phase 3)
  - Test agent retry with simulated timeouts (Phase 4)
- [x] Run /plan command end-to-end with fixes
  ```bash
  /plan "test authentication feature" --complexity 2
  ```
- [x] Verify no exit code 2 errors (bash syntax)
  ```bash
  # Check recent errors
  /errors --since 1h --type parse_error --command /plan
  # Expect: No results
  ```
- [x] Verify no exit code 127 errors (function not found)
  ```bash
  /errors --since 1h --type execution_error --command /plan
  # Expect: No results with "not found" message
  ```
- [x] Measure agent success rate over 20 invocations
  ```bash
  # Run /plan 20 times, count successes
  # Target: >90% success rate (>18/20)
  ```
- [x] Run existing test suites to verify no regressions
  ```bash
  bash .claude/tests/integration/test_plan_command.sh
  bash .claude/tests/lib/test_state_persistence.sh
  ```

**Testing**:
```bash
# Comprehensive integration test
bash .claude/tests/integration/test_repair_fixes.sh

# Expected output:
# ✓ Bash conditional syntax correct
# ✓ State persistence rejects JSON
# ✓ Library validation detects missing functions
# ✓ Agent retry logic working
# ✓ All integration tests passed
```

**Expected Duration**: 3 hours

---

### Phase 6: Update Error Log Status [COMPLETE]
dependencies: [5]

**Objective**: Update error log entries to RESOLVED status and verify no FIX_PLANNED errors remain

**Complexity**: Low

**Tasks**:
- [x] Verify all fixes working (tests pass from Phase 5)
- [x] Update error log entries to RESOLVED status (file: `.claude/data/logs/errors.jsonl`)
  ```bash
  # Script to update status field in JSONL entries
  # Filter by workflow_id or timestamp range matching repair period
  # Update status: FIX_PLANNED → RESOLVED
  ```
- [x] Verify no FIX_PLANNED errors remain in log
  ```bash
  jq -r 'select(.status == "FIX_PLANNED")' .claude/data/logs/errors.jsonl | wc -l
  # Expect: 0
  ```
- [x] Add repair metadata to resolved entries (date, plan path, fix description)
- [x] Generate repair completion report
  ```bash
  /errors --since 10d --status RESOLVED --summary
  ```
- [x] Archive error analysis report (file: `.claude/specs/992_repair_plan_20251201_123734/reports/001-plan-errors-repair.md`)

**Testing**:
```bash
# Verify error log updated
jq -r 'select(.status == "RESOLVED") | select(.repair_plan == "992_repair_plan_20251201_123734")' \
  .claude/data/logs/errors.jsonl | wc -l
# Expect: 27 (all errors from original analysis)

# Verify no FIX_PLANNED remain
jq -r 'select(.status == "FIX_PLANNED")' .claude/data/logs/errors.jsonl | wc -l
# Expect: 0
```

**Expected Duration**: 1 hour

---

## Testing Strategy

### Unit Tests

**Bash Conditional Validation**:
- Test lint-bash-conditionals.sh detects `\!` patterns
- Test lint accepts `!` patterns
- Test various conditional formats (path validation, string matching, numeric comparison)

**State Persistence Type Validation**:
- Test append_workflow_state rejects JSON objects: `{"key": "value"}`
- Test append_workflow_state rejects JSON arrays: `["item1", "item2"]`
- Test append_workflow_state accepts scalars: simple strings, numbers, paths
- Test append_workflow_state_array converts multiple arguments to space-separated string
- Test state file parsing after validation (no corruption)

**Library Function Validation**:
- Test validate_library_functions succeeds when all functions present
- Test validate_library_functions fails when function missing
- Test validate_library_functions provides clear error message
- Test validation for each critical library (state-persistence, workflow-state-machine, error-handling)

**Agent Retry Logic**:
- Test retry activates after first failure
- Test exponential backoff timing (2s, 4s)
- Test max retries respected (stops after 2 retries)
- Test success on retry N (1st retry, 2nd retry)
- Test fallback naming format

### Integration Tests

**End-to-End /plan Workflow**:
- Run /plan with all fixes integrated
- Verify no exit code 2 errors (bash syntax)
- Verify no exit code 127 errors (function not found)
- Verify agent reliability (>90% success over 20 runs)
- Verify state file integrity (no JSON corruption)

**Cross-Command Validation**:
- Test fixes apply to other commands using same patterns (/build, /research, /debug)
- Verify no regressions in existing functionality

**Error Log Integration**:
- Verify error logging still captures failures correctly
- Verify resolved entries have proper metadata
- Verify /errors command displays resolved status

### Performance Testing

**Agent Timeout Measurement**:
- Measure agent response time distribution over 50 invocations
- Verify 10s timeout accommodates 95th percentile response time
- Measure retry overhead (time added per retry attempt)

**State Persistence Overhead**:
- Measure type validation overhead (<5ms per append_workflow_state call)
- Verify no performance regression in state file loading

### Test Coverage Requirements

- Unit test coverage: 100% of new validation functions
- Integration test coverage: All 4 error patterns remediated
- Regression test coverage: All existing /plan test cases pass

## Documentation Requirements

### Code Documentation

**State Persistence Library** (`.claude/lib/core/state-persistence.sh`):
- Update header comments to document scalar-only contract
- Add examples showing append_workflow_state_array usage
- Document error messages and return codes

**Library Validation Function** (`.claude/lib/workflow/validation-utils.sh`):
- Reference existing validate_workflow_prerequisites function
- Document integration pattern in /plan command
- Update command documentation to show validation-utils.sh usage

**Command Updates** (`.claude/commands/plan.md`):
- Update comments for bash conditional fix (WHAT, not WHY)
- Document retry mechanism in agent invocation block
- Update state persistence calls with type-safe patterns

### User Documentation

**Error Troubleshooting Guides**:
- Update [Exit Code 127 Troubleshooting](../../troubleshooting/exit-code-127-command-not-found.md) with validation pattern
- Add [Bash Conditional Patterns](../../guides/development/bash-conditional-patterns.md) guide
- Update [State Persistence Guide](../../guides/development/state-persistence-guide.md) with type constraints

**Standards Updates**:
- Update [Code Standards](../../reference/standards/code-standards.md) with bash conditional requirements
- Update [Output Formatting Standards](../../reference/standards/output-formatting.md) with fail-fast pattern enforcement
- Update [Error Handling Pattern](../../concepts/patterns/error-handling.md) with validation best practices

### Process Documentation

**Repair Workflow Documentation**:
- Document repair workflow process (error analysis → plan → fix → validate → resolve)
- Add examples of error pattern identification
- Document error log status lifecycle (NEW → FIX_PLANNED → RESOLVED)

## Dependencies

### Internal Dependencies

**Library Files**:
- `.claude/lib/core/state-persistence.sh` - Type validation implementation
- `.claude/lib/workflow/validation-utils.sh` - Existing validation function (validate_workflow_prerequisites)
- `.claude/lib/core/error-handling.sh` - Error logging (no changes, used for verification)

**Command Files**:
- `.claude/commands/plan.md` - Primary fix target (4 blocks modified)
- Other commands may require similar fixes (discovered during Phase 1 grep)

**Test Files**:
- `.claude/tests/integration/test_plan_validation.sh` - Integration test for validation-utils.sh usage (Phase 3)
- `.claude/tests/lib/test_state_persistence_type_validation.sh` - New test for Phase 2 (if validation needed)
- `.claude/tests/integration/test_repair_fixes.sh` - Comprehensive integration test for Phase 5

**Validation Infrastructure**:
- `.claude/scripts/validate-all-standards.sh` - Existing unified validator (used in Phase 5)
- `.claude/tests/utilities/lint_bash_conditionals.sh` - Existing linter (no changes)
- `.claude/scripts/lint/check-library-sourcing.sh` - Existing linter (no changes)
- `.claude/scripts/lint/lint_error_suppression.sh` - Existing linter (no changes)

### External Dependencies

None - all fixes use existing bash built-ins and standard utilities (grep, sed, jq).

### Blocked Dependencies

None - all phases are independent except Phase 5 (validation) which depends on Phases 1-4 completion, and Phase 6 (error log update) which depends on Phase 5 verification.

## Risk Management

### Technical Risks

**Risk 1: Type Validation Breaking Existing Code**
- **Severity**: Medium
- **Likelihood**: Low
- **Mitigation**: Search all callsites before implementing validation, provide helper function for legitimate array use cases
- **Contingency**: Add flag to temporarily disable validation if blocking critical workflows

**Risk 2: Library Validation False Positives**
- **Severity**: Low
- **Likelihood**: Low
- **Mitigation**: Test validation with all critical libraries before deployment
- **Contingency**: Validation returns 0 (success) with warning for undefined libraries

**Risk 3: Agent Timeout Too Long**
- **Severity**: Low
- **Likelihood**: Low
- **Mitigation**: 10s based on research showing test-agent timeout at 1s was too aggressive
- **Contingency**: Make timeout configurable via environment variable

### Implementation Risks

**Risk 4: Missing Conditional Patterns in Other Commands**
- **Severity**: Low
- **Likelihood**: Medium
- **Mitigation**: Phase 1 includes grep across all commands to find all instances
- **Contingency**: Linter catches any missed patterns in pre-commit hook

**Risk 5: Test Coverage Gaps**
- **Severity**: Medium
- **Likelihood**: Low
- **Mitigation**: Phase 5 includes comprehensive integration testing
- **Contingency**: Add tests incrementally as edge cases discovered

### Rollback Strategy

All fixes are backward-compatible with existing functionality:

**Phase 1 Rollback**: Revert bash conditional changes (git revert)
**Phase 2 Rollback**: Remove type validation (keeps helper function for future use)
**Phase 3 Rollback**: Remove validation calls (keep function for opt-in use)
**Phase 4 Rollback**: Revert timeout and retry changes (git revert)

No data migration required - state files remain compatible.

## Notes

**Plan Revision History**:
- **2025-12-01 (Initial)**: Created repair plan based on error log analysis
- **2025-12-01 (Revised)**: Updated based on standards alignment research (report 002)
  - Phase 1: Added verification step before changing `\!` to `!` (linter documents `[[ ! ]]` as SAFE)
  - Phase 2: Added verification of actual JSON array usage before implementing validation
  - Phase 3: Changed to use existing `validate_workflow_prerequisites()` from validation-utils.sh (created 2025-12-01)
  - Phase 4: Added benchmarking step to set timeout based on P95 + 2s buffer (data-driven approach)
  - Phase 5: Changed to use existing `validate-all-standards.sh` infrastructure instead of creating new tests
  - Estimated hours increased from 12 to 14 (added verification steps in Phases 1, 2, 4)

**Error Distribution Context**:
- Total Errors: 27 (/plan command, 2025-11-21 to 2025-11-30)
- Agent Errors: 11 (40%) - Highest frequency
- Execution Errors: 10 (37%) - Exit code 127 primary concern
- State Errors: 2 (7%) - JSON corruption
- Parse Errors: 1 (4%) - Exit code 2 (bash syntax)

**Fix Impact Projection**:
- Phase 1: Eliminates 1 error (4% of total) - Critical severity
- Phase 2: Eliminates 1 error + prevents cascading failures (4% direct + indirect effects)
- Phase 3: Eliminates 8 errors (29% of total) - High severity
- Phase 4: Reduces 11 errors to <3 (73% reduction, 30% of total remaining)
- Overall: 95%+ error reduction expected

**Validation Infrastructure**:
- Existing linters enforced via pre-commit hooks
- New validation functions integrate with existing patterns
- No new external dependencies required

**Future Enhancements** (out of scope for this plan):
- Extend validation to /build, /research, /debug commands
- Add agent performance monitoring dashboard
- Automated error pattern detection and reporting
