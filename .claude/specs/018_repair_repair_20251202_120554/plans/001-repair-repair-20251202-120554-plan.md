# Implementation Plan: Fix /repair Command Error Logging Issues

## Metadata
- **Date**: 2025-12-02
- **Feature**: Fix /repair command state persistence, error logging, and workflow transition issues
- **Status**: [IN PROGRESS]
- **Estimated Hours**: 8-12 hours
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Research Reports**: /home/benjamin/.config/.claude/specs/018_repair_repair_20251202_120554/reports/001-repair-errors-repair.md

## Overview

The /repair command has logged 28 errors over 11 days, with three critical root causes identified:
1. **State Persistence Variable Interpolation Failure** (39% of errors) - `RESEARCH_DIR` variable empty due to bash preprocessing issues
2. **JSON Type Validation Failures** (18% of errors) - State persistence library rejects JSON-formatted `ERROR_FILTERS`
3. **Invalid State Transitions** (18% of errors) - Command skips research state, attempts invalid `initialize → plan` transition

The implementation plan addresses all three root causes with refactored state initialization, flat key storage for filters, and corrected state transition sequence.

## Success Criteria

- [ ] All 28 logged /repair errors eliminated (no recurrence with same patterns)
- [ ] State persistence uses flat keys for ERROR_FILTERS (no JSON type validation errors)
- [ ] State machine transitions follow correct sequence: `initialize → research → plan → complete`
- [ ] RESEARCH_DIR variable always populated before find commands execute
- [ ] Integration tests pass for state initialization, transitions, and path calculation
- [ ] Error log entries updated with FIX_PLANNED status upon plan creation
- [ ] Error log entries updated with RESOLVED status after fixes verified

## Dependencies

- State persistence library (`state-persistence.sh`) - no changes needed, use flat keys
- Workflow state machine (`workflow-state-machine.sh`) - no changes needed, fix command usage
- Error handling library (`error-handling.sh`) - includes `mark_errors_fix_planned` and `mark_errors_resolved_for_plan` functions

## Phase 1: Refactor ERROR_FILTERS from JSON to Flat Keys

**Objective**: Replace nested JSON ERROR_FILTERS with separate state keys to eliminate type validation failures

**Estimated Time**: 2-3 hours

**Tasks**:
- [ ] Replace `ERROR_FILTERS` JSON construction in Block 1a with individual filter keys
  - Change: `append_workflow_state "ERROR_FILTERS" "$ERROR_FILTERS"`
  - To: Four separate append calls for FILTER_SINCE, FILTER_TYPE, FILTER_COMMAND, FILTER_SEVERITY
  - Location: `/home/benjamin/.config/.claude/commands/repair.md` lines 105-112, 339
- [ ] Update Block 3 error log update to read flat keys instead of parsing JSON
  - Change: `ERROR_FILTERS_JSON=$(grep "^ERROR_FILTERS=" ...)`
  - To: Direct state variable reads: `ERROR_COMMAND_FILTER`, `ERROR_TYPE_FILTER`, `ERROR_SINCE_FILTER`
  - Location: `/home/benjamin/.config/.claude/commands/repair.md` lines 1499-1513
- [ ] Remove jq-based JSON extraction and use state variables directly
  - Remove: `echo "$ERROR_FILTERS_JSON" | jq -r '.command // ""'`
  - Use: `${ERROR_COMMAND_FILTER:-}` directly
- [ ] Update state persistence calls to use flat keys
  - Add: `append_workflow_state "ERROR_FILTER_SINCE" "$ERROR_SINCE"`
  - Add: `append_workflow_state "ERROR_FILTER_TYPE" "$ERROR_TYPE"`
  - Add: `append_workflow_state "ERROR_FILTER_COMMAND" "$ERROR_COMMAND"`
  - Add: `append_workflow_state "ERROR_FILTER_SEVERITY" "$ERROR_SEVERITY"`
- [ ] Test state file format change with manual /repair invocation
  - Verify: `grep "^ERROR_FILTER_" "$STATE_FILE"` shows 4 separate keys
  - Verify: No JSON type validation errors in error log

**Files Modified**:
- `/home/benjamin/.config/.claude/commands/repair.md` (Block 1a lines 105-112, 339; Block 3 lines 1499-1513)

**Validation**:
```bash
# Test filter storage
/repair --command /build --type state_error --since 1h

# Check state file has flat keys
STATE_FILE=$(ls -t ~/.claude/tmp/workflow_repair_*.sh | head -1)
grep -E "^ERROR_FILTER_(SINCE|TYPE|COMMAND|SEVERITY)=" "$STATE_FILE"

# Verify no type validation errors
tail -20 ~/.claude/data/logs/errors.jsonl | jq 'select(.error_message | contains("Type validation failed"))'
# Should return empty
```

## Phase 2: Fix State Transition Sequence

**Objective**: Update /repair command to follow correct state transition sequence for research-and-plan scope

**Estimated Time**: 1-2 hours

**Tasks**:
- [ ] Move `sm_transition research` to BEFORE path initialization in Block 1a
  - Current: Lines 236-251 attempt transition but state may not be initialized
  - Fix: Ensure `sm_init` completes successfully before transition
  - Location: `/home/benjamin/.config/.claude/commands/repair.md` lines 236-251
- [ ] Verify `sm_init` success before any transition attempts
  - Add validation: Check `SM_INIT_EXIT` code and log state_error if non-zero
  - Already present at lines 220-234, verify exit on failure
- [ ] Ensure CURRENT_STATE persisted after research transition
  - Add explicit persistence: `append_workflow_state "CURRENT_STATE" "$CURRENT_STATE"` after transition
  - Already present at line 270, verify it executes
- [ ] Add state machine initialization check at Block 2a start
  - Add: `sm_validate_state` before research artifact verification
  - Location: `/home/benjamin/.config/.claude/commands/repair.md` Block 2a after line 819
- [ ] Remove premature `sm_transition plan` calls before agent delegation
  - Verify: `sm_transition "$STATE_PLAN"` only called in Block 2a after research verified
  - Location: Confirm lines 863-878 are AFTER research verification
- [ ] Test state transitions with --dry-run equivalent (manual verification)
  - Run: `/repair --command /test` and capture state file at each block
  - Verify: CURRENT_STATE = research in Block 1b, CURRENT_STATE = plan in Block 2b

**Files Modified**:
- `/home/benjamin/.config/.claude/commands/repair.md` (Block 1a lines 236-270; Block 2a lines 819-878)

**Validation**:
```bash
# Test state transition sequence
/repair --type execution_error --since 1h

# Check state transitions in state file
STATE_FILE=$(ls -t ~/.claude/tmp/workflow_repair_*.sh | head -1)
grep "^CURRENT_STATE=" "$STATE_FILE"
grep "^COMPLETED_STATES=" "$STATE_FILE"

# Verify no invalid transition errors
tail -20 ~/.claude/data/logs/errors.jsonl | jq 'select(.error_message | contains("Invalid state transition"))'
# Should return empty
```

## Phase 3: Add Defensive Directory Validation

**Objective**: Add defensive checks to ensure RESEARCH_DIR exists before find commands execute

**Estimated Time**: 1 hour

**Tasks**:
- [ ] Add RESEARCH_DIR existence check in Block 1b before find command
  - Add before line 434: `[ -d "$RESEARCH_DIR" ] || mkdir -p "$RESEARCH_DIR"`
  - Log warning (not error) if directory had to be created
  - Location: `/home/benjamin/.config/.claude/commands/repair.md` lines 418-434
- [ ] Add RESEARCH_DIR non-empty validation in Block 1b
  - Add before line 420: `if [ -z "${RESEARCH_DIR:-}" ]; then log_command_error ... fi`
  - Already present at lines 420-430, verify failure handling
- [ ] Add fallback EXISTING_REPORTS=0 if find fails
  - Change: `EXISTING_REPORTS=$(find "$RESEARCH_DIR" ... || echo "0")`
  - Location: Line 434
- [ ] Add defensive mkdir before PLANS_DIR usage in Block 2b
  - Already present at line 1125: `mkdir -p "$(dirname "$PLAN_PATH")"`
  - Verify covers PLANS_DIR creation
- [ ] Test with non-existent RESEARCH_DIR (delete before run)
  - Setup: `rm -rf ~/.claude/specs/*/reports`
  - Run: `/repair --command /test`
  - Verify: Directory created, no ERR trap triggered

**Files Modified**:
- `/home/benjamin/.config/.claude/commands/repair.md` (Block 1b lines 418-434)

**Validation**:
```bash
# Test defensive directory handling
# Delete research dir from previous run
rm -rf ~/.claude/specs/018_*/reports

# Run repair (should create directory automatically)
/repair --command /debug --since 2h

# Verify directory created
LATEST_SPEC=$(ls -td ~/.claude/specs/018_* | head -1)
[ -d "$LATEST_SPEC/reports" ] && echo "SUCCESS: reports/ created"

# Verify no file_error entries
tail -20 ~/.claude/data/logs/errors.jsonl | jq 'select(.error_type == "file_error" and .error_message | contains("RESEARCH_DIR"))'
# Should return empty
```

## Phase 4: Validate STATE_FILE Sourcing Pattern

**Objective**: Ensure state file is sourced correctly in all blocks to restore variables

**Estimated Time**: 1-2 hours

**Tasks**:
- [ ] Audit all blocks for consistent state restoration pattern
  - Pattern: `STATE_FILE="${CLAUDE_PROJECT_DIR}/.claude/tmp/workflow_${WORKFLOW_ID}.sh"`
  - Pattern: `if [ -f "$STATE_FILE" ]; then source "$STATE_FILE"; else exit 1; fi`
  - Blocks to check: 1b (lines 393-399), 1c (lines 575-581), 2a (lines 709, 922-928), 2a-standards (lines 922-928), 2b (lines 1033-1040), 2c (lines 1262-1268), 3 (lines 1396)
- [ ] Verify WORKFLOW_ID persistence between blocks
  - Pattern: `WORKFLOW_ID=$(cat "$STATE_ID_FILE")`
  - Check all blocks read from same STATE_ID_FILE location
  - Location: Lines 385, 566, 683, 913, 1025, 1253, 1370
- [ ] Add diagnostic output if STATE_FILE missing
  - Add: `[ -f "$STATE_FILE" ] || { echo "ERROR: State file not found: $STATE_FILE" >&2; exit 1; }`
  - Already present in all blocks, verify error message consistency
- [ ] Test state restoration across block boundary
  - Run: `/repair --type agent_error`
  - Add debug: `echo "DEBUG: STATE_FILE=$STATE_FILE, RESEARCH_DIR=${RESEARCH_DIR:-UNSET}" >&2` in Block 2a
  - Verify: RESEARCH_DIR populated in Block 2a from Block 1a persistence

**Files Modified**:
- `/home/benjamin/.config/.claude/commands/repair.md` (All blocks: state restoration sections)

**Validation**:
```bash
# Test state restoration across blocks
# Add temporary debug output to Block 2a (after state load)
/repair --command /plan --since 6h 2>&1 | tee /tmp/repair_debug.log

# Verify state restored
grep "RESEARCH_DIR" /tmp/repair_debug.log
# Should show absolute path, not UNSET

# Check state file contents at each checkpoint
STATE_FILE=$(ls -t ~/.claude/tmp/workflow_repair_*.sh | head -1)
echo "=== Block 1a variables ==="
grep -E "^(RESEARCH_DIR|PLANS_DIR|TOPIC_PATH)=" "$STATE_FILE"
```

## Phase 5: Create Integration Tests

**Objective**: Add comprehensive integration tests to prevent regression of state persistence and transition issues

**Estimated Time**: 3-4 hours

**Tasks**:
- [ ] Create test file: `.claude/tests/commands/test_repair_state_persistence.sh`
  - Test 1: Verify flat key storage for ERROR_FILTERS
  - Test 2: Verify RESEARCH_DIR populated in all blocks
  - Test 3: Verify state transitions follow research-and-plan sequence
  - Test 4: Verify defensive directory creation
- [ ] Add test fixture with known error log entries
  - Create: `.claude/tests/fixtures/repair-test-errors.jsonl`
  - Include: Sample errors matching filter criteria (command=/build, type=state_error)
- [ ] Test state file integrity across blocks
  - Test: All critical variables (RESEARCH_DIR, PLANS_DIR, TOPIC_PATH) present in state file
  - Test: WORKFLOW_ID consistent across all blocks
- [ ] Test error log status updates
  - Test: mark_errors_fix_planned updates matching errors with FIX_PLANNED status
  - Test: mark_errors_resolved_for_plan updates linked errors with RESOLVED status
- [ ] Add test to CI pipeline
  - Update: `.claude/tests/integration/test_all_fixes_integration.sh` to include repair tests
  - Ensure: Tests run in isolation (use SUPPRESS_ERR_LOGGING=1)

**Files Created**:
- `.claude/tests/commands/test_repair_state_persistence.sh`
- `.claude/tests/fixtures/repair-test-errors.jsonl`

**Validation**:
```bash
# Run integration tests
bash .claude/tests/commands/test_repair_state_persistence.sh

# Expected output:
# ✓ Test 1: ERROR_FILTERS stored as flat keys
# ✓ Test 2: RESEARCH_DIR restored in Block 2a
# ✓ Test 3: State transitions: initialize → research → plan
# ✓ Test 4: Defensive mkdir creates missing directories
# ✓ All tests passed

# Run full test suite
bash .claude/tests/integration/test_all_fixes_integration.sh
```

## Phase 6: Update Error Log Status

**Objective**: Update error log entries from FIX_PLANNED to RESOLVED

**Estimated Time**: 1 hour

dependencies: [Phase 1, Phase 2, Phase 3, Phase 4, Phase 5]

**Tasks**:
- [ ] Verify all fixes are working (tests pass, no new errors generated)
  - Run: `bash .claude/tests/commands/test_repair_state_persistence.sh`
  - Run: `/repair --command /repair --since 24h` (self-test)
  - Verify: No new errors logged with same patterns
- [ ] Update error log entries to RESOLVED status:
  ```bash
  source .claude/lib/core/error-handling.sh
  RESOLVED_COUNT=$(mark_errors_resolved_for_plan "/home/benjamin/.config/.claude/specs/018_repair_repair_20251202_120554/plans/001-repair-repair-20251202-120554-plan.md")
  echo "Resolved $RESOLVED_COUNT error log entries"
  ```
- [ ] Verify no FIX_PLANNED errors remain for this plan:
  ```bash
  REMAINING=$(query_errors --status FIX_PLANNED | jq -r '.repair_plan_path' | grep -c "018_repair_repair_20251202_120554" || echo "0")
  [ "$REMAINING" -eq 0 ] && echo "All errors resolved" || echo "WARNING: $REMAINING errors still FIX_PLANNED"
  ```
- [ ] Validate error log status distribution
  - Run: `query_errors --command /repair | jq '.status' | sort | uniq -c`
  - Verify: 28 entries moved from ERROR → FIX_PLANNED → RESOLVED
- [ ] Document resolution in repair report
  - Update: `.claude/specs/018_repair_repair_20251202_120554/reports/001-repair-errors-repair.md`
  - Add: "Resolution Status" section with test results and error count reduction

**Validation**:
```bash
# Check error log status after fixes
query_errors --command /repair --status RESOLVED | jq -r '.timestamp, .error_message' | head -20

# Verify no ERROR status entries remain
query_errors --command /repair --status ERROR | wc -l
# Should be 0 (or only new unrelated errors)

# Verify FIX_PLANNED entries linked to this plan
query_errors --status FIX_PLANNED | jq -r 'select(.repair_plan_path | contains("018_repair_repair")) | .timestamp'
# Should be empty after resolution
```

## Testing Strategy

### Unit Tests
- Test ERROR_FILTERS flat key storage (Phase 1)
- Test state transition sequence validation (Phase 2)
- Test defensive directory creation (Phase 3)
- Test state file sourcing across blocks (Phase 4)

### Integration Tests
- Test end-to-end /repair workflow with various filter combinations
- Test state persistence across all blocks (1a → 1b → 2a → 2b → 3)
- Test error log status updates (ERROR → FIX_PLANNED → RESOLVED)
- Test hard barrier pattern (pre-calculated paths, post-invocation validation)

### Regression Tests
- Verify no recurrence of original 28 error patterns
- Test with missing RESEARCH_DIR (defensive handling)
- Test with invalid state transitions (rejection by state machine)
- Test with malformed state file (error recovery)

### Manual Validation
- Run /repair with different filter combinations (--command, --type, --since)
- Inspect state files at each block checkpoint
- Review error log entries before/after fixes
- Verify workflow output matches expected format

## Rollback Plan

If implementation introduces regressions:

1. **Revert Phase 1 (ERROR_FILTERS flat keys)**:
   - Restore JSON construction: `ERROR_FILTERS=$(jq -n ...)`
   - Restore single append: `append_workflow_state "ERROR_FILTERS" "$ERROR_FILTERS"`
   - Note: Does not fix type validation errors

2. **Revert Phase 2 (State transitions)**:
   - Restore original transition sequence (if any)
   - Remove `sm_validate_state` checks

3. **Revert Phase 3 (Defensive validation)**:
   - Remove mkdir before find commands
   - Restore direct find without fallback

4. **Revert Phase 4 (State sourcing)**:
   - Restore original state restoration pattern (if changed)

5. **Full Rollback**:
   - Git checkout: `git checkout HEAD -- .claude/commands/repair.md`
   - Remove test files: `rm .claude/tests/commands/test_repair_state_persistence.sh`
   - Restore error log: `cp .claude/data/logs/errors.jsonl.backup .claude/data/logs/errors.jsonl`

## Implementation Notes

### Critical Constraints
- All changes must maintain backward compatibility with existing state files
- Error log format changes must preserve queryability (status, repair_plan_path fields)
- State machine transitions must follow strict validation rules (no shortcuts)

### Performance Considerations
- Flat key storage reduces jq invocations (faster state restoration)
- Defensive mkdir adds negligible overhead (sub-millisecond)
- State file validation adds ~100ms per block (acceptable)

### Security Considerations
- State file contains user filter criteria (command, type, since) - sanitize before persistence
- Error log entries contain command arguments - avoid logging sensitive data
- Temporary state files should be cleaned up on workflow completion

## Definition of Done

- [ ] All phases completed and validated
- [ ] Integration tests pass (exit code 0)
- [ ] Manual /repair invocation succeeds without logged errors
- [ ] Error log shows 0 ERROR status entries for /repair command
- [ ] Error log shows 28 RESOLVED status entries linked to this plan
- [ ] Documentation updated (repair-output.md includes resolution summary)
- [ ] Code review completed (standards compliance verified)
- [ ] Pre-commit hooks pass (library sourcing, bash conditionals, README structure)
