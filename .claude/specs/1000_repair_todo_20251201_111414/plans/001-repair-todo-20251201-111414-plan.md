# /todo Command State Persistence Repair Plan

## Metadata
- **Date**: 2025-12-01
- **Feature**: Fix /todo command state persistence initialization errors
- **Scope**: Repair state initialization in Block 1 and Block 2a of todo.md command
- **Estimated Phases**: 5
- **Estimated Hours**: 6
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Status**: [COMPLETE]
- **Structure Level**: 0 (Single File)
- **Complexity Score**: 19.0
- **Research Reports**:
  - [Error Analysis Report](../reports/001-todo-errors-analysis.md)

## Overview

The `/todo` command fails during Block 2a (Status Classification Setup) with repeated **"ERROR: STATE_FILE not set. Call init_workflow_state first."** errors followed by exit code 141. The root cause is that Block 2a sources the `state-persistence.sh` library and immediately calls `append_workflow_state()` without first initializing the state file via `init_workflow_state()`.

This repair plan implements proper state initialization following the three-tier library sourcing pattern and state-persistence architecture. The fix requires:

1. Initialize workflow state in Block 1 after library sourcing
2. Initialize/regenerate state in Block 2a before state operations
3. Add proper error handling and verification checks
4. Test all /todo modes (default, --clean, --dry-run)
5. Verify error logging integration

## Research Summary

The error analysis identified the critical issue:
- **Primary Problem**: Block 2a calls `append_workflow_state()` without initializing `STATE_FILE`
- **Root Cause**: Missing `init_workflow_state()` call in Block 2a
- **Library Pattern**: Three-tier sourcing requires explicit initialization before state operations
- **Current State**: Exit code 141 masks the underlying STATE_FILE initialization failure
- **Recommended Solution**: Call `init_workflow_state()` with WORKFLOW_ID from Block 1

## Success Criteria

- [x] Block 1 initializes STATE_FILE via `init_workflow_state()` call
- [x] Block 2a regenerates/initializes STATE_FILE before `append_workflow_state()` calls
- [x] All `append_workflow_state()` operations in Block 2a succeed without errors
- [x] Exit code 0 on successful /todo execution
- [x] /todo --clean mode works correctly with state persistence
- [x] /todo --dry-run mode works correctly with state persistence
- [x] Error logging integration functional (COMMAND_NAME, WORKFLOW_ID, USER_ARGS exported)
- [x] All error scenarios properly logged via error-handling.sh

## Technical Design

### Architecture Overview

The repair implements proper state initialization following established patterns:

1. **Block 1 (Setup)**:
   - Source state-persistence.sh library
   - Call `init_workflow_state()` to create STATE_FILE
   - Export STATE_FILE variable for subprocesses
   - Set up EXIT trap for cleanup

2. **Block 2a (Status Classification Setup)**:
   - Detect CLAUDE_PROJECT_DIR and source libraries
   - Call `init_workflow_state()` with WORKFLOW_ID from Block 1
   - Verify STATE_FILE creation
   - Set error logging context (COMMAND_NAME, WORKFLOW_ID, USER_ARGS)
   - Execute `append_workflow_state()` calls with initialized state

3. **Block 2c/3/4 (Subsequent Blocks)**:
   - Restore persisted variables via `load_workflow_state()`
   - Continue normal block execution with state available

### State Initialization Pattern

```bash
# === INITIALIZE WORKFLOW STATE ===
# Call init_workflow_state() to create/regenerate state file
STATE_FILE=$(init_workflow_state "$WORKFLOW_ID")

# Verify state file creation
if [ ! -f "$STATE_FILE" ]; then
  log_command_error "$COMMAND_NAME" "$WORKFLOW_ID" "$USER_ARGS" \
    "state_error" "Failed to initialize state file: $STATE_FILE" \
    "Block:StateInit" \
    '{"workflow_id":"'"$WORKFLOW_ID"'"}'
  echo "ERROR: Failed to initialize workflow state" >&2
  exit 1
fi

# Export for subprocesses
export STATE_FILE
```

### Error Logging Context

Block 2a must set error logging context before state operations:

```bash
COMMAND_NAME="/todo"
USER_ARGS="$([ "$CLEAN_MODE" = "true" ] && echo "--clean")$([ "$DRY_RUN" = "true" ] && echo " --dry-run")"
export COMMAND_NAME USER_ARGS WORKFLOW_ID STATE_FILE
```

## Implementation Phases

### Phase 1: Block 1 State Initialization [COMPLETE]
dependencies: []

**Objective**: Initialize workflow state in Block 1 after library sourcing

**Complexity**: Low

**Tasks**:
- [x] Locate Block 1 library sourcing section (after line 202 in todo.md)
- [x] Add state initialization code block calling `init_workflow_state()`
- [x] Add state file verification with error handling
- [x] Add EXIT trap for state file cleanup
- [x] Export STATE_FILE variable for subprocess access
- [x] Verify error logging context set (COMMAND_NAME, WORKFLOW_ID, USER_ARGS exported)

**Testing**:
```bash
# Verify Block 1 creates state file
WORKFLOW_ID="todo_$(date +%s)"
source .claude/lib/core/state-persistence.sh
STATE_FILE=$(init_workflow_state "$WORKFLOW_ID")
test -f "$STATE_FILE" && echo "✓ State file created" || echo "✗ State file missing"
cat "$STATE_FILE"  # Should be readable
```

**Expected Duration**: 1 hour

### Phase 2: Block 2a State Initialization [COMPLETE]
dependencies: [1]

**Objective**: Initialize state in Block 2a before append_workflow_state() calls

**Complexity**: Medium

**Tasks**:
- [x] Locate Block 2a status classification setup (lines 282-335 in todo.md)
- [x] Add state initialization code after library sourcing (after line 310)
- [x] Call `init_workflow_state()` with WORKFLOW_ID from Block 1 output
- [x] Add state file verification with error logging
- [x] Set error logging context (COMMAND_NAME, WORKFLOW_ID, USER_ARGS, CLEAN_MODE, DRY_RUN)
- [x] Verify append_workflow_state() calls now work without errors
- [x] Add additional state persistence for COMMAND_NAME, USER_ARGS, CLEAN_MODE, DRY_RUN

**Testing**:
```bash
# Test Block 2a state initialization
/todo 2>&1 | grep -q "ERROR: STATE_FILE not set" && echo "✗ Still has error" || echo "✓ No STATE_FILE error"

# Verify state file contains persisted variables
STATE_FILE=$(ls -t .claude/tmp/workflow_todo_*.sh 2>/dev/null | head -1)
grep "DISCOVERED_PROJECTS" "$STATE_FILE" && echo "✓ Variables persisted"
```

**Expected Duration**: 1.5 hours

### Phase 3: Block 2c State Restoration [COMPLETE]
dependencies: [2]

**Objective**: Ensure Block 2c correctly restores persisted variables

**Complexity**: Low

**Tasks**:
- [x] Verify Block 2c sources state-persistence.sh (already done)
- [x] Verify Block 2c calls `load_workflow_state()` or sources STATE_FILE
- [x] Check that DISCOVERED_PROJECTS, CLASSIFIED_RESULTS, SPECS_ROOT restored correctly
- [x] Verify error logging context available (COMMAND_NAME, WORKFLOW_ID)
- [x] Test state file restoration in verification block

**Testing**:
```bash
# Execute /todo and check that Block 2c verification completes
/todo 2>&1 | tail -5

# Check verification checkpoint
/todo 2>&1 | grep -q "Verification complete"
```

**Expected Duration**: 0.5 hours

### Phase 4: Integration Testing - All Modes [COMPLETE]
dependencies: [3]

**Objective**: Test all /todo command modes with proper state persistence

**Complexity**: Medium

**Tasks**:
- [x] Test default mode: `/todo` - verify no STATE_FILE errors, exit code 0
- [x] Test clean mode: `/todo --clean` - verify state persists through cleanup
- [x] Test dry-run mode: `/todo --dry-run` - verify no STATE_FILE errors
- [x] Test combined: `/todo --clean --dry-run` - verify cleanup preview works
- [x] Verify state files cleaned up after execution (EXIT trap works)
- [x] Check error logs for any state_error entries

**Testing**:
```bash
# Test default mode
/todo && echo "✓ Default mode passed" || echo "✗ Default mode failed: $?"

# Test clean mode
/todo --clean && echo "✓ Clean mode passed" || echo "✗ Clean mode failed: $?"

# Test dry-run mode
/todo --dry-run && echo "✓ Dry-run mode passed" || echo "✗ Dry-run mode failed: $?"

# Verify no STATE_FILE errors in any mode
for i in 1 2 3; do
  /todo >/dev/null 2>&1
  /todo --clean >/dev/null 2>&1
  /todo --dry-run >/dev/null 2>&1
done
grep -c "STATE_FILE not set" .claude/logs/errors.jsonl 2>/dev/null || echo "0"
```

**Expected Duration**: 1.5 hours

### Phase 5: Verify Error Log Status [COMPLETE]
dependencies: [4]

**Objective**: Verify all fixes are working and update error log status

**Complexity**: Low

**Tasks**:
- [x] Run full /todo test suite (all modes) and verify no errors
- [x] Check error logs for any remaining state_error entries
- [x] Verify exit codes are 0 on successful execution
- [x] Confirm no 141 exit codes in recent executions
- [x] Query error log for /todo command errors: `/errors --command /todo --summary`
- [x] Mark error log entries as RESOLVED if no new errors detected
- [x] Document any remaining issues (if applicable)

**Testing**:
```bash
# Query recent errors for /todo command
/errors --command /todo --since 1h --summary

# Verify no exit code 141 errors
/errors --type execution_error --since 1h | grep -q "141" && echo "✗ Still seeing 141" || echo "✓ No 141 errors"

# Run smoke test suite
echo "=== Smoke Tests ==="
/todo && echo "✓ Test 1: Default mode"
/todo --dry-run && echo "✓ Test 2: Dry-run mode"
/todo --clean --dry-run && echo "✓ Test 3: Clean preview"
echo "=== All tests passed ==="
```

**Expected Duration**: 1 hour

## Testing Strategy

### Unit Testing
1. **State Initialization Tests**: Verify `init_workflow_state()` creates valid STATE_FILE
2. **Library Sourcing Tests**: Verify three-tier pattern properly sources all libraries
3. **Error Logging Tests**: Verify error context (COMMAND_NAME, WORKFLOW_ID, USER_ARGS) properly set

### Integration Testing
1. **Block-to-Block State Persistence**: Verify STATE_FILE survives subprocess boundaries
2. **Mode Testing**: Test default, --clean, and --dry-run modes
3. **Error Recovery**: Verify graceful error handling when state initialization fails

### System Testing
1. **End-to-End Workflow**: Run /todo through completion without STATE_FILE errors
2. **Cleanup Verification**: Run /todo --clean and verify proper execution
3. **State Cleanup**: Verify EXIT trap properly cleans up temporary state files

### Test Commands
```bash
# Unit tests
bash .claude/tests/lib/test_state_persistence.sh
bash .claude/tests/lib/test_todo_functions.sh

# Integration tests
bash .claude/tests/commands/test_todo_block_persistence.sh
bash .claude/tests/integration/test_todo_all_modes.sh

# System test
/todo && /todo --clean --dry-run && /todo --dry-run
```

## Documentation Requirements

- **Update todo.md command file**: Add state initialization block documentation
- **Update CLAUDE.md**: Reference proper state initialization pattern in /todo section
- **Update error handling docs**: Document state_error recovery procedures
- **Code comments**: Add inline documentation explaining state initialization

## Dependencies

- **Libraries**: state-persistence.sh (>=1.6.0), error-handling.sh (>=1.0.0)
- **Environment**: CLAUDE_PROJECT_DIR must be set
- **Temp Directory**: `.claude/tmp/` must exist (created by init_workflow_state)

## Prevention Guidelines

For future command development:

1. **Always initialize state in Block 1** before any state operations
2. **Explicitly export STATE_FILE** to subprocesses that need it
3. **Document state initialization** in block comments
4. **Test state persistence** across block boundaries
5. **Use load_workflow_state()** with proper validation in subsequent blocks

---

## Notes

- All phase headings include [NOT STARTED] status markers for progress tracking
- This is a repair workflow (research-and-plan) as specified in input contract
- Plan follows adaptive tier selection (Tier 1 - single file structure)
- Total estimated hours: 6 (1 + 1.5 + 0.5 + 1.5 + 1)
- Error log status should be updated to RESOLVED upon successful completion of Phase 5
