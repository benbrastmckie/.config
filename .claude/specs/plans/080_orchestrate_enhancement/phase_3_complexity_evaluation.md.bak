# Phase 3: Complexity Evaluation - Automated Plan Analysis

## Metadata
- **Phase Number**: 3
- **Phase Name**: Complexity Evaluation - Automated Plan Analysis
- **Parent Plan**: [080_orchestrate_enhancement.md](../080_orchestrate_enhancement.md)
- **Complexity Score**: 8/10
- **Expansion Reason**: Algorithmic design, multi-factor analysis, and critical role in downstream automation
- **Dependencies**: depends_on: [phase_1, phase_2]
- **Estimated Duration**: 6-8 hours
- **Risk Level**: High (algorithm accuracy affects all downstream expansion decisions)

## Objective

Implement automated complexity evaluation system that analyzes implementation plans, calculates multi-factor complexity scores, and determines which phases should be expanded to separate files. This system enables intelligent plan organization by identifying high-complexity phases that require detailed expansion before implementation.

## Overview

This phase creates the analytical foundation for adaptive plan organization by implementing:

1. **Weighted Complexity Formula**: Multi-factor algorithm balancing task count, file dependencies, risk factors, testing scope, and dependency chain depth
2. **complexity-estimator Agent**: Specialized agent that analyzes plan structure and returns structured complexity reports
3. **Threshold Configuration**: CLAUDE.md integration for project-specific complexity tolerances
4. **Metadata Injection**: Automatic insertion of complexity scores into plan files for transparency
5. **Expansion Triggering**: Automated decision-making for when to invoke expansion-specialist

The complexity evaluation system runs after plan creation (Phase 2) and before implementation (Phase 5), ensuring plans are optimally structured before execution begins.

## Success Criteria

- [ ] Complexity formula produces scores 0.0-15.0 with clear normalization
- [ ] complexity-estimator agent returns structured YAML reports
- [ ] Scores accurately reflect manual complexity assessment (95%+ correlation)
- [ ] Thresholds loaded from CLAUDE.md `adaptive_planning_config` section
- [ ] Plans automatically injected with complexity metadata
- [ ] Expansion recommendations trigger expansion-specialist correctly
- [ ] Error handling covers malformed plans, missing metadata, invalid YAML
- [ ] Performance: <5 seconds for plans up to 50 phases

## Architecture

### Complexity Score Components

The complexity score is a weighted combination of 5 factors:

```yaml
Components:
  task_count:
    weight: 0.30
    rationale: Task volume is primary complexity driver
    measurement: Count of checkbox items per phase

  file_references:
    weight: 0.20
    rationale: More files = more integration complexity
    measurement: Count of unique file paths in phase

  dependency_depth:
    weight: 0.20
    rationale: Complex dependency chains increase coordination overhead
    measurement: Maximum chain length from dependency graph

  test_scope:
    weight: 0.15
    rationale: Comprehensive testing adds complexity
    measurement: Count of test-related tasks and commands

  risk_factors:
    weight: 0.15
    rationale: High-risk operations require extra care
    measurement: Presence of keywords (security, migration, breaking, API)
```

**Total Weight**: 1.00 (100%)

### Normalization Strategy

Raw scores normalized to 0.0-15.0 scale:

```
normalized_score = min(15.0, raw_score * normalization_factor)

Where:
  normalization_factor = 15.0 / expected_max_raw_score
  expected_max_raw_score = (30 tasks * 0.3) + (30 files * 0.2) + (5 depth * 0.2) + (10 tests * 0.15) + (5 risks * 0.15)
                         = 9.0 + 6.0 + 1.0 + 1.5 + 0.75
                         = 18.25

  normalization_factor = 15.0 / 18.25 = 0.822
```

This ensures scores typically range 0.0-12.0 with extreme cases capping at 15.0.

### Threshold Configuration

Thresholds read from CLAUDE.md section:

```markdown
<!-- SECTION: adaptive_planning_config -->
## Adaptive Planning Configuration

### Complexity Thresholds

- **Expansion Threshold**: 8.0 (phases above this score → Level 1 expansion)
- **Task Count Threshold**: 10 (phases with >N tasks → expand regardless of score)
- **File Reference Threshold**: 10 (phases with >N files → increased complexity)
- **Replan Limit**: 2 (max auto-replans during /implement)
<!-- END_SECTION: adaptive_planning_config -->
```

**Configuration Priority**:
1. Project-specific CLAUDE.md (subdirectory-specific overrides)
2. Root CLAUDE.md (project defaults)
3. Hardcoded defaults (expansion: 8.0, task: 10, file: 10)

## Stage 1: Design Weighted Complexity Formula

**Objective**: Design and document the mathematical complexity formula with specific coefficients, normalization approach, and validation metrics.

**Duration**: 1-2 hours

### Tasks

- [ ] **Document weighted formula specification**
  - Define 5 complexity factors (task_count, file_references, dependency_depth, test_scope, risk_factors)
  - Assign weights: 0.30, 0.20, 0.20, 0.15, 0.15 (totaling 1.00)
  - Document rationale for each weight assignment
  - Create formula spec document: `.claude/docs/reference/complexity-formula-spec.md`

- [ ] **Design normalization algorithm**
  - Calculate expected maximum raw score (18.25 based on typical max values)
  - Define normalization factor: 15.0 / 18.25 = 0.822
  - Implement capping at 15.0 for extreme outliers
  - Document edge cases: 0 tasks, negative values, infinity handling
  - Add examples:
    ```
    Low complexity: 3 tasks, 2 files, 0 deps, 1 test, 0 risks → Score 1.9
    Medium complexity: 8 tasks, 5 files, 1 dep, 3 tests, 1 risk → Score 5.3
    High complexity: 15 tasks, 12 files, 2 deps, 5 tests, 2 risks → Score 8.7
    Extreme complexity: 30 tasks, 25 files, 5 deps, 10 tests, 5 risks → Score 14.2
    ```

- [ ] **Define measurement methodology for each factor**
  - **task_count**: `grep -c "^- \[ \]" phase_content` (count unchecked checkboxes)
  - **file_references**: `grep -oE '(\w+/)+\w+\.\w+' | sort -u | wc -l` (unique file paths)
  - **dependency_depth**: Parse `depends_on: [...]` metadata, build graph, find max chain length
  - **test_scope**: `grep -c "test\|spec\|coverage" phase_content` (test-related keywords)
  - **risk_factors**: `grep -c "security\|migration\|breaking\|API\|database schema" phase_content` (high-risk keywords)
  - Document measurement commands in formula spec

- [ ] **Create validation dataset**
  - Manually assess complexity of 10 existing plans (from specs/plans/)
  - Rate each plan phase 1-15 based on human judgment
  - Document ground truth ratings in `.claude/tests/fixtures/complexity/ground_truth.yaml`
  - Use for correlation testing in Stage 2

- [ ] **Design coefficient tuning process**
  - Define tuning methodology: Compare algorithm scores vs ground truth
  - Calculate correlation coefficient (target >0.90)
  - Document weight adjustment procedure if correlation <0.90
  - Plan for iterative refinement based on real-world usage

### Testing

```bash
# Test formula documentation completeness
test -f /home/benjamin/.config/.claude/docs/reference/complexity-formula-spec.md
grep -q "task_count.*0.30" /home/benjamin/.config/.claude/docs/reference/complexity-formula-spec.md

# Test normalization examples
# Verify low complexity example: 3 tasks * 0.3 * 0.822 = 0.74 (base) + other factors = ~1.9
# Verify high complexity example produces score >8.0

# Test ground truth dataset
test -f /home/benjamin/.config/.claude/tests/fixtures/complexity/ground_truth.yaml
grep -q "phase_.*complexity:" /home/benjamin/.config/.claude/tests/fixtures/complexity/ground_truth.yaml
```

### Expected Outcomes

- Complete formula specification document with mathematical details
- Normalization algorithm preventing score inflation
- Measurement methodology for automated factor extraction
- Validation dataset with 10+ manually-rated plan phases
- Tuning process for weight refinement

---

## Stage 2: Create complexity-estimator Agent

**Objective**: Implement the complexity-estimator agent that reads plan files, applies the weighted formula, and returns structured complexity reports.

**Duration**: 2-3 hours

### Tasks

- [ ] **Create agent prompt file**
  - File: `.claude/agents/complexity-estimator.md`
  - Define agent role: "Analyze implementation plans and calculate complexity scores"
  - Specify input format:
    ```yaml
    Input:
      plan_path: "/path/to/plan.md"
      thresholds:
        expansion_threshold: 8.0
        task_count_threshold: 10
        file_reference_threshold: 10
    ```
  - Specify output format (YAML structure, see below)
  - Include error handling instructions for malformed plans

- [ ] **Implement factor extraction logic**
  - **Task Count Extraction**:
    ```bash
    # Extract phase content between ### Phase N: and next ### Phase or end
    # Count checkboxes: grep -c "^- \[ \]"
    # Weight: task_count * 0.3
    ```
  - **File Reference Extraction**:
    ```bash
    # Extract all file paths: grep -oE '([a-zA-Z0-9_-]+/)+[a-zA-Z0-9_-]+\.[a-zA-Z0-9]+'
    # Remove duplicates: sort -u
    # Count: wc -l
    # Weight: file_count * 0.2
    ```
  - **Dependency Depth Extraction**:
    ```bash
    # Parse dependency metadata: grep "depends_on:" phase_content
    # Build dependency graph (phase -> [dependencies])
    # Calculate max chain length using recursive traversal
    # Weight: depth * 0.2
    ```
  - **Test Scope Extraction**:
    ```bash
    # Count test-related tasks: grep -ic "test\|spec\|coverage\|testing"
    # Weight: test_count * 0.15
    ```
  - **Risk Factor Extraction**:
    ```bash
    # Count high-risk keywords: grep -ic "security\|migration\|breaking\|API\|schema\|authentication\|authorization"
    # Weight: risk_count * 0.15
    ```

- [ ] **Implement weighted formula calculation**
  - Calculate raw score: `(task * 0.3) + (files * 0.2) + (depth * 0.2) + (tests * 0.15) + (risks * 0.15)`
  - Apply normalization: `normalized = min(15.0, raw * 0.822)`
  - Round to 1 decimal place: `rounded = round(normalized, 1)`
  - Classify complexity:
    ```
    0.0-3.0: Low
    3.1-6.0: Medium
    6.1-8.0: Medium-High
    8.1-12.0: High
    12.1-15.0: Very High
    ```

- [ ] **Define structured output format**
  ```yaml
  complexity_report:
    plan_path: "/path/to/027_auth.md"
    analysis_timestamp: "2025-10-21T14:32:00Z"
    total_phases: 5

    phases:
      - phase_number: 1
        phase_name: "Setup and Configuration"
        complexity_score: 3.2
        complexity_level: "Medium"
        factors:
          task_count: 5
          file_references: 3
          dependency_depth: 0
          test_scope: 2
          risk_factors: 0
        raw_score: 3.9
        normalized_score: 3.2
        expansion_recommended: false
        expansion_reason: null

      - phase_number: 2
        phase_name: "Backend Implementation"
        complexity_score: 8.5
        complexity_level: "High"
        factors:
          task_count: 15
          file_references: 12
          dependency_depth: 2
          test_scope: 5
          risk_factors: 3
        raw_score: 10.35
        normalized_score: 8.5
        expansion_recommended: true
        expansion_reason: "Complexity score 8.5 exceeds threshold 8.0 (15 tasks, 12 files, security risks)"

    summary:
      phases_to_expand: [2, 4]
      expansion_count: 2
      average_complexity: 5.8
      max_complexity: 8.5
      recommendation: "2 phases recommended for expansion before implementation"
  ```

- [ ] **Implement error handling**
  - **Malformed plan file**: Missing phase headers, invalid markdown structure
    - Detection: Check for `### Phase N:` patterns
    - Response: Return error report with specific line numbers
  - **Missing metadata**: No dependency information, no task checkboxes
    - Detection: Check for `- [ ]` patterns, `depends_on:` metadata
    - Response: Return partial report with warnings
  - **Invalid YAML dependencies**: Syntax errors in `depends_on: [...]`
    - Detection: Try parsing YAML, catch exceptions
    - Response: Skip dependency depth calculation, log warning
  - **File read errors**: Permission denied, file not found
    - Detection: Check file existence before reading
    - Response: Return error with file path and error type

- [ ] **Add agent behavioral guidelines**
  - "NEVER modify the plan file during analysis"
  - "Return only structured YAML output, no conversational text"
  - "Include all phases in report, even if complexity is 0.0"
  - "Document any assumptions made during analysis"
  - "Report warnings for ambiguous or unclear plan structure"

### Testing

```bash
# Test complexity-estimator agent with simple plan
cat > /tmp/test_plan.md <<'EOF'
### Phase 1: Simple Setup
- [ ] Install dependencies (package.json)
- [ ] Create config file (config/app.json)
- [ ] Write unit tests
EOF

# Invoke agent (simulated)
# Expected: complexity_score ~2.5 (3 tasks, 2 files, 0 deps, 1 test, 0 risks)

# Test with complex plan
cat > /tmp/test_complex_plan.md <<'EOF'
### Phase 2: Authentication System
depends_on: [phase_1]
- [ ] Design database schema (db/schema.sql)
- [ ] Implement user model (src/models/user.ts)
- [ ] Create JWT service (src/auth/jwt.ts)
- [ ] Add password hashing (src/auth/hash.ts)
- [ ] Implement OAuth provider (src/auth/oauth.ts)
- [ ] Add session management (src/auth/session.ts)
- [ ] Create middleware (src/middleware/auth.ts)
- [ ] Write API endpoints (src/routes/auth.ts)
- [ ] Add rate limiting (src/middleware/ratelimit.ts)
- [ ] Implement 2FA (src/auth/2fa.ts)
- [ ] Write unit tests (tests/auth.test.ts)
- [ ] Write integration tests (tests/integration/auth.test.ts)
- [ ] Add security auditing (src/audit/security.ts)
- [ ] Create documentation (docs/auth.md)
- [ ] Setup CI/CD pipeline (.github/workflows/auth.yml)
EOF

# Invoke agent (simulated)
# Expected: complexity_score >8.0 (15 tasks, 15 files, 1 dep, 2 tests, 3 security risks)

# Test error handling with malformed plan
cat > /tmp/test_malformed.md <<'EOF'
This is not a valid plan file.
No phase headers present.
EOF

# Invoke agent
# Expected: Error report with "No phase headers found"

# Test correlation with ground truth dataset
# Compare agent scores vs manual ratings
# Calculate correlation coefficient
# Expected: >0.90 correlation
```

### Expected Outcomes

- complexity-estimator agent created in `.claude/agents/`
- Agent returns structured YAML complexity reports
- Factor extraction logic accurate for all 5 factors
- Weighted formula calculation matches specification
- Error handling covers common failure modes
- Correlation with manual ratings >0.90

---

## Stage 3: Integrate Complexity Analysis into orchestrate.md

**Objective**: Add complexity evaluation invocation point in /orchestrate command after plan creation, extract complexity reports, and store expansion recommendations in workflow state.

**Duration**: 1-2 hours

### Tasks

- [ ] **Add Phase 2.5 to orchestrate.md workflow**
  - Insert new section after Phase 2 (Planning) completion
  - Title: "Phase 2.5: Complexity Evaluation and Expansion Analysis"
  - Position: After plan-architect returns plan path, before expansion-specialist
  - Dependencies: Requires plan file to exist

- [ ] **Invoke complexity-estimator agent**
  - Use Task tool to invoke complexity-estimator
  - Pass plan path from Phase 2 output
  - Pass thresholds loaded from CLAUDE.md (Stage 4)
  - Example invocation:
    ```yaml
    Task:
      subagent_type: "general-purpose"
      description: "Analyze plan complexity and recommend expansion"
      prompt: |
        Read and follow the behavioral guidelines from:
        /home/benjamin/.config/.claude/agents/complexity-estimator.md

        You are acting as a Complexity Estimator Agent.

        ANALYSIS TASK: Calculate complexity scores for all phases

        Input:
          plan_path: "{plan_path_from_phase_2}"
          thresholds:
            expansion_threshold: 8.0
            task_count_threshold: 10
            file_reference_threshold: 10

        Output: Structured YAML complexity report
    ```

- [ ] **Extract complexity report from agent response**
  - Parse YAML output from complexity-estimator
  - Extract key fields:
    - `phases[]`: Array of phase complexity objects
    - `summary.phases_to_expand[]`: Array of phase numbers needing expansion
    - `summary.expansion_count`: Count of phases to expand
    - `summary.recommendation`: Human-readable summary
  - Handle parsing errors with fallback to manual expansion decision

- [ ] **Store expansion recommendations in workflow state**
  - Create workflow state object:
    ```yaml
    workflow_state:
      plan_path: "/path/to/027_auth.md"
      complexity_report:
        phases_to_expand: [2, 4]
        expansion_count: 2
        average_complexity: 5.8
        max_complexity: 8.5
      expansion_pending: true  # Flag for Phase 4 (expansion)
    ```
  - Pass state to subsequent phases

- [ ] **Display complexity summary to user**
  - Format user-friendly summary:
    ```
    ✓ Phase 2.5: Complexity Evaluation Complete

    Plan Analysis: 027_auth_implementation.md
    Total Phases: 5
    Average Complexity: 5.8

    Complexity Breakdown:
      Phase 1: Setup and Configuration       | 3.2 (Medium)     | ✓ No expansion
      Phase 2: Backend Implementation        | 8.5 (High)       | ⚠ Expansion recommended
      Phase 3: Frontend Integration          | 5.1 (Medium)     | ✓ No expansion
      Phase 4: Testing and Security Review   | 7.9 (Medium-High)| ✓ No expansion
      Phase 5: Documentation and Deployment  | 4.2 (Medium)     | ✓ No expansion

    Recommendation: 1 phase requires expansion before implementation
    Next: Phase 4 (Plan Expansion)
    ```
  - Use colored output if terminal supports it (green ✓, yellow ⚠)

- [ ] **Add conditional branching logic**
  - If `expansion_count > 0`:
    - Set `workflow_state.expansion_pending = true`
    - Proceed to Phase 4 (Plan Expansion with expansion-specialist)
  - If `expansion_count == 0`:
    - Set `workflow_state.expansion_pending = false`
    - Skip Phase 4, proceed directly to Phase 5 (Implementation)
    - Display: "✓ No expansion needed, proceeding to implementation"

- [ ] **Add error recovery for complexity analysis failures**
  - If complexity-estimator fails (parsing error, agent error):
    - Log warning: "Complexity analysis failed, proceeding without expansion"
    - Set `workflow_state.expansion_pending = false`
    - Continue to implementation without expansion
    - Store error details in workflow state for debugging

### Testing

```bash
# Test orchestrate.md with simple plan (no expansion needed)
/orchestrate "Fix typo in README.md"
# Verify: Phase 2.5 runs complexity-estimator
# Verify: Complexity summary displayed
# Verify: "No expansion needed" message shown
# Verify: Phase 4 skipped, proceeds to Phase 5

# Test orchestrate.md with complex plan (expansion recommended)
/orchestrate "Implement authentication with OAuth, JWT, 2FA, and session management"
# Verify: Phase 2.5 calculates high complexity scores
# Verify: Expansion summary shows "2 phases require expansion"
# Verify: workflow_state.expansion_pending = true
# Verify: Proceeds to Phase 4 (expansion-specialist invoked)

# Test error handling
# Simulate complexity-estimator failure (e.g., malformed plan)
# Verify: Error logged, workflow continues without expansion
# Verify: No crash or hang
```

### Expected Outcomes

- Phase 2.5 added to orchestrate.md workflow
- complexity-estimator invoked automatically after planning
- Complexity summary displayed to user
- Expansion recommendations stored in workflow state
- Conditional branching to expansion phase working
- Error recovery prevents workflow failure

---

## Stage 4: Implement Threshold Configuration Reading

**Objective**: Read complexity thresholds from CLAUDE.md `adaptive_planning_config` section and pass to complexity-estimator, supporting project-specific and subdirectory-specific overrides.

**Duration**: 1 hour

### Tasks

- [ ] **Create threshold extraction utility**
  - File: `.claude/lib/complexity-thresholds.sh`
  - Function: `get_complexity_thresholds()`
  - Search order:
    1. Current directory's CLAUDE.md (subdirectory-specific)
    2. Parent directories upward to project root (recursive search)
    3. Hardcoded defaults if no CLAUDE.md found
  - Extract section using markers:
    ```bash
    # Extract adaptive_planning_config section
    sed -n '/<!-- SECTION: adaptive_planning_config -->/,/<!-- END_SECTION: adaptive_planning_config -->/p' CLAUDE.md
    ```
  - Parse threshold values:
    ```bash
    # Extract expansion_threshold
    grep "Expansion Threshold:" | grep -oE '[0-9]+\.[0-9]+'

    # Extract task_count_threshold
    grep "Task Count Threshold:" | grep -oE '[0-9]+'

    # Extract file_reference_threshold
    grep "File Reference Threshold:" | grep -oE '[0-9]+'

    # Extract replan_limit
    grep "Replan Limit:" | grep -oE '[0-9]+'
    ```

- [ ] **Define default threshold values**
  - Hardcoded fallbacks when CLAUDE.md not found:
    ```yaml
    defaults:
      expansion_threshold: 8.0
      task_count_threshold: 10
      file_reference_threshold: 10
      replan_limit: 2
    ```
  - Document defaults in `.claude/docs/reference/complexity-defaults.md`

- [ ] **Implement threshold override mechanism**
  - Subdirectory CLAUDE.md overrides parent CLAUDE.md
  - Example: `nvim/CLAUDE.md` overrides root `CLAUDE.md` for nvim/ subdirectory
  - Support partial overrides (only some thresholds specified):
    ```markdown
    <!-- SECTION: adaptive_planning_config -->
    ## Adaptive Planning Configuration
    - **Expansion Threshold**: 5.0  # Override: more aggressive expansion
    <!-- Inherit other thresholds from parent CLAUDE.md -->
    <!-- END_SECTION: adaptive_planning_config -->
    ```
  - Merge parent thresholds with subdirectory thresholds (subdirectory wins)

- [ ] **Integrate threshold loading into orchestrate.md**
  - Before Phase 2.5 (complexity evaluation):
    - Invoke threshold extraction utility
    - Load thresholds based on plan location
    - Store in workflow state
  - Pass thresholds to complexity-estimator agent:
    ```yaml
    complexity_estimator_input:
      thresholds:
        expansion_threshold: 8.0  # From CLAUDE.md
        task_count_threshold: 10
        file_reference_threshold: 10
    ```

- [ ] **Add threshold validation**
  - Validate extracted thresholds:
    - `expansion_threshold`: 0.0 ≤ value ≤ 15.0
    - `task_count_threshold`: 1 ≤ value ≤ 50
    - `file_reference_threshold`: 1 ≤ value ≤ 100
    - `replan_limit`: 1 ≤ value ≤ 5
  - If invalid, log warning and use defaults
  - Display to user: "Using custom complexity thresholds from CLAUDE.md"

- [ ] **Document threshold configuration in CLAUDE.md**
  - Update root CLAUDE.md with threshold configuration section
  - Add examples for different project types:
    - Research-heavy (aggressive expansion): threshold 5.0
    - Simple web app (conservative expansion): threshold 10.0
    - Mission-critical (maximum organization): threshold 3.0
  - Link to complexity formula spec for details

### Testing

```bash
# Test threshold extraction from CLAUDE.md
bash .claude/lib/complexity-thresholds.sh get_complexity_thresholds
# Expected: expansion_threshold=8.0, task_count_threshold=10, ...

# Test default fallback when CLAUDE.md missing
cd /tmp && bash /home/benjamin/.config/.claude/lib/complexity-thresholds.sh get_complexity_thresholds
# Expected: Default values (8.0, 10, 10, 2)

# Test subdirectory override
# Create test subdirectory with custom CLAUDE.md
mkdir -p /tmp/test_project/subdir
cat > /tmp/test_project/CLAUDE.md <<'EOF'
<!-- SECTION: adaptive_planning_config -->
- **Expansion Threshold**: 8.0
<!-- END_SECTION: adaptive_planning_config -->
EOF

cat > /tmp/test_project/subdir/CLAUDE.md <<'EOF'
<!-- SECTION: adaptive_planning_config -->
- **Expansion Threshold**: 5.0
<!-- END_SECTION: adaptive_planning_config -->
EOF

cd /tmp/test_project/subdir && get_complexity_thresholds
# Expected: expansion_threshold=5.0 (subdirectory override)

# Test threshold validation
# Set invalid threshold in CLAUDE.md
sed -i 's/Expansion Threshold: 8.0/Expansion Threshold: 99.0/' CLAUDE.md
get_complexity_thresholds
# Expected: Warning logged, default 8.0 used

# Test orchestrate.md threshold integration
/orchestrate "Test feature"
# Verify: Thresholds loaded from CLAUDE.md before complexity evaluation
# Verify: "Using custom complexity thresholds" message displayed
```

### Expected Outcomes

- Threshold extraction utility working with recursive search
- Default thresholds used when CLAUDE.md not found
- Subdirectory overrides work correctly
- Threshold validation prevents invalid values
- orchestrate.md loads and passes thresholds to complexity-estimator
- Configuration documented in CLAUDE.md

---

## Stage 5: Inject Complexity Metadata into Plans

**Objective**: Automatically update plan files with complexity scores and expansion recommendations as inline metadata for transparency and future reference.

**Duration**: 1 hour

### Tasks

- [ ] **Design metadata injection format**
  - Add complexity metadata to each phase header:
    ```markdown
    ### Phase 2: Backend Implementation
    **Complexity**: 8.5/10 (High)
    **Expansion Status**: Recommended
    **Factors**: 15 tasks, 12 files, 3 security risks

    [Existing phase content...]
    ```
  - Add plan-level metadata section:
    ```markdown
    ## Complexity Analysis
    - **Analysis Date**: 2025-10-21
    - **Average Complexity**: 5.8/10
    - **Max Complexity**: 8.5/10 (Phase 2)
    - **Phases Requiring Expansion**: [2]
    - **Threshold Used**: 8.0 (from CLAUDE.md)

    ### Complexity Breakdown
    | Phase | Name | Score | Level | Expansion |
    |-------|------|-------|-------|-----------|
    | 1 | Setup | 3.2 | Medium | No |
    | 2 | Backend | 8.5 | High | Yes |
    | 3 | Frontend | 5.1 | Medium | No |
    ```

- [ ] **Implement metadata injection utility**
  - File: `.claude/lib/inject-complexity-metadata.sh`
  - Function: `inject_complexity_metadata(plan_path, complexity_report)`
  - Algorithm:
    1. Read complexity report YAML
    2. For each phase, find phase header in plan file
    3. Insert complexity metadata after header
    4. Add plan-level summary section after main metadata
    5. Preserve original content (don't modify tasks or descriptions)
    6. Use Edit tool for safe in-place updates

- [ ] **Add metadata update to complexity evaluation phase**
  - In orchestrate.md Phase 2.5:
    1. After complexity-estimator returns report
    2. Before displaying summary to user
    3. Invoke metadata injection utility
    4. Update plan file with complexity scores
    5. Verify update successful (check for "Complexity:" headers)

- [ ] **Handle metadata conflicts**
  - If plan already has complexity metadata (from previous run):
    - Overwrite with new values (update scenario)
    - Preserve expansion history if present
    - Add "Last Updated" timestamp
  - If plan has manual complexity notes:
    - Don't overwrite manual notes
    - Add automated metadata in separate section
    - Log warning: "Manual complexity notes detected, adding automated metadata separately"

- [ ] **Add metadata validation**
  - After injection, verify:
    - All phases have complexity metadata
    - Plan-level summary present
    - Metadata format correct (valid YAML/Markdown)
    - No duplicate metadata sections
  - If validation fails:
    - Rollback changes (restore original plan file)
    - Log error with details
    - Continue workflow without metadata injection

- [ ] **Update plan revision history**
  - Add revision entry to plan metadata:
    ```markdown
    ## Revision History
    - **2025-10-21 14:32**: Complexity analysis added (avg 5.8, max 8.5)
    - **2025-10-21 14:45**: Phase 2 expanded to Level 1 (complexity 8.5)
    ```
  - Track metadata injection as revision event

### Testing

```bash
# Test metadata injection on simple plan
cat > /tmp/test_plan.md <<'EOF'
## Metadata
- **Date**: 2025-10-21

### Phase 1: Setup
- [ ] Install dependencies
EOF

inject_complexity_metadata /tmp/test_plan.md <(cat <<'YAML'
phases:
  - phase_number: 1
    phase_name: "Setup"
    complexity_score: 3.2
    complexity_level: "Medium"
YAML
)

# Verify: Plan now includes "**Complexity**: 3.2/10 (Medium)" after Phase 1 header
grep -A 1 "### Phase 1: Setup" /tmp/test_plan.md

# Test plan-level summary injection
grep -A 5 "## Complexity Analysis" /tmp/test_plan.md
# Expected: Table with complexity breakdown

# Test metadata update (overwrite scenario)
# Run injection twice, verify second run overwrites first
inject_complexity_metadata /tmp/test_plan.md <(echo "...")
inject_complexity_metadata /tmp/test_plan.md <(echo "...")
# Verify: Only one set of complexity metadata, updated timestamp

# Test validation failure recovery
# Corrupt plan file during injection (simulate write error)
# Verify: Rollback works, original content restored

# Test integration with orchestrate.md
/orchestrate "Test feature"
# Verify: After Phase 2.5, plan file includes complexity metadata
# Verify: Phase headers updated with scores
# Verify: Plan-level summary table present
```

### Expected Outcomes

- Metadata injection utility working reliably
- Plan files include complexity scores inline
- Plan-level summary table generated
- Metadata conflicts handled gracefully
- Validation prevents corrupted plan files
- Revision history tracks metadata changes

---

## Error Handling

### Malformed Plan Files

**Scenario**: Plan file missing phase headers, invalid markdown structure

**Detection**:
```bash
# Check for minimum valid structure
phase_count=$(grep -c "^### Phase [0-9]" "$plan_path")
if [[ $phase_count -eq 0 ]]; then
  echo "ERROR: No phase headers found in plan"
fi
```

**Response**:
- Return error report:
  ```yaml
  error:
    type: "malformed_plan"
    message: "Plan file does not contain valid phase headers"
    plan_path: "/path/to/plan.md"
    expected_pattern: "### Phase N: Name"
    found_headers: []
  ```
- Skip complexity analysis
- Continue workflow without expansion
- Log error for debugging

### Missing Metadata

**Scenario**: Plan missing dependency information, task checkboxes, or other expected metadata

**Detection**:
```bash
# Check for checkboxes
task_count=$(grep -c "^- \[ \]" "$plan_path")
if [[ $task_count -eq 0 ]]; then
  echo "WARNING: No task checkboxes found"
fi
```

**Response**:
- Return partial complexity report with warnings:
  ```yaml
  warnings:
    - "No task checkboxes found, task_count = 0"
    - "No dependency metadata found, dependency_depth = 0"
  phases:
    - phase_number: 1
      complexity_score: 2.1  # Based on available factors only
      missing_factors: ["task_count", "dependency_depth"]
  ```
- Calculate complexity using available factors only
- Normalize weights for missing factors
- Proceed with partial analysis

### Invalid Threshold Configuration

**Scenario**: CLAUDE.md contains invalid threshold values (negative, out of range)

**Detection**:
```bash
if [[ $(echo "$expansion_threshold > 15.0" | bc) -eq 1 ]]; then
  echo "ERROR: expansion_threshold $expansion_threshold exceeds maximum 15.0"
fi
```

**Response**:
- Log warning: "Invalid threshold configuration, using defaults"
- Fall back to hardcoded defaults (8.0, 10, 10, 2)
- Display to user: "⚠ Invalid threshold configuration detected, using defaults"
- Continue workflow with default values

### Agent Invocation Failures

**Scenario**: complexity-estimator agent fails (timeout, parsing error, exception)

**Detection**:
- Task tool returns error response
- YAML parsing of agent output fails
- Agent response doesn't match expected structure

**Response**:
- Log error with full details
- Return empty complexity report:
  ```yaml
  error: "complexity_estimator_failed"
  recommendation: "Proceed without expansion"
  ```
- Set `workflow_state.expansion_pending = false`
- Skip Phase 4 (expansion)
- Continue to Phase 5 (implementation) with original plan

### File System Errors

**Scenario**: Permission denied reading plan, disk full writing metadata

**Detection**:
```bash
if [[ ! -r "$plan_path" ]]; then
  echo "ERROR: Cannot read plan file (permission denied)"
fi
```

**Response**:
- Return error with specific file system details
- Skip affected operations (metadata injection, etc.)
- Continue workflow with degraded functionality
- Log error for system administrator review

---

## Performance Considerations

### Analysis Speed

**Target**: <5 seconds for plans up to 50 phases

**Optimization Strategies**:
- Use grep/sed for factor extraction (avoid loading entire file into memory)
- Parse plan file once, extract all factors in single pass
- Cache dependency graph computation (don't recalculate for each phase)
- Parallelize phase analysis if >10 phases (invoke multiple complexity-estimator instances)

### Memory Usage

**Target**: <100 MB memory footprint for analysis

**Optimization Strategies**:
- Stream plan file processing (don't load entire file)
- Use lightweight YAML parsing (avoid heavy libraries)
- Clear temporary data after each phase analysis
- Limit complexity report size (cap at 1000 phases)

### Caching

**Strategy**: Cache complexity reports for unchanged plans

**Implementation**:
- Generate plan hash: `md5sum plan.md`
- Store report in `.claude/data/cache/complexity/`
- Cache key: `{plan_hash}.yaml`
- Cache invalidation: Compare plan modification time vs cache time
- Cache TTL: 24 hours (refresh daily)

---

## Integration Points

### Input Dependencies

- **From Phase 2 (Planning)**: Plan file path
- **From CLAUDE.md**: Complexity threshold configuration
- **From workflow state**: Topic path, artifact paths

### Output Products

- **To Phase 4 (Expansion)**: List of phases to expand
- **To workflow state**: Complexity report, expansion recommendations
- **To plan file**: Injected complexity metadata
- **To user**: Complexity summary display

### Agent Dependencies

- **complexity-estimator**: Core analysis agent (created in Stage 2)
- **expansion-specialist**: Consumes expansion recommendations (Phase 4)
- **spec-updater**: Updates plan metadata cross-references (Phase 7)

---

## Validation Criteria

### Accuracy

- [ ] Complexity scores correlate >0.90 with manual ratings
- [ ] Expansion recommendations match manual assessment 95%+ of time
- [ ] Factor extraction accuracy >99% (verified against known plans)

### Reliability

- [ ] Error handling covers all identified failure modes
- [ ] No crashes or hangs on malformed plans
- [ ] Graceful degradation when metadata missing

### Performance

- [ ] Analysis completes <5 seconds for 50-phase plans
- [ ] Memory usage <100 MB during analysis
- [ ] Cache hit rate >80% for unchanged plans

### Usability

- [ ] Complexity summary readable and informative
- [ ] Metadata injection doesn't break plan structure
- [ ] Threshold configuration easy to understand and modify

---

## Notes

### Formula Tuning Process

After initial deployment, monitor complexity-estimator accuracy:

1. **Collect feedback**: Track expansion recommendations vs actual expansion needs
2. **Calculate correlation**: Compare algorithm scores vs developer judgment
3. **Identify outliers**: Find plans where algorithm significantly disagrees with humans
4. **Analyze patterns**: Look for common characteristics in outlier plans
5. **Adjust weights**: Modify formula coefficients based on patterns
6. **Re-validate**: Test updated formula against validation dataset
7. **Deploy update**: Update complexity-estimator with new weights

**Target iteration cycle**: 2-4 weeks for initial tuning, quarterly reviews thereafter

### Integration with Expansion Phase

Complexity evaluation (Phase 3) feeds directly into expansion (Phase 4):

```
Phase 3 Output:
  phases_to_expand: [2, 4]

Phase 4 Input:
  for phase in phases_to_expand:
    invoke expansion-specialist(plan_path, phase_number)
```

The expansion-specialist uses complexity scores to determine how to structure expanded phases (number of stages, level of detail, etc.).

### Threshold Customization Examples

**Research-Heavy Project** (detailed documentation preferred):
```markdown
- **Expansion Threshold**: 5.0  # More aggressive
- **Task Count Threshold**: 7
```

**Simple Web App** (larger inline phases acceptable):
```markdown
- **Expansion Threshold**: 10.0  # More conservative
- **Task Count Threshold**: 15
```

**Mission-Critical System** (maximum organization):
```markdown
- **Expansion Threshold**: 3.0  # Very aggressive
- **Task Count Threshold**: 5
```

### Future Enhancements

- **Machine learning tuning**: Train weights on historical plan data
- **Project-type detection**: Automatically adjust thresholds based on project characteristics
- **Real-time feedback**: Update complexity scores as plan is implemented
- **Complexity visualization**: Generate graphs showing complexity distribution
