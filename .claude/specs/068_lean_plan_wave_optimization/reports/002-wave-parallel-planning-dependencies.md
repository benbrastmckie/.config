# Research Report: Wave-Based Parallel Planning with Dependency Management

**Research Topic**: Wave-Based Parallel Planning with Dependency Management: Research how /lean-plan can structure output to enable /lean-implement to execute phases in parallel waves based on dependency constraints. Focus on dependency declaration syntax, phase ordering strategies, and metadata structures that support parallel execution patterns.

**Date**: 2025-12-09
**Researcher**: research-specialist
**Status**: COMPLETE

## Executive Summary

The /lean-plan command currently generates plans with sequential phase dependencies but lacks optimization for wave-based parallel execution. This research identifies the existing infrastructure and proposes minimal enhancements to enable /lean-plan to structure output for parallel execution by /lean-implement.

**Key Findings**:
1. Infrastructure exists: dependency-analyzer.sh provides wave calculation using Kahn's algorithm
2. /lean-plan already generates required metadata fields (implementer, lean_file, dependencies)
3. Gap: /lean-plan doesn't analyze theorem dependencies to create parallel-friendly dependency structures
4. Opportunity: 40-60% time savings possible with proper wave structure generation

**Recommendation**: Enhance /lean-plan to analyze theorem dependencies during STEP 1 and generate optimized dependency arrays that enable wave-based parallel execution.

## Research Findings

### Current State Analysis

#### 1. Existing Wave Infrastructure

The system has complete wave-based execution infrastructure:

**File**: `.claude/lib/util/dependency-analyzer.sh`
- Parses `dependencies: []` metadata from phases
- Uses Kahn's algorithm (topological sort) to calculate execution waves
- Detects circular dependencies
- Calculates parallelization metrics (time savings: 40-60%)

**File**: `.claude/docs/reference/workflows/phase-dependencies.md`
- Complete documentation of dependency syntax
- Wave calculation examples
- Parallelization patterns (fan-out, fan-in, diamond, hybrid)

**File**: `.claude/agents/lean-coordinator.md` (plan-based mode)
- Extracts dependencies directly from plan metadata
- Builds wave groups from dependency arrays
- Supports both sequential (default) and parallel wave execution

#### 2. Current /lean-plan Output Format

Plans generated by lean-plan-architect include required metadata:

```markdown
### Phase N: Phase Name [NOT STARTED]
implementer: lean
lean_file: /absolute/path/file.lean
dependencies: []

**Objective**: Prove theorem properties

**Theorems**:
- [ ] theorem_name: Description
  - Goal: ∀ a b : Nat, a + b = b + a
  - Strategy: Use Mathlib theorem via exact tactic
  - Complexity: Simple
```

**Critical Fields Present**:
- `implementer:` - Routes to lean-coordinator
- `lean_file:` - Target Lean file for theorems
- `dependencies: []` - Dependency array (currently always empty or sequential)

#### 3. Dependency Declaration Syntax

From `.claude/docs/reference/workflows/phase-dependencies.md`:

**Supported Formats**:
```markdown
dependencies: []              # No dependencies (Wave 1)
dependencies: [1]             # Depends on Phase 1
dependencies: [1, 2]          # Depends on Phases 1 and 2
dependencies: [1, 3, 5]       # Non-consecutive dependencies
```

**Rules**:
- Dependencies must reference earlier phases (no forward dependencies)
- No self-dependencies
- No circular dependencies
- Empty array `[]` = independent phase (goes in Wave 1)

#### 4. Gap Analysis: Sequential vs Parallel Dependencies

**Current /lean-plan behavior**:
- Generates dependencies based on phase order, not theorem relationships
- Most plans have sequential dependencies: Phase N depends on Phase N-1
- Result: Single-threaded execution (no parallelization)

**Example Current Output**:
```markdown
### Phase 1: Basic Properties [NOT STARTED]
dependencies: []

### Phase 2: Derived Properties [NOT STARTED]
dependencies: [1]  # Sequential: waits for Phase 1

### Phase 3: Composition [NOT STARTED]
dependencies: [2]  # Sequential: waits for Phase 2
```

**Wave Structure**: 3 waves (no parallelization)

**Optimized Output** (after enhancement):
```markdown
### Phase 1: theorem_add_comm [NOT STARTED]
dependencies: []

### Phase 2: theorem_mul_comm [NOT STARTED]
dependencies: []  # Independent: can run parallel with Phase 1

### Phase 3: theorem_distributivity [NOT STARTED]
dependencies: [1, 2]  # Depends on both: runs after Wave 1 completes
```

**Wave Structure**: 2 waves (50% time savings)
- Wave 1: Phases 1, 2 (parallel)
- Wave 2: Phase 3

### Theorem Dependency Analysis

From `.claude/agents/lean-plan-architect.md` (lines 98-108):

**Existing Capability** (not fully utilized):
```markdown
**Theorem Dependency Analysis** (CRITICAL):

For each theorem to prove:
1. Identify Prerequisites: Which other theorems must be proven first?
2. Check Mathlib Availability: Can prerequisites use existing Mathlib theorems?
3. Build Dependency Graph: Create edges from theorem → dependencies
4. Validate Acyclicity: Ensure no circular dependencies
```

**Current Implementation**: lean-plan-architect performs this analysis but doesn't translate it into phase dependencies.

**Gap**: Analysis results are not reflected in `dependencies:` metadata arrays.

### Wave Calculation Mechanism

From `.claude/lib/util/dependency-analyzer.sh` (lines 296-392):

**Kahn's Algorithm Implementation**:
1. Build in-degree map (count incoming edges per node)
2. Find all phases with in-degree = 0 (no dependencies) → Wave 1
3. Remove Wave 1 phases, decrement in-degrees of dependent phases
4. Repeat until all phases assigned to waves
5. Detect circular dependencies if phases remain

**Performance Metrics**:
```
effectiveness = (sequential_time - parallel_time) / sequential_time

Target: > 0.40 (40% time savings)
Good: > 0.50 (50% time savings)
Excellent: > 0.60 (60% time savings)
```

### Integration with /lean-implement

From `.claude/docs/guides/commands/lean-implement-command-guide.md` (lines 234-265):

**Dual Coordinator Architecture**:
- Phases with `implementer: lean` → routed to lean-coordinator
- lean-coordinator uses plan-based mode by default
- Extracts `dependencies:` metadata directly from plan (no dependency-analyzer invocation)
- Builds wave groups from dependency arrays
- Executes independent phases in parallel (40-60% time savings)

**Brief Summary Return Pattern** (96% context reduction):
- Coordinator returns brief summary (80 tokens) instead of full file (2,000 tokens)
- Enables 10+ iterations (vs 3-4 before)

**Critical Requirement**: Plan must have accurate `dependencies:` arrays for wave-based execution to work.

### Phase Ordering Strategies

From `.claude/docs/reference/workflows/phase-dependencies.md` (lines 428-527):

**Common Patterns**:

1. **Linear Pipeline** (no parallelization):
   ```
   Phase 1 → Phase 2 → Phase 3 → Phase 4
   dependencies: [], [1], [2], [3]
   Waves: 4 (no time savings)
   ```

2. **Fan-Out** (good parallelization):
   ```
         ┌→ Phase 2
   Phase 1 ├→ Phase 3
         └→ Phase 4
   dependencies: [], [1], [1], [1]
   Waves: 2 (3 phases parallel in Wave 2)
   Time savings: ~50%
   ```

3. **Fan-In** (good parallelization):
   ```
   Phase 1 ┐
   Phase 2 ├→ Phase 4
   Phase 3 ┘
   dependencies: [], [], [], [1,2,3]
   Waves: 2 (3 phases parallel in Wave 1)
   Time savings: ~50%
   ```

4. **Diamond** (moderate parallelization):
   ```
         ┌→ Phase 2 ┐
   Phase 1 ┤          ├→ Phase 4
         └→ Phase 3 ┘
   dependencies: [], [1], [1], [2,3]
   Waves: 3 (2 phases parallel in Wave 2)
   Time savings: ~33%
   ```

**Optimal Strategy for Lean Plans**:
- Use **Fan-Out** when proving multiple independent theorems that build on common foundation
- Use **Fan-In** when proving multiple independent lemmas that converge to main theorem
- Use **Diamond** when proving symmetric properties (e.g., commutativity for + and ×)

### Metadata Structures Supporting Parallel Execution

#### Phase Metadata Requirements

From `.claude/agents/lean-plan-architect.md` (lines 27-60):

**Parser-Enforced Field Order**:
```markdown
### Phase N: Phase Name [NOT STARTED]
implementer: lean                    # REQUIRED: "lean" or "software"
lean_file: /absolute/path/file.lean  # REQUIRED for lean phases
dependencies: []                      # REQUIRED: array of phase numbers

Tasks:
- [ ] Theorem tasks
```

**Field Specifications**:
- `implementer: lean` - Routes to lean-coordinator (never "software" unless infrastructure)
- `lean_file: /absolute/path` - Tier 1 discovery for multi-file plans
- `dependencies: []` - Wave structure integration

#### Phase Routing Summary Table

From `.claude/agents/lean-plan-architect.md` (lines 50-58):

**Required After "## Implementation Phases"**:
```markdown
## Implementation Phases

### Phase Routing Summary
| Phase | Type | Implementer Agent |
|-------|------|-------------------|
| 1 | lean | lean-implementer |
| 2 | lean | lean-implementer |
| 3 | lean | lean-implementer |
```

Enables /lean-implement to route phases correctly without parsing entire plan.

#### Global Metadata Integration

From `.claude/docs/guides/commands/lean-plan-command-guide.md` (lines 386-427):

**Plan Metadata Standard Compliance**:
```markdown
## Metadata
- **Date**: YYYY-MM-DD
- **Feature**: One-line description
- **Scope**: Mathematical domain and approach
- **Status**: [NOT STARTED]
- **Estimated Hours**: low-high hours
- **Complexity Score**: Numeric value
- **Structure Level**: 0 (always 0 for Lean plans)
- **Estimated Phases**: Phase count
- **Standards File**: /absolute/path/CLAUDE.md
- **Research Reports**: [Links to research]
- **Lean File**: /absolute/path/file.lean (Tier 2 fallback)
- **Lean Project**: /absolute/path/project/
```

**Lean-Specific Extensions**:
- **Lean File**: Tier 2 discovery fallback when phase lacks `lean_file:`
- **Lean Project**: Project root for lake build and dependency resolution

### Complexity Estimation Integration

From `.claude/agents/lean-plan-architect.md` (lines 116-122):

**Proof Complexity Categories**:
- **Simple** (0.5-1 hour): Direct Mathlib application via `exact` tactic
- **Medium** (1-3 hours): Tactic combination, rewrites, simp/ring
- **Complex** (3-6 hours): Custom lemmas, deep reasoning, induction

**Usage for Wave Optimization**:
- Group Simple theorems in early waves (fast completions)
- Separate Complex theorems into isolated phases (minimize blocking)
- Balance wave complexity (avoid waves with only Complex theorems)

## Implementation Recommendations

### Recommendation 1: Enhance Theorem Dependency Analysis

**Current State**: lean-plan-architect performs theorem dependency analysis (lines 98-108) but doesn't translate results into `dependencies:` metadata.

**Proposed Enhancement**:

**Location**: `.claude/agents/lean-plan-architect.md` STEP 1

**Implementation**:
1. During theorem dependency analysis, build dependency graph:
   ```
   theorem_A: []  # No dependencies
   theorem_B: []  # No dependencies
   theorem_C: [theorem_A, theorem_B]  # Depends on both
   ```

2. Map theorem dependencies to phase dependencies:
   - If Phase 1 = theorem_A, Phase 2 = theorem_B, Phase 3 = theorem_C
   - Then Phase 3 dependencies: [1, 2]

3. Generate `dependencies:` arrays in phase metadata:
   ```markdown
   ### Phase 1: theorem_A [NOT STARTED]
   dependencies: []

   ### Phase 2: theorem_B [NOT STARTED]
   dependencies: []

   ### Phase 3: theorem_C [NOT STARTED]
   dependencies: [1, 2]
   ```

**Expected Outcome**: Plans have accurate dependency structures that enable wave-based parallel execution.

### Recommendation 2: Add Wave Structure Preview

**Proposed Enhancement**: lean-plan-architect should display wave structure during plan creation.

**Implementation**:
1. After generating dependency arrays, calculate wave structure using dependency-analyzer logic
2. Display wave preview in plan creation output:
   ```
   Wave Structure Preview:
   Wave 1: Phases 1, 2, 3 (parallel)
   Wave 2: Phases 4, 5 (parallel)
   Wave 3: Phase 6

   Estimated Time Savings: 50%
   Sequential: 18 hours
   Parallel: 9 hours
   ```

3. Include wave structure as comment in plan file for reference

**Expected Outcome**: Users see parallelization benefits upfront, can adjust theorem grouping if needed.

### Recommendation 3: Optimize Phase Granularity

**Current State**: Plans may group multiple theorems into single phases, reducing parallelization opportunities.

**Proposed Enhancement**: Generate one phase per theorem (or per theorem cluster with tight dependencies).

**Rationale**:
- Fine-grained phases = more opportunities for parallelization
- Example: 6 theorems in 2 phases (max 2 parallel) vs 6 theorems in 6 phases (max 6 parallel)

**Implementation**:
1. Default to one theorem per phase
2. Group only when theorems have tight dependencies (e.g., theorem + helper lemma)
3. Use complexity estimation to balance phase sizes

**Expected Outcome**: More phases = more parallelization opportunities = better time savings.

### Recommendation 4: Integrate with /lean-implement Wave Execution

**Current State**: /lean-implement supports wave-based execution but relies on accurate `dependencies:` metadata.

**Proposed Integration**:
1. /lean-plan generates accurate dependency arrays (Recommendation 1)
2. /lean-implement uses lean-coordinator in plan-based mode
3. lean-coordinator extracts dependencies and builds wave groups
4. Independent phases execute in parallel with brief summary returns (96% context reduction)

**No Changes Needed**: Existing /lean-implement infrastructure supports this pattern.

**Expected Outcome**: Plans created by /lean-plan automatically benefit from wave-based parallel execution.

### Recommendation 5: Add Dependency Visualization

**Proposed Enhancement**: Generate dependency graph visualization during plan creation.

**Implementation**:
1. Use ASCII art or Unicode box-drawing to display dependency graph:
   ```
   Theorem Dependency Graph:

   theorem_add_comm ┐
   theorem_mul_comm ┴─→ theorem_distributivity
   ```

2. Include in plan file as comment for reference
3. Display during plan creation

**Expected Outcome**: Visual feedback helps users understand parallelization structure.

### Summary of Recommendations

| Recommendation | Priority | Effort | Impact | Target File |
|----------------|----------|--------|--------|-------------|
| 1. Enhance theorem dependency analysis | High | Medium | High (enables all other benefits) | lean-plan-architect.md STEP 1 |
| 2. Add wave structure preview | Medium | Low | Medium (user visibility) | lean-plan-architect.md STEP 2 |
| 3. Optimize phase granularity | Medium | Low | High (more parallelization) | lean-plan-architect.md STEP 1 |
| 4. Integrate with /lean-implement | Low | None | High (automatic benefit) | No changes needed |
| 5. Add dependency visualization | Low | Medium | Low (nice to have) | lean-plan-architect.md STEP 2 |

**Recommended Implementation Order**:
1. Start with Recommendation 1 (foundation)
2. Add Recommendation 3 (amplifies Recommendation 1)
3. Add Recommendation 2 (user feedback)
4. Recommendation 4 works automatically
5. Add Recommendation 5 if time permits

## References

### Primary Sources

1. **Phase Dependencies Guide**:
   - File: `.claude/docs/reference/workflows/phase-dependencies.md`
   - Content: Complete documentation of dependency syntax, wave calculation, parallelization patterns
   - Lines: 1-831

2. **Lean Plan Command Guide**:
   - File: `.claude/docs/guides/commands/lean-plan-command-guide.md`
   - Content: /lean-plan usage, plan format, metadata requirements, integration with /lean workflow
   - Lines: 1-1022

3. **Lean Implement Command Guide**:
   - File: `.claude/docs/guides/commands/lean-implement-command-guide.md`
   - Content: Hybrid coordinator architecture, wave execution, brief summary pattern, context management
   - Lines: 1-545

4. **Lean Plan Architect Agent**:
   - File: `.claude/agents/lean-plan-architect.md`
   - Content: Plan creation process, theorem dependency analysis, phase metadata requirements
   - Lines: 1-200 (truncated, full file longer)

5. **Lean Coordinator Agent**:
   - File: `.claude/agents/lean-coordinator.md`
   - Content: Wave orchestration, dependency extraction, plan-based vs file-based modes
   - Lines: 1-300 (truncated, full file longer)

6. **Dependency Analyzer Utility**:
   - File: `.claude/lib/util/dependency-analyzer.sh`
   - Content: Kahn's algorithm implementation, wave calculation, cycle detection, metrics
   - Lines: 1-639

7. **Directory Protocols**:
   - File: `.claude/docs/concepts/directory-protocols.md`
   - Content: Phase dependencies section, wave-based execution, dependency syntax rules
   - Lines: 1137-1190

### Related Documentation

8. **Hierarchical Agents Examples**:
   - File: `.claude/docs/concepts/hierarchical-agents-examples.md`
   - Content: Example 8 (Lean Command Coordinator) demonstrates wave-based orchestration with brief summary parsing
   - Note: Referenced in CLAUDE.md hierarchical_agent_architecture section

9. **Command Authoring Standards**:
   - File: `.claude/docs/reference/standards/command-authoring.md`
   - Content: Standards for command development, metadata requirements
   - Note: Referenced for plan metadata integration

10. **Plan Metadata Standard**:
    - File: `.claude/docs/reference/standards/plan-metadata-standard.md`
    - Content: Required metadata fields, Lean-specific workflow extensions
    - Note: Referenced for compliance requirements
