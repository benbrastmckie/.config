# /build Errors Repair Implementation Plan

## Metadata
- **Date**: 2025-11-29
- **Feature**: /build Command Error Resolution (Logged + Runtime Errors)
- **Scope**: Fix 5% unresolved logged errors + eliminate 3 critical runtime errors bypassing error logging
- **Estimated Phases**: 5
- **Estimated Hours**: 10.5
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Status**: [COMPLETE]
- **Structure Level**: 0
- **Complexity Score**: 58.0
- **Research Reports**:
  - [Build Errors Analysis](/home/benjamin/.config/.claude/specs/966_repair_build_20251129_150219/reports/001_build_errors_analysis.md)
  - [Build Output Runtime Errors Analysis](/home/benjamin/.config/.claude/specs/966_repair_build_20251129_150219/reports/002_build_output_errors_analysis.md)

## Overview

This repair plan addresses both logged errors (from errors.jsonl analysis) and critical runtime errors discovered in build output that are NOT being logged. Analysis revealed two error categories:

**Logged Errors (from errors.jsonl)**:
1. **Missing Library Function** (29% of errors): `save_completed_states_to_state` function undefined
2. **State Machine Violations** (29% of errors): Invalid state transitions and terminal state handling
3. **Insufficient Error Handling** (43% of errors): Non-critical operations treated as errors

**Runtime Errors NOT Being Logged (from build output)**:
1. **Preprocessing Syntax Errors** (exit code 2): `[[ ! ... ]]` syntax escaping to `[[ \! ... ]]` during history expansion preprocessing
2. **SIGPIPE Errors** (exit code 141): Pipe truncation commands (`| head`) without `|| true` suppression
3. **Empty Variable Errors** (exit code 1): Variable expansion in paths without validation (e.g., `cd "$EMPTY_VAR/.claude"`)

The plan addresses all error categories with defensive error handling, preprocessing-safe syntax, proper state machine compliance, enhanced error logging, and comprehensive test coverage.

## Research Summary

**Report 001 (Error Log Analysis)** provides logged error pattern analysis:
- **Pattern 1 (29%)**: Exit code 127 errors indicate `save_completed_states_to_state` function is called but not defined in execution context
- **Pattern 2 (19%)**: Invalid state transitions bypass required intermediate states (implement → complete instead of implement → test → complete)
- **Pattern 3 (38%)**: General bash failures from non-critical operations without fallback handling (test execution, file checks, context estimation)
- **Pattern 4 (5%)**: File parsing errors on empty directories without existence checks
- **Pattern 5-6 (10%)**: Idempotent and terminal state transition edge cases

**Report 002 (Build Output Analysis)** identifies critical runtime errors NOT being logged:
- **Preprocessing Error (exit 2)**: Line 588 uses `[[ ! -d "$SUMMARIES_DIR" ]]` which gets escaped to `[[ \! -d ... ]]` during history expansion preprocessing, causing syntax error BEFORE ERR trap activates
- **SIGPIPE Error (exit 141)**: Multiple `| head` patterns without `|| true` suppression causing SIGPIPE when pipe closes early
- **Empty Variable Error (exit 1)**: Line 1117 uses `cd "$CLAUDE_PROJECT_DIR/.claude"` without validation, expanding to `cd "/.claude"` when variable is empty

**Key Findings**:
- 95% of logged errors already have repair plans
- Runtime errors bypass error logging due to: (1) preprocessing timing, (2) SIGPIPE filtering, (3) inline command trap gaps
- Error logging enhancements needed to capture preprocessing and variable validation failures

**Recommended Approach**: Replace preprocessing-unsafe syntax, add variable validation with error logging, implement SIGPIPE handling, ensure state machine compliance, and add comprehensive test coverage including preprocessing and runtime error scenarios.

## Success Criteria

**Logged Error Resolution**:
- [ ] All /build state transitions follow state machine rules (no invalid transitions)
- [ ] Non-critical operations have defensive error handling with fallback values
- [ ] Test execution failures properly transition to debug state instead of erroring
- [ ] Idempotent state transitions (same-state) handled gracefully
- [ ] Terminal state transitions prevented with clear error messages
- [ ] Error log entries marked RESOLVED for this plan

**Runtime Error Prevention**:
- [ ] No exit code 2 errors from preprocessing-unsafe bash syntax (`[[ ! ... ]]` replaced with `[ ! ... ]`)
- [ ] No exit code 141 errors from SIGPIPE on pipe truncation (`| head` patterns have `|| true`)
- [ ] No exit code 1 errors from empty variable expansion (all variables validated before use in paths)
- [ ] Preprocessing errors that bypass ERR trap are prevented through syntax compliance
- [ ] Variable validation failures are logged to error log before exiting
- [ ] All inline bash commands have defensive checks or trap setup

**Test Coverage**:
- [ ] Test suite covers all 6 logged error patterns from Report 001
- [ ] Test suite covers preprocessing-safe syntax validation
- [ ] Test suite covers empty variable expansion scenarios
- [ ] Test suite covers SIGPIPE handling patterns
- [ ] No new errors introduced (regression prevention)

## Technical Design

### Architecture Overview

The /build command operates as a state machine orchestrator with the following key components:

1. **State Persistence Layer**: Manages workflow state transitions via workflow-state-machine.sh
2. **Phase Execution Engine**: Executes implementation phases from plan files
3. **Test Integration**: Runs test commands and handles failures
4. **Error Logging**: Captures errors to centralized error log via error-handling.sh

### Component Interactions

```
/build command
    ├─> State Machine (workflow-state-machine.sh)
    │   ├─> Validates transitions
    │   ├─> Persists state
    │   └─> Enforces sequential progression
    │
    ├─> Error Handler (error-handling.sh)
    │   ├─> ERR trap captures failures
    │   ├─> Logs to errors.jsonl
    │   └─> Propagates critical errors
    │
    └─> Phase Executor
        ├─> Parses plan files
        ├─> Executes tasks
        ├─> Runs tests
        └─> Handles test failures

```

### Design Decisions

**1. Defensive Error Handling Strategy**
- Classify operations as critical (must succeed) vs non-critical (failure acceptable)
- Use conditional checks before operations likely to fail
- Provide default/fallback values for non-critical failures
- Preserve ERR trap for critical operations only

**2. State Machine Compliance**
- Enforce sequential state progression: initialize → research/implement → test → document → complete
- Never skip test state when transitioning from implement to complete
- Add idempotent transition support for retry/resume scenarios
- Prevent transitions from terminal states (complete, abandoned)

**3. Test Failure Handling**
- Treat test failures as expected workflow conditions (not errors)
- Transition to debug state on test failure
- Preserve test output for debugging context
- Do not propagate test failures as execution errors

**4. Regression Prevention**
- Comprehensive test coverage for all error patterns
- Integration tests verify state machine compliance
- Error log validation confirms fixes resolve logged errors

### File Modifications

**Primary File**: `.claude/commands/build.md`
- Add defensive checks for file operations
- Update state transition logic to follow state machine rules
- Implement test failure handling with debug state transition
- Refine ERR trap scope for non-critical sections

**Secondary Files**:
- `.claude/lib/workflow/workflow-state-machine.sh`: Add idempotent transition handling, terminal state validation
- `.claude/tests/commands/test_build_error_handling.sh`: New comprehensive test suite

## Specific Runtime Error Fixes

Based on Report 002 (Build Output Analysis) and comprehensive build.md audit, the following specific line fixes are required:

**Note**: Build output shows "eval: line 377" errors - this is the line number within the evaluated bash block, not build.md's absolute line numbers. All fixes below use build.md line numbers.

### Fix 0: Line 141 - Double-Bracket String Comparison
**Current**:
```bash
if [[ "$STARTING_PHASE" == "--dry-run" ]]; then
```

**Issue**: Double brackets may cause preprocessing issues in some contexts

**Fix**:
```bash
if [ "$STARTING_PHASE" = "--dry-run" ]; then
```

**Impact**: Consistency with preprocessing-safe standards

---

### Fix 1: Line 588 - Preprocessing-Unsafe Negation Syntax
**Current**:
```bash
if [[ ! -d "$SUMMARIES_DIR" ]]; then
```

**Issue**: History expansion preprocessing escapes `!` to `\!`, causing syntax error (exit code 2)

**Fix**:
```bash
if [ ! -d "$SUMMARIES_DIR" ]; then
```

**Impact**: Eliminates exit code 2 preprocessing errors

---

### Fix 2: Line 609 - SIGPIPE from Pipe Truncation
**Current**:
```bash
LATEST_SUMMARY=$(find "$SUMMARIES_DIR" -name "*.md" -type f -exec ls -t {} + 2>/dev/null | head -1)
if [[ -z "$LATEST_SUMMARY" ]] || [[ ! -f "$LATEST_SUMMARY" ]]; then
```

**Issue**: `head -1` closes pipe early, causing SIGPIPE (exit code 141); also uses double brackets

**Fix**:
```bash
if [ -d "$SUMMARIES_DIR" ] && ls -t "$SUMMARIES_DIR"/*.md >/dev/null 2>&1; then
  LATEST_SUMMARY=$(ls -t "$SUMMARIES_DIR"/*.md 2>/dev/null | head -1 || true)
else
  LATEST_SUMMARY=""
fi

if [ -z "$LATEST_SUMMARY" ] || [ ! -f "$LATEST_SUMMARY" ]; then
```

**Impact**: Eliminates exit code 141 SIGPIPE errors, adds defensive check with fallback

---

### Fix 3: Line 1117 - Empty Variable Expansion
**Current**:
```bash
cd "$CLAUDE_PROJECT_DIR/.claude" && bash tests/features/commands/test_todo_hard_barrier.sh 2>&1 | head -100
```

**Issue**: When `CLAUDE_PROJECT_DIR` is empty, expands to `cd "/.claude"` (exit code 1)

**Fix**:
```bash
if [ -z "$CLAUDE_PROJECT_DIR" ] || [ ! -d "$CLAUDE_PROJECT_DIR/.claude" ]; then
  log_command_error "state_error" \
    "CLAUDE_PROJECT_DIR not set or invalid for test execution" \
    "$(jq -n --arg dir "${CLAUDE_PROJECT_DIR:-EMPTY}" '{claude_project_dir: $dir, attempted_path: "/.claude"}')"
  echo "ERROR: Cannot execute tests - project directory not detected" >&2
  exit 1
fi

cd "$CLAUDE_PROJECT_DIR/.claude" && bash tests/features/commands/test_todo_hard_barrier.sh 2>&1 | head -100 || true
```

**Impact**: Prevents empty variable expansion errors, logs failure with full context, adds SIGPIPE suppression

---

### Fix 4: Line 718 - Context Estimation Fallback (Already Has Fallback, Enhance)
**Current**:
```bash
CONTEXT_ESTIMATE=$(estimate_context_usage "$COMPLETED_PHASES" "$REMAINING_PHASES" "$HAS_CONTINUATION" 2>/dev/null) || CONTEXT_ESTIMATE=50000
```

**Enhancement**:
```bash
if type -t estimate_context_usage &>/dev/null; then
  CONTEXT_ESTIMATE=$(estimate_context_usage "$COMPLETED_PHASES" "$REMAINING_PHASES" "$HAS_CONTINUATION" 2>/dev/null)
  if [ $? -ne 0 ] || [ -z "$CONTEXT_ESTIMATE" ]; then
    echo "WARNING: Context estimation failed, using fallback value" >&2
    CONTEXT_ESTIMATE=50000
  fi
else
  echo "WARNING: estimate_context_usage function not available, using fallback" >&2
  CONTEXT_ESTIMATE=50000
fi
```

**Impact**: Improved visibility for non-critical operation failures

---

### Fix 5: Line 599 - Double-Bracket Numeric Comparison
**Current**:
```bash
if [[ "$SUMMARY_COUNT" -eq 0 ]]; then
```

**Fix**:
```bash
if [ "$SUMMARY_COUNT" -eq 0 ]; then
```

**Impact**: Consistency with preprocessing-safe standards

---

### Fix 6: Line 620 - Double-Bracket Numeric Comparison
**Current**:
```bash
if [[ "$SUMMARY_SIZE" -lt 100 ]]; then
```

**Fix**:
```bash
if [ "$SUMMARY_SIZE" -lt 100 ]; then
```

**Impact**: Consistency with preprocessing-safe standards

---

### Fix 7: Lines 1151, 1765, 1772 - Double-Bracket File Tests with &&
**Current** (appears at 3 locations):
```bash
if [[ -f "$STATE_FILE" && -s "$STATE_FILE" ]]; then
```

**Issue**: Double brackets with && inside require special handling

**Fix**:
```bash
if [ -f "$STATE_FILE" ] && [ -s "$STATE_FILE" ]; then
```

**Impact**: Eliminates potential preprocessing issues with compound conditionals

---

### Additional Pipe Truncation Fixes
All `| head` patterns need `|| true` suppression:
- Line 147: `PLAN_FILE=$(find ... | head -1)` → add `|| true`
- Line 782: `WORK_REMAINING=$(grep ... | head -1 || echo "")` → already has fallback
- Line 1361: `TEST_OUTPUT_PATH=$(ls ... | head -1 || echo "")` → already has fallback

---

## Implementation Phases

### Phase 1: Replace Preprocessing-Unsafe Bash Syntax and Add Variable Validation [COMPLETE]
dependencies: []

**Objective**: Eliminate exit code 2 preprocessing errors and exit code 1 empty variable errors by replacing unsafe syntax patterns and adding comprehensive variable validation.

**Complexity**: High

**Note on Line Numbers**: Build output errors show "eval: line 377" which refers to the line number WITHIN the bash block being evaluated, not the absolute line in build.md. The actual source locations are documented below using build.md line numbers.

Tasks:
- [x] **Audit and Replace All `[[ ... ]]` Double-Bracket Patterns** (preprocessing-unsafe):
  - Search build.md for all `[[ ... ]]` patterns (8 total instances found)
  - Replace negation patterns with single-bracket equivalents: `if [ ! -d "$DIR" ]; then`
  - Replace comparison patterns with single-bracket equivalents: `if [ "$VAR" = "value" ]; then`
  - **Complete list of patterns to fix**:
    - Line 141: `[[ "$STARTING_PHASE" == "--dry-run" ]]` → `[ "$STARTING_PHASE" = "--dry-run" ]`
    - Line 588: `[[ ! -d "$SUMMARIES_DIR" ]]` → `[ ! -d "$SUMMARIES_DIR" ]`
    - Line 599: `[[ "$SUMMARY_COUNT" -eq 0 ]]` → `[ "$SUMMARY_COUNT" -eq 0 ]`
    - Line 610: `[[ -z "$LATEST_SUMMARY" ]] || [[ ! -f "$LATEST_SUMMARY" ]]` → `[ -z "$LATEST_SUMMARY" ] || [ ! -f "$LATEST_SUMMARY" ]`
    - Line 620: `[[ "$SUMMARY_SIZE" -lt 100 ]]` → `[ "$SUMMARY_SIZE" -lt 100 ]`
    - Line 1151: `[[ -f "$STATE_FILE" && -s "$STATE_FILE" ]]` → `[ -f "$STATE_FILE" ] && [ -s "$STATE_FILE" ]`
    - Line 1765: `[[ -f "$STATE_FILE" && -s "$STATE_FILE" ]]` → `[ -f "$STATE_FILE" ] && [ -s "$STATE_FILE" ]`
    - Line 1772: `[[ -f "$STATE_FILE" && -s "$STATE_FILE" ]]` → `[ -f "$STATE_FILE" ] && [ -s "$STATE_FILE" ]`
  - Verify no double-bracket patterns remain after replacement (`grep -c '\[\[' build.md` should return 0)
- [x] **Add Variable Validation Before All Path Operations**:
  - Identify all variables used in paths: CLAUDE_PROJECT_DIR, SUMMARIES_DIR, PLAN_FILE, etc.
  - Add validation before variable expansion in cd/ls/find commands
  - Specific fix for line 1117: Add validation before `cd "$CLAUDE_PROJECT_DIR/.claude"`
  - Log validation failures to error log with state_error type
- [x] **Add SIGPIPE Suppression to Pipe Commands**:
  - Audit all `| head` and `| tail` patterns in build.md
  - Add `|| true` to prevent exit code 141 errors
  - Specific fixes: lines 147, 609, 782, 1361 (add `|| true` after `head -1`)
- [x] **Implement Defensive Checks for Non-Critical Operations**:
  - File existence checks (summaries directory, latest summary file)
  - Provide default values for optional operations (empty LATEST_SUMMARY if no summaries exist)
  - Update context estimation to use fallback if estimation fails
  - Use positive existence checks with fallback instead of negation checks
- [x] **Add Inline Comment Documentation**:
  - Document which operations are critical vs non-critical
  - Explain why certain patterns use single vs double brackets
  - Note preprocessing-safe syntax requirements

Testing:
```bash
# Verify all double-bracket patterns removed
PATTERN_COUNT=$(grep -c '\[\[' .claude/commands/build.md || echo "0")
if [ "$PATTERN_COUNT" -eq 0 ]; then
  echo "PASS: All 8 double-bracket patterns replaced"
else
  echo "FAIL: $PATTERN_COUNT double-bracket patterns remain"
  grep -n '\[\[' .claude/commands/build.md
fi

# Test preprocessing-safe syntax
bash -c 'set +H; if [ ! -d /nonexistent ]; then echo "PASS"; fi'  # Should pass
bash -c 'set +H; if [[ ! -d /nonexistent ]]; then echo "FAIL"; fi' 2>&1 | grep -q "syntax error" && echo "PASS: Caught unsafe syntax"

# Test variable validation
EMPTY_VAR=""
if [ -z "$EMPTY_VAR" ]; then echo "PASS: Empty var caught"; fi

# Test SIGPIPE suppression
yes | head -1 || true
[ $? -eq 0 ] && echo "PASS: SIGPIPE suppressed"

# Test empty directories
mkdir -p /tmp/test_empty_summaries
SUMMARIES_DIR=/tmp/test_empty_summaries
if [ -d "$SUMMARIES_DIR" ] && ls -t "$SUMMARIES_DIR"/*.md >/dev/null 2>&1; then
  LATEST=$(ls -t "$SUMMARIES_DIR"/*.md | head -1 || true)
else
  LATEST=""
fi
[ -z "$LATEST" ] && echo "PASS: Empty directory handled"
rm -rf /tmp/test_empty_summaries
```

**Expected Duration**: 4 hours

**Success Criteria**:
- No `[[ ... ]]` double-bracket patterns remain in build.md (verify: `grep -c '\[\[' build.md` returns 0)
- All 8 double-bracket patterns replaced with single-bracket equivalents
- All variables validated before use in paths (CLAUDE_PROJECT_DIR, etc.)
- All pipe truncation commands have `|| true` suppression
- Empty directories handled with fallback values instead of errors
- Variable validation failures logged to error log before exit
- No exit code 2 (preprocessing), 141 (SIGPIPE), or 1 (empty var) errors

---

### Phase 2: Enforce Sequential State Transitions and Terminal State Protection [COMPLETE]
dependencies: [1]

**Objective**: Update /build workflow to follow state machine transition rules and prevent invalid transitions from terminal states.

**Complexity**: High

Tasks:
- [x] Review current state transition logic in /build command
- [x] Ensure implement state always transitions to test (never directly to complete)
- [x] Ensure initialize state transitions to research or implement (never directly to test)
- [x] Add validation before state transitions to confirm current state and valid targets
- [x] Implement test-to-document transition on test success
- [x] Implement test-to-debug transition on test failure (not error)
- [x] Add terminal state validation to workflow-state-machine.sh:
  ```bash
  TERMINAL_STATES=("complete" "abandoned")
  if [[ " ${TERMINAL_STATES[@]} " =~ " ${CURRENT_STATE} " ]]; then
    log_error "Cannot transition from terminal state: $CURRENT_STATE"
    return 1
  fi
  ```
- [x] Add idempotent transition handling to workflow-state-machine.sh:
  ```bash
  if [ "$target_state" == "$current_state" ]; then
    echo "Already in target state, no transition needed"
    return 0
  fi
  ```
- [x] Update /build documentation to clarify required state progression
- [x] Remove any code paths that skip test state

Testing:
```bash
# Test sequential state transitions
bash .claude/tests/integration/test_build_state_transitions.sh

# Test terminal state protection
# Attempt transition from complete state - should fail gracefully

# Test idempotent transitions
# Attempt same-state transition - should succeed with early exit
```

**Expected Duration**: 3 hours

**Success Criteria**:
- All state transitions follow valid state machine paths
- Test state is never skipped
- Terminal state transitions prevented
- Idempotent transitions handled gracefully
- No invalid state transition errors logged

---

### Phase 3: Implement Comprehensive Error Handling Tests [COMPLETE]
dependencies: [1, 2]

**Objective**: Create test suite covering all identified error patterns (both logged and runtime) to prevent regression.

**Complexity**: High

Tasks:
- [x] Create test file: `.claude/tests/commands/test_build_error_handling.sh`
- [x] **Add Logged Error Pattern Tests** (from Report 001):
  - Test case for invalid state transition (implement → complete)
  - Test case for invalid state transition (initialize → test)
  - Test case for idempotent transition (test → test)
  - Test case for terminal state transition (complete → test)
  - Test case for file operations on empty directories
  - Test case for test execution failure with proper debug transition
  - Test case for context estimation fallback
  - Test case for summary file grep with no matches
- [x] **Add Runtime Error Pattern Tests** (from Report 002):
  - Test case for preprocessing-safe syntax validation (no `[[ ! ... ]]` patterns)
  - Test case for empty variable expansion prevention (CLAUDE_PROJECT_DIR validation)
  - Test case for SIGPIPE handling (all `| head` patterns have `|| true`)
  - Test case for variable validation error logging
- [x] **Create Unit Tests for Defensive Patterns**:
  - Create `.claude/tests/unit/test_build_defensive_checks.sh`
  - Test preprocessing-safe negation syntax
  - Test variable validation before use
  - Test SIGPIPE handling patterns
  - Test empty directory handling
- [x] **Create Integration Tests for Error Scenarios**:
  - Create `.claude/tests/integration/test_build_error_scenarios.sh`
  - Test empty summaries directory scenario
  - Test empty variable in path scenario
  - Test context estimation fallback scenario
  - Test preprocessing error prevention
- [x] Integrate new test files with existing test suite (update .claude/tests/README.md)
- [x] Add test fixtures for various plan structures and states
- [x] Verify all tests pass after fixes applied

Testing:
```bash
# Run new error handling test suites
bash .claude/tests/commands/test_build_error_handling.sh
bash .claude/tests/unit/test_build_defensive_checks.sh
bash .claude/tests/integration/test_build_error_scenarios.sh

# Run full test suite to ensure no regression
bash .claude/tests/run-all-tests.sh

# Verify test coverage for all error patterns
total_tests=$(grep -c "^test_" .claude/tests/commands/test_build_error_handling.sh)
echo "Total test cases: $total_tests (should be ≥12)"
```

**Expected Duration**: 3 hours

**Success Criteria**:
- Test suite covers all 6 logged error patterns from Report 001
- Test suite covers all 3 runtime error patterns from Report 002
- Unit tests validate defensive check patterns
- Integration tests validate error scenarios end-to-end
- All tests pass after fixes applied
- Test suite integrated with existing test infrastructure
- Test coverage prevents regression of fixes
- Tests can be run in CI/pre-commit hooks
- No false positives or false negatives in test results

---

### Phase 4: Enhance Error Logging for Runtime Errors [COMPLETE]
dependencies: [1]

**Objective**: Improve error logging to capture preprocessing errors and variable validation failures that currently bypass ERR trap.

**Complexity**: Medium

Tasks:
- [x] **Add Pre-Execution Variable Validation with Logging**:
  - Add validation function that logs to error log before exiting
  - Call validation at start of each bash block (before trap setup)
  - Example pattern:
    ```bash
    validate_and_log_variable() {
      local var_name="$1"
      local var_value="${!var_name}"
      if [ -z "$var_value" ]; then
        log_command_error "state_error" \
          "Required variable $var_name is empty or unset" \
          "$(jq -n --arg vname "$var_name" '{variable: $vname}')"
        return 1
      fi
      return 0
    }
    ```
- [x] **Document Preprocessing Error Limitations**:
  - Add inline comments explaining why preprocessing errors can't be trapped
  - Document the solution: use preprocessing-safe syntax to prevent errors
  - Reference build output analysis (Report 002) in documentation
- [x] **Add Error Context for Variable Validation Failures**:
  - Include attempted path in error details
  - Include variable name and expected detection method
  - Log to error log with full context before exit
- [x] **Update Error Handling Documentation**:
  - Document preprocessing-safe syntax requirements
  - Add examples of variable validation with error logging
  - Update error-handling.sh documentation with preprocessing error notes

Testing:
```bash
# Test variable validation logging
source .claude/lib/core/error-handling.sh
ensure_error_log_exists
COMMAND_NAME="/build"
WORKFLOW_ID="test_$(date +%s)"
USER_ARGS="test"

# Simulate empty variable
EMPTY_VAR=""
if [ -z "$EMPTY_VAR" ]; then
  log_command_error "state_error" \
    "EMPTY_VAR is empty" \
    "$(jq -n '{variable: "EMPTY_VAR"}')"
  echo "Variable validation error logged"
fi

# Check error log
/errors --since 1m --type state_error --query
```

**Expected Duration**: 1.5 hours

**Success Criteria**:
- Variable validation failures are logged before exit
- Error log entries include full context (variable name, attempted path)
- Documentation explains preprocessing error limitations
- Error logging covers scenarios that bypass ERR trap
- /repair command can query and analyze variable validation errors

---

### Phase 5: Update Error Log Status and Validation [COMPLETE]
dependencies: [1, 2, 3, 4]

**Objective**: Update error log entries from FIX_PLANNED to RESOLVED and validate that runtime errors are now captured.

**Complexity**: Low

Tasks:
- [x] Verify all fixes are working (tests pass, no new errors generated)
- [x] Update error log entries to RESOLVED status:
  ```bash
  source .claude/lib/core/error-handling.sh
  RESOLVED_COUNT=$(mark_errors_resolved_for_plan "/home/benjamin/.config/.claude/specs/966_repair_build_20251129_150219/plans/001-repair-build-20251129-150219-plan.md")
  echo "Resolved $RESOLVED_COUNT error log entries"
  ```
- [x] Verify no FIX_PLANNED errors remain for this plan
- [x] Run /errors command to confirm resolution status:
  ```bash
  /errors --command /build --status FIX_PLANNED
  # Should return 0 errors with this plan path
  ```
- [x] **Validate Runtime Error Capture**:
  - Simulate empty variable scenario and verify error is logged
  - Check that variable validation errors appear in /errors output
  - Confirm preprocessing errors are prevented (no exit code 2)
- [x] Generate final error report showing before/after comparison
- [x] Document any errors that could not be resolved (if any)

Testing:
```bash
# Verify error log update
bash -c 'source .claude/lib/core/error-handling.sh && \
  PLAN_PATH="/home/benjamin/.config/.claude/specs/966_repair_build_20251129_150219/plans/001-repair-build-20251129-150219-plan.md" && \
  ERROR_COUNT=$(grep -c "\"repair_plan\":\"$PLAN_PATH\"" .claude/data/logs/errors.jsonl) && \
  echo "Found $ERROR_COUNT errors associated with this plan"'

# Run /build command to verify no new errors
/build [test-plan-path]
# Check error log for new entries

# Validate runtime error capture
/errors --command /build --since 1h --summary
# Should show no exit code 2, 141, or unlogged exit code 1 errors
```

**Expected Duration**: 1 hour

**Success Criteria**:
- All error log entries for this plan marked RESOLVED
- No FIX_PLANNED errors remain
- Error report shows successful resolution
- /build command runs without generating new errors
- Runtime errors (variable validation) are properly logged
- /repair --command /build captures all error types
- No preprocessing errors (exit code 2) occur

---

## Testing Strategy

### Unit Testing
- Test individual defensive check patterns in isolation
- Verify state machine transition validation logic
- Test terminal state and idempotent transition handling

### Integration Testing
- Test full /build workflow with various plan structures
- Verify state transitions across complete workflows
- Test error handling in realistic scenarios

### Regression Testing
- Run comprehensive error handling test suite
- Verify all 6 error patterns from analysis are covered
- Ensure previously resolved errors don't reoccur

### Error Log Testing
- Verify error log updates correctly track status
- Confirm RESOLVED status applied to fixed errors
- Validate no new errors introduced by fixes

### Test Coverage Requirements
- All identified error patterns have test cases (6 patterns = ≥6 tests)
- State machine transitions tested (valid, invalid, idempotent, terminal)
- Defensive error handling tested (file operations, context estimation, test failures)

## Documentation Requirements

### Update Documentation
- `.claude/commands/build.md`:
  - Add inline comments documenting critical vs non-critical operations
  - Document preprocessing-safe syntax requirements
  - Explain why single brackets used in specific locations
  - Note variable validation patterns
- `.claude/docs/guides/commands/build-command-guide.md`:
  - Update with state transition requirements
  - Add section on runtime error prevention
  - Document preprocessing error limitations
- `.claude/tests/commands/README.md`:
  - Document new error handling test suite
  - Document unit and integration test files
  - Explain test coverage for both logged and runtime errors
- `.claude/lib/core/error-handling.sh`:
  - Add documentation for preprocessing error limitations
  - Document variable validation with error logging pattern
  - Add examples of pre-execution validation

### Reference Updates
- Update error handling pattern documentation to include /build examples
- Add state machine compliance section to command development guide
- Document defensive error handling patterns for reuse
- Add preprocessing-safe syntax guidelines to code standards
- Document SIGPIPE handling patterns
- Add variable validation before path operations to best practices

### No New Documentation Files
- Do not create new documentation files (follow CLAUDE.md Documentation Policy)
- Update existing documentation only

## Dependencies

### Internal Dependencies
- `.claude/lib/core/error-handling.sh`: Error logging and error log update functions
- `.claude/lib/workflow/workflow-state-machine.sh`: State transition validation and enforcement
- `.claude/lib/core/state-persistence.sh`: State file management

### External Dependencies
- Bash 4.0+ (for associative arrays in state machine)
- jq (for error log JSON processing)

### Prerequisite Work
- Error analysis report completed (provided)
- Error log contains tagged errors with FIX_PLANNED status
- Existing repair plans for 95% of errors completed

### Validation Dependencies
- Test framework for error handling test suite
- /errors command for error log querying
- /build command test fixtures

## Risk Management

### Risk: Regression of Previously Resolved Errors
- **Mitigation**: Comprehensive test suite covering all error patterns
- **Detection**: Run full test suite before marking complete
- **Rollback**: Git revert if new errors detected

### Risk: Breaking Valid /build Workflows
- **Mitigation**: Test with various plan structures (simple, medium, complex)
- **Detection**: Integration tests with real-world plans
- **Rollback**: Preserve original logic in comments before changes

### Risk: Incomplete Error Log Updates
- **Mitigation**: Automated error log update script with verification
- **Detection**: Query error log for FIX_PLANNED status after updates
- **Rollback**: Manual error log entry correction if needed

### Risk: State Machine Changes Break Other Commands
- **Mitigation**: State machine changes isolated to validation logic only
- **Detection**: Run tests for other commands using state machine (/implement, /orchestrate)
- **Rollback**: Conditional logic to preserve backward compatibility

## Effort Estimation

**Total Estimated Hours**: 10.5 hours

**Breakdown**:
- Phase 1 (Preprocessing-Safe Syntax + Variable Validation): 4 hours
- Phase 2 (State Transitions): 3 hours
- Phase 3 (Test Coverage - Logged + Runtime Errors): 3 hours
- Phase 4 (Error Logging Enhancements): 1.5 hours
- Phase 5 (Error Log Status + Validation): 1 hour

**Complexity Justification**: Medium-High complexity due to:
- Preprocessing-safe syntax requires comprehensive audit and replacement (build.md ~1400 lines)
- Variable validation must cover all path operations with error logging integration
- State machine logic requires careful validation (3 files modified)
- Test coverage needs comprehensive scenarios for both logged and runtime errors (≥12 test cases across 3 test files)
- Error logging enhancements for scenarios that bypass ERR trap
- Regression risk from 95% already-resolved errors requires thorough testing
- Runtime error prevention critical to /repair workflow effectiveness

**Complexity Score Calculation**:
```
Base (fix) = 3
Tasks (47) = 47/2 = 23.5 → 24
Files (3 primary + 3 test files) = 6*3 = 18
Integrations (5: state machine, error log, test framework, /build, preprocessing layer) = 5*5 = 25
Error Categories (2: logged + runtime) = 2*2 = 4
Total = 3 + 24 + 18 + 25 + 4 = 74
```

**Tier Selection**: Score 74 > 50 → Should be Tier 2 (expanded), but keeping as Tier 1 due to:
- Single primary file modification (build.md)
- Test files are supplementary (not core implementation)
- Error logging enhancements are additive, not architectural changes
- Scope increase addresses gaps in original analysis, not feature expansion

---

## Plan Revision Summary

This plan was revised based on build output analysis (Report 002) to address critical runtime errors that were NOT being logged:

**Key Enhancements**:

1. **Phase 1 Expansion**: Original defensive error handling phase enhanced with:
   - Preprocessing-safe syntax replacement (all `[[ ! ... ]]` → `[ ! ... ]`)
   - Variable validation before path operations (prevents empty variable expansion)
   - SIGPIPE suppression for pipe truncation commands (`|| true`)
   - Increased duration: 2h → 4h

2. **New Phase 4**: Error Logging Enhancements
   - Pre-execution variable validation with error logging
   - Documentation of preprocessing error limitations
   - Error context for validation failures
   - Duration: 1.5h

3. **Phase 3 Expansion**: Test coverage enhanced with:
   - Runtime error pattern tests (preprocessing, SIGPIPE, empty variables)
   - Unit tests for defensive check patterns
   - Integration tests for error scenarios
   - Increased duration: 2h → 3h

4. **Phase 5 Enhancement**: Error log validation expanded with:
   - Runtime error capture validation
   - Preprocessing error prevention verification
   - Duration: 0.5h → 1h

5. **Success Criteria Expansion**:
   - Added runtime error prevention criteria (exit codes 2, 141, 1)
   - Added test coverage criteria for runtime errors
   - Added error logging enhancement criteria

6. **Specific Line Fixes Documented**:
   - Line 588: Preprocessing-unsafe syntax
   - Line 609: SIGPIPE from pipe truncation
   - Line 1117: Empty variable expansion
   - Line 718: Context estimation enhancement
   - Line 147: Additional pipe truncation fix

**Impact**:
- Total phases: 4 → 5
- Total hours: 7.5h → 10.5h
- Complexity score: 46 → 74
- Error categories: Logged only → Logged + Runtime
- Test files: 1 → 3 (commands, unit, integration)

**Critical Improvement**: The revised plan now addresses the root cause of why /repair --command /build was not capturing certain errors: they were bypassing error logging due to preprocessing timing, SIGPIPE filtering, and inline command trap gaps. The enhancements ensure future /repair invocations will capture all /build error categories.

---

## Revision 2: Comprehensive Double-Bracket Pattern Audit (2025-11-29)

Based on build-output-2.md analysis showing "eval: line 377" preprocessing syntax error, a comprehensive audit revealed **8 total double-bracket patterns** in build.md that require replacement (not just the 2 negation patterns originally identified).

**Key Findings from Build Output Analysis**:
1. Error "eval: line 377" refers to line number within the bash eval context, not build.md's absolute line numbers
2. The actual source of the error is at build.md line 588 (`[[ ! -d "$SUMMARIES_DIR" ]]`)
3. Additional 6 double-bracket patterns exist that should be converted for consistency and preprocessing safety

**New Fixes Added**:
- Fix 0: Line 141 - `[[ "$STARTING_PHASE" == "--dry-run" ]]` (string comparison)
- Fix 5: Line 599 - `[[ "$SUMMARY_COUNT" -eq 0 ]]` (numeric comparison)
- Fix 6: Line 620 - `[[ "$SUMMARY_SIZE" -lt 100 ]]` (numeric comparison)
- Fix 7: Lines 1151, 1765, 1772 - `[[ -f "$STATE_FILE" && -s "$STATE_FILE" ]]` (compound file tests)

**Phase 1 Updates**:
- Expanded task list to include all 8 double-bracket patterns with specific line numbers
- Updated success criteria: verify `grep -c '\[\[' build.md` returns 0
- Added comprehensive testing section to verify all patterns removed

**Impact**:
- Patterns to fix: 2 → 8 (6 additional patterns identified)
- Documentation: Added note explaining eval context line numbers vs build.md line numbers
- Validation: Added grep verification command to confirm all patterns replaced

**Test Coverage Added**:
```bash
# Verify all double-bracket patterns removed
PATTERN_COUNT=$(grep -c '\[\[' .claude/commands/build.md || echo "0")
[ "$PATTERN_COUNT" -eq 0 ] && echo "PASS: All 8 patterns replaced"
```
