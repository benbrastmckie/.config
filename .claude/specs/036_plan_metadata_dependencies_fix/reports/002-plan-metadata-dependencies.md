# Plan Metadata Dependencies & Phase Classification

## Research Overview

**Topic**: Research missing plan metadata structure including phase dependencies, phase type classification (lean vs. software), and implement structured metadata standards
**Date**: 2025-12-09
**Context**: Analysis of phase-level metadata requirements and integration with .claude/docs/ standards

## Executive Summary

The Plan Metadata Standard (`.claude/docs/reference/standards/plan-metadata-standard.md`) defines optional phase-level metadata fields for `implementer`, `dependencies`, and `lean_file` that enable mixed Lean/software plan orchestration and wave-based parallelization. These fields are documented but not consistently generated by plan-architect agents (lean-plan-architect, plan-architect). The standard includes validation rules, format specifications, and integration points with `/lean-implement` coordinator routing logic.

**Key Findings**:
1. Phase metadata fields are OPTIONAL (validation only enforces format when present)
2. Three-tier phase classification system (Tier 1: implementer field, Tier 2: lean_file presence, Tier 3: keyword fallback)
3. Dependencies field enables 40-60% time savings via wave-based parallel execution
4. Current lean-plan-architect does not inject these fields into generated plans

## Findings

### Finding 1: Phase-Level Metadata Specification

**Source**: `/home/benjamin/.config/.claude/docs/reference/standards/plan-metadata-standard.md:126-286`

**Defined Fields**:

| Field | Format | Purpose | Required? |
|-------|--------|---------|-----------|
| `implementer` | `lean` or `software` | Explicit phase type for coordinator routing | Optional |
| `dependencies` | `[]` or `[1, 2, 3]` | Phase numbers that must complete before this phase | Optional |
| `lean_file` | `/absolute/path/to/file.lean` | Lean source file for theorem proving phases | Optional |

**Format Example** (from standard:135-145):

```markdown
### Phase N: Phase Name [NOT STARTED]
implementer: lean|software
lean_file: /absolute/path/to/file.lean
dependencies: [1, 2]

Tasks:
- [ ] Task 1
- [ ] Task 2
```

**Key Quote** (line 129-133):

> Phase-level metadata enables explicit orchestration control through unambiguous implementer type declaration, dependency tracking for wave-based parallelization, and Lean file associations for theorem proving phases.

**When to Include** (line 134-138):

> Use phase-level metadata when:
> - Plans contain mixed Lean/software phases requiring different coordinators
> - Phase dependencies enable parallel wave execution
> - Explicit implementer declaration eliminates classification ambiguity

### Finding 2: Three-Tier Phase Classification System

**Source**: plan-metadata-standard.md:165-173

**Classification Tiers** (strongest signal wins):

1. **Tier 1**: `implementer:` field (explicit declaration, no ambiguity)
2. **Tier 2**: `lean_file:` field presence (backward compatibility, implies Lean phase)
3. **Tier 3**: Keyword analysis fallback (weakest, prone to misclassification)

**Usage Notes** (line 168-173):

> - **3-Tier Detection**: Phase classification uses three tiers (strongest signal wins):
>   1. Tier 1: `implementer:` field (strongest - no ambiguity)
>   2. Tier 2: `lean_file:` field presence (backward compatibility)
>   3. Tier 3: Keyword analysis fallback (weakest - prone to misclassification)
> - **Coordinator Routing**: `/lean-implement` routes phases to appropriate coordinators:
>   - `implementer: lean` → `lean-coordinator.md` (theorem proving workflow)
>   - `implementer: software` → `implementer-coordinator.md` (software implementation workflow)

**Misclassification Risk**: Without Tier 1 or Tier 2 signals, keyword analysis can incorrectly classify phases containing words like "lean" in non-technical contexts.

### Finding 3: Dependencies Field for Wave-Based Execution

**Source**: plan-metadata-standard.md:175-196

**Format**: `dependencies: []` or `dependencies: [1, 2, 3]`

**Purpose**: Enable parallel execution of independent phases in waves

**Example** (line 181-189):

```markdown
### Phase 3: Integration Layer [NOT STARTED]
implementer: software
dependencies: [1, 2]

Tasks:
- [ ] Integrate authentication module (depends on Phase 1)
- [ ] Integrate caching layer (depends on Phase 2)
```

**Wave Construction** (line 191-195):

> **Usage Notes**:
> - **Wave Construction**: `/lean-implement` Block 1a builds execution waves from dependency graph
> - **Parallel Execution**: Phases with no mutual dependencies execute in parallel (40-60% time savings)
> - **Dependency Format**: Empty array `[]` indicates no dependencies (can start in Wave 1)

**Performance Impact**: Plans with independent phases can execute 40-60% faster through parallelization compared to sequential execution.

### Finding 4: lean_file Field for Build Integration

**Source**: plan-metadata-standard.md:198-218

**Format**: `lean_file: /absolute/path/to/file.lean`

**Purpose**: Associates phase with specific Lean source file for proof validation and build verification

**Example** (line 204-212):

```markdown
### Phase 2: Decidability Proofs [IN PROGRESS]
implementer: lean
lean_file: /home/user/project/theories/Decidable.lean
dependencies: [1]

Tasks:
- [ ] Prove decidability for equality
- [ ] Prove decidability for ordering
```

**Usage Notes** (line 214-218):

> - **Backward Compatibility**: Presence of `lean_file:` field triggers Tier 2 phase classification (Lean phase)
> - **Build Integration**: `/lean-build` uses `lean_file:` to locate source files for proof building
> - **Multiple Files**: If phase spans multiple files, use primary file path (others referenced in tasks)

**Integration Point**: `/lean-build` command parses `lean_file:` field to determine which Lean files to compile.

### Finding 5: Validation Rules for Phase Metadata

**Source**: plan-metadata-standard.md:267-286

**Validation Approach**: Optional fields only validated when present

**Format Validation** (ERROR-level if malformed):

| Field | Validation Rule | Example Error |
|-------|-----------------|---------------|
| `implementer:` | Must be exactly "lean" or "software" | `implementer: Lean` (case mismatch) |
| `dependencies:` | Valid array: `[]` or `[N, N, N]` with numeric values | `dependencies: [1, 2, "three"]` (non-numeric) |
| `lean_file:` | Absolute path ending with `.lean` | `lean_file: file.lean` (not absolute) |

**Omission Validation** (No errors):

> **Omission Validation** (No errors):
> - Missing phase metadata fields are acceptable (fallback classification applies)
> - Plans without any phase metadata are valid (Tier 3 keyword-based classification used)

**Key Principle**: Validation is PERMISSIVE for omission but STRICT for format when fields are present.

### Finding 6: Real-World Examples of Phase Metadata

**Source**: plan-metadata-standard.md:280-286

**Referenced Plans**:

1. **Spec 028**: Lean Subagent Orchestration
   - Mixed plan with explicit `implementer:` fields
   - Path: `.claude/specs/028_lean_subagent_orchestration/plans/001-lean-subagent-orchestration-plan.md`

2. **Spec 032**: Lean Plan Command
   - Pure Lean plan with `lean_file:` associations
   - Path: `.claude/specs/032_lean_plan_command/plans/001-lean-plan-command-plan.md`

3. **Spec 037**: Lean Metadata Phase Refactor
   - Infrastructure plan with software phases only
   - Path: `.claude/specs/037_lean_metadata_phase_refactor/plans/001-lean-metadata-phase-refactor-plan.md`

**Analysis Needed**: Read these example plans to understand pattern usage in production.

### Finding 7: Integration with standards-extraction.sh

**Source**: plan-metadata-standard.md:422-433

**Integration Point**: The `format_standards_for_prompt()` function should inject phase metadata standards into planning agent context

**Implementation** (line 426-433):

```bash
source "${CLAUDE_LIB}/plan/standards-extraction.sh"
FORMATTED_STANDARDS=$(format_standards_for_prompt)

# Agent receives standards in prompt:
# **Project Standards**:
# ${FORMATTED_STANDARDS}
```

**Required Action** (line 434):

> **Implementation**: Add `plan_metadata_standard` to extracted sections array in standards-extraction.sh (~line 150-160).

**Current Status**: Unknown if standards-extraction.sh includes phase metadata section. Verification needed.

### Finding 8: Generated Plan Missing Phase Metadata

**Evidence**: Plan at `/home/benjamin/Documents/Philosophy/Projects/ProofChecker/.claude/specs/053_p6_perpetuity_theorem_derive/plans/001-p6-perpetuity-theorem-derive-plan.md`

**Observations**:

1. **Phase 1 (lines 26-59)**: Has tasks but missing all three metadata fields
2. **Phase 2 (lines 63-98)**: Has tasks but missing all three metadata fields
3. **Phase 3 (lines 100-135)**: Has tasks but missing all three metadata fields

**Impact**:
- `/lean-implement` will use Tier 3 classification (keyword fallback)
- No wave-based parallelization (sequential execution only)
- No explicit Lean file association (requires detection)

**Root Cause Hypothesis**: lean-plan-architect agent either:
- Not receiving phase metadata standard in context
- Not applying standard to generated output
- Bypassed entirely due to workflow error (Finding 1 from Report 001)

## Recommendations

### Recommendation 1: Verify standards-extraction.sh Includes Phase Metadata

**Action**: Read `/home/benjamin/.config/.claude/lib/plan/standards-extraction.sh`

**Check**: Look for `plan_metadata_standard` in extracted sections array

**Expected Location**: Around line 150-160 per plan-metadata-standard.md:434

**If Missing**: Add phase metadata standard to extraction array

**Validation**: After fix, verify `format_standards_for_prompt()` output includes phase metadata section

### Recommendation 2: Audit lean-plan-architect Agent Guidelines

**Action**: Read `/home/benjamin/.config/.claude/agents/lean-plan-architect.md`

**Check**:
1. Does agent behavioral guidelines include phase metadata template?
2. Does agent invoke `format_standards_for_prompt()` for context?
3. Does agent include example phase with all three fields?

**Expected Pattern**: Agent should receive formatted standards via context injection from /lean-plan command

**If Missing**: Add explicit phase metadata generation instructions to agent guidelines

### Recommendation 3: Add Phase Metadata to lean-plan-architect Output Template

**Location**: lean-plan-architect.md (behavioral guidelines)

**Template Addition**:

```markdown
### Phase N: Phase Name [NOT STARTED]
implementer: lean
lean_file: /absolute/path/to/file.lean
dependencies: []

**Goal**: [Phase objective]

**Files Modified**:
- [File list]

**Tasks**:
- [ ] Task 1
- [ ] Task 2
```

**Instruction**: Add to STEP 3 (Plan Generation) of lean-plan-architect behavioral guidelines

**Validation**: Generated plans should include phase metadata fields automatically

### Recommendation 4: Test Phase Metadata Validation

**Tool**: `.claude/scripts/lint/validate-plan-metadata.sh` (mentioned in plan-metadata-standard.md:449-457)

**Test Cases**:

1. **Valid metadata**: All three fields with correct format
2. **Invalid implementer**: `implementer: Lean` (case mismatch)
3. **Invalid dependencies**: `dependencies: [1, "two"]` (non-numeric)
4. **Invalid lean_file**: `lean_file: relative/path.lean` (not absolute)
5. **Missing metadata**: No phase fields (should pass - optional)

**Expected Results**:
- Cases 2-4: ERROR-level validation failure
- Cases 1, 5: Validation passes

**Action**: Run validator against test plans with each case

### Recommendation 5: Document Phase Metadata in /lean-implement Guide

**Location**: `.claude/docs/guides/commands/lean-implement-command-guide.md`

**Content Additions**:

1. **Section**: "Phase Classification System" documenting three tiers
2. **Section**: "Wave-Based Execution" explaining dependencies field
3. **Example**: Complete plan excerpt with all three metadata fields
4. **Troubleshooting**: What happens when metadata is missing

**Cross-Reference**: Link to plan-metadata-standard.md for canonical specification

### Recommendation 6: Create Migration Script for Existing Plans

**Purpose**: Add phase metadata to plans created before standard was enforced

**Approach**:

1. **Detection**: Parse plan file to find phases without metadata
2. **Classification**: Use Tier 3 keyword analysis to infer `implementer` type
3. **Dependencies**: Analyze task descriptions for dependency keywords
4. **Lean Files**: Search tasks for file paths ending in `.lean`
5. **Injection**: Insert metadata fields below phase heading

**Script Location**: `.claude/scripts/migration/add-phase-metadata.sh`

**Dry-Run Mode**: Show proposed changes without modifying files

**Validation**: After migration, run validate-plan-metadata.sh on migrated plans

### Recommendation 7: Add Phase Metadata Examples to Documentation

**Locations**:

1. **plan-metadata-standard.md**: Add more complete examples (currently has minimal examples)
2. **lean-implement-command-guide.md**: Add phase routing decision tree
3. **lean-plan-command-guide.md**: Add expected plan output format

**Example Content**:

```markdown
## Phase Metadata Examples

### Pure Lean Plan (All Phases Lean)

```
### Phase 1: Core Theorems [NOT STARTED]
implementer: lean
lean_file: /home/user/project/Core.lean
dependencies: []

### Phase 2: Derived Theorems [NOT STARTED]
implementer: lean
lean_file: /home/user/project/Derived.lean
dependencies: [1]
```

### Mixed Lean/Software Plan

```
### Phase 1: Infrastructure Setup [NOT STARTED]
implementer: software
dependencies: []

### Phase 2: Lean Formalization [NOT STARTED]
implementer: lean
lean_file: /home/user/project/Main.lean
dependencies: [1]
```
```

### Recommendation 8: Test Wave-Based Execution with Dependencies

**Test Plan**:

1. Create test plan with 4 phases:
   - Phase 1: `dependencies: []` (Wave 1)
   - Phase 2: `dependencies: []` (Wave 1, parallel with Phase 1)
   - Phase 3: `dependencies: [1]` (Wave 2, after Phase 1)
   - Phase 4: `dependencies: [1, 2]` (Wave 3, after Phases 1 and 2)

2. Run `/lean-implement` on test plan

3. Verify:
   - Phases 1 and 2 execute in parallel (same wave)
   - Phase 3 waits for Phase 1 completion
   - Phase 4 waits for both Phase 1 and Phase 2 completion
   - Total execution time < sequential execution time

4. Measure time savings: Compare parallel vs sequential execution

**Success Criteria**: 40-60% time reduction for test plan with parallelizable phases

## Validation Checklist

After implementing recommendations:

- [ ] standards-extraction.sh includes plan_metadata_standard section
- [ ] format_standards_for_prompt() output includes phase metadata
- [ ] lean-plan-architect behavioral guidelines include phase metadata template
- [ ] Generated Lean plans include implementer, dependencies, lean_file fields
- [ ] validate-plan-metadata.sh correctly validates phase metadata format
- [ ] /lean-implement correctly routes phases based on implementer field
- [ ] Wave-based execution works with dependencies field
- [ ] Documentation includes phase metadata examples and usage guide

## Related Standards

**Primary Reference**: `/home/benjamin/.config/.claude/docs/reference/standards/plan-metadata-standard.md` (lines 126-286)

**Related Standards**:
- [Command Authoring Standards](../reference/standards/command-authoring.md) - Plan metadata injection patterns
- [Lean Implement Command Guide](../guides/commands/lean-implement-command-guide.md) - Phase routing and wave execution
- [Directory Protocols](../concepts/directory-protocols.md) - Plan file organization and structure

## Conclusion

The Plan Metadata Standard defines optional but valuable phase-level metadata fields (implementer, dependencies, lean_file) that enable sophisticated orchestration capabilities. These fields are documented and validated but not consistently generated by lean-plan-architect. The fix requires:

1. **Standards Injection**: Ensure format_standards_for_prompt() includes phase metadata section
2. **Agent Guidelines**: Update lean-plan-architect to generate phase metadata
3. **Documentation**: Add comprehensive examples to command guides
4. **Testing**: Validate wave-based execution with dependency graphs

The standard's permissive validation approach (optional fields, strict format when present) balances backward compatibility with modern orchestration needs.
