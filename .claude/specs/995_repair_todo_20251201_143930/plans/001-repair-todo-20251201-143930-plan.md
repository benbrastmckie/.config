# Implementation Plan: /todo Error Repair

## Metadata
- **Plan ID**: 001-repair-todo-20251201-143930-plan
- **Created**: 2025-12-01T14:39:30Z
- **Revised**: 2025-12-01T15:04:52Z
- **Workflow Type**: repair
- **Complexity**: 2
- **Status**: [COMPLETE]
- **Feature**: /todo errors repair
- **Research Report**: /home/benjamin/.config/.claude/specs/995_repair_todo_20251201_143930/reports/001-todo-errors-repair.md
- **Conformance Analysis**: /home/benjamin/.config/.claude/specs/995_repair_todo_20251201_143930/reports/002-plan-conformance-analysis.md
- **Estimated Effort**: 8-13 hours (revised from 15-20h via infrastructure reuse)
- **Phase Count**: 7 phases

## Overview

This plan addresses errors identified in the /todo command analysis and systemic issues affecting multiple commands. The research analysis revealed:

- **Zero logged errors** for /todo command itself (0/185 total errors)
- **1 runtime error** detected in workflow output (bash syntax error from escaped negation operators)
- **Systemic issues** affecting 72% of all errors across commands (execution_error 45%, state_error 27%)
- **Agent failures** accounting for 16% of errors (topic naming agent output contract violations)

The plan focuses on immediate /todo fixes (Phases 1-2) followed by systemic improvements (Phases 3-5) that will benefit all commands. Implementation leverages existing infrastructure (validation-utils.sh, error-handling.sh helpers) to achieve 35-50% effort reduction while maintaining full standards conformance.

## Success Criteria

- [ ] /todo command bash conditional syntax complies with preprocessing safety standards
- [ ] /todo command logs all errors to errors.jsonl with proper metadata
- [ ] All commands follow three-tier sourcing pattern with fail-fast handlers
- [ ] Topic naming agent output contract enforced using validation-utils.sh library
- [ ] State file validation complements existing variable validation
- [ ] Error logging compliance verified across all commands
- [ ] All tests pass after changes
- [ ] Zero new errors generated during implementation

## Phases

### Phase 1: Fix /todo Bash Conditional Syntax [COMPLETE]

**Priority**: Medium
**Effort**: Low
**Status**: Not Started

**Objective**: Replace escaped negation operators in /todo command conditionals to comply with bash preprocessing safety standards.

**Tasks**:
- [x] Read /todo command file: `.claude/commands/todo.md`
- [x] Identify all escaped negation patterns: `\!` in bash conditionals
- [x] Replace with standard negation syntax: `if [[ ! "$TODO_PATH" =~ ^/ ]]` (remove backslash)
- [x] Run validation: `bash .claude/scripts/validate-all-standards.sh --conditionals`
- [x] Test /todo execution with various arguments to confirm no syntax errors
- [x] Verify fix eliminates the exit code 2 error from workflow output

**Artifacts**:
- Modified: `.claude/commands/todo.md`
- Validation output: bash conditional linter results

**Impact**: Eliminates 1 runtime error; improves standards compliance

---

### Phase 2: Audit /todo Error Logging Coverage [COMPLETE]

**Priority**: Medium
**Effort**: Low
**Status**: Not Started
**Dependencies**: None

**Objective**: Verify /todo follows mandatory error logging pattern per Command Authoring Standards (lines 89-160).

**Tasks**:
- [x] Review `/todo` bash blocks for compliance with existing mandatory pattern:
  - [x] error-handling.sh sourced in block 1 (Tier 1)
  - [x] `ensure_error_log_exists` called immediately after sourcing
  - [x] COMMAND_NAME, WORKFLOW_ID, USER_ARGS set before first error
  - [x] ERR trap configured using `setup_bash_error_trap()` helper
- [x] If violations found, update to use existing error-handling.sh helpers:
  ```bash
  source "$CLAUDE_LIB/core/error-handling.sh" 2>/dev/null || {
    echo "Error: Cannot load error-handling library" >&2
    exit 1
  }
  ensure_error_log_exists
  COMMAND_NAME="/todo"
  WORKFLOW_ID="todo_$(date +%s)"
  USER_ARGS="$*"
  setup_bash_error_trap  # Use existing helper instead of manual trap
  ```
- [x] Test error scenarios and verify errors appear in errors.jsonl:
  - Invalid arguments (e.g., `/todo --invalid-flag`)
  - Missing TODO.md file
  - File permission errors
  - State restoration failures
- [x] Query errors: `/errors --command /todo --since 10m` to verify logging

**Artifacts**:
- Modified: `.claude/commands/todo.md` (if violations found)
- Test results: error logging coverage verification

**Impact**: Ensures /todo compliance with existing mandatory pattern; enables /repair command to detect /todo failures

**References**:
- Command Authoring Standards: Error Logging Integration (lines 89-160)
- error-handling.sh: `setup_bash_error_trap()` function

---

### Phase 3: Enforce Three-Tier Sourcing Pattern Across All Commands [COMPLETE]

**Priority**: High
**Effort**: Medium
**Status**: Not Started
**Dependencies**: None

**Objective**: Systematically audit and fix library sourcing order in all commands to eliminate 72% of systemic errors (execution_error 45%, state_error 27%).

**Tasks**:
- [x] Run sourcing validator to identify violations:
  ```bash
  bash .claude/scripts/validate-all-standards.sh --sourcing > /tmp/sourcing-violations.txt
  ```
- [x] Review violations report and create command remediation list
- [x] For each command with violations, update bash blocks to source in order:
  - **Tier 1** (with fail-fast handlers):
    - `state-persistence.sh`
    - `workflow-state-machine.sh`
    - `error-handling.sh`
  - **Tier 2**: Command-specific libraries
  - **Tier 3**: Helper utilities (validation-utils.sh when using validation functions)
- [x] Add fail-fast handlers for Tier 1 failures:
  ```bash
  source "$CLAUDE_LIB/core/state-persistence.sh" 2>/dev/null || {
    echo "CRITICAL: Cannot load state-persistence library" >&2
    log_command_error "execution_error" "Failed to source state-persistence.sh" "Tier 1 library missing"
    exit 1
  }
  ```
- [x] Add validation-utils.sh sourcing to commands using agent artifact validation:
  ```bash
  # Tier 3: Helper utilities (graceful degradation)
  source "${CLAUDE_PROJECT_DIR}/.claude/lib/workflow/validation-utils.sh" 2>/dev/null || true
  ```
- [x] Priority commands to fix (highest error counts):
  - [x] `/build` (21 execution_error, 21 state_error)
  - [x] `/errors` (10 execution_error)
  - [x] `/plan` (10 execution_error, 4 state_error) + add validation-utils.sh
  - [x] `/revise` (7 execution_error, 6 state_error)
  - [x] `/research` (6 execution_error, 2 state_error) + add validation-utils.sh
  - [x] `/repair` (6 execution_error)
- [x] Re-run validator to verify all violations resolved
- [x] Test affected commands to ensure state persistence functions work

**Artifacts**:
- Modified: Multiple command files (`.claude/commands/*.md`)
- Validation report: sourcing violations before/after comparison

**Impact**: Eliminates 45% of execution_error (83/185) and 27% of state_error (50/185)

**References**:
- Code Standards: Three-Tier Sourcing Pattern (lines 34-87)
- validation-utils.sh: Helper library for agent artifact and workflow validation

---

### Phase 4: Strengthen Topic Naming Agent Output Contract [COMPLETE]

**Priority**: Medium
**Effort**: Low
**Status**: Not Started
**Dependencies**: [Phase 3]

**Objective**: Leverage validation-utils.sh library to enforce hard barrier pattern and eliminate 16% of agent_error failures.

**Tasks**:
- [x] Read current agent implementation: `.claude/agents/topic-naming-agent.md`
- [x] Add mandatory file creation verification to agent completion criteria:
  ```markdown
  **CRITICAL COMPLETION REQUIREMENT**:
  You MUST create the output file at the exact path specified in the contract.
  The orchestrator will verify this file using validate_agent_artifact().

  Verification checks performed:
  1. File exists and is readable
  2. File has minimum content (10+ bytes)
  3. Content matches expected format: single line, no whitespace padding
  ```
- [x] Update calling commands (/plan, /research) to use validation-utils.sh library:
  ```bash
  # After topic naming agent invocation (assumes validation-utils.sh sourced in Phase 3)
  validate_agent_artifact "$TOPIC_NAME_FILE" 10 "topic name" || {
    echo "ERROR: Topic naming agent failed validation" >&2
    # Retry logic or fallback to manual naming
  }
  ```
- [x] Implement retry logic in /plan and /research (2 retries, 5 second delay):
  ```bash
  MAX_RETRIES=2
  RETRY_DELAY=5
  for attempt in $(seq 1 $MAX_RETRIES); do
    # Invoke topic naming agent
    if validate_agent_artifact "$TOPIC_NAME_FILE" 10 "topic name"; then
      break
    fi
    echo "Retry $attempt/$MAX_RETRIES for topic naming agent..." >&2
    sleep $RETRY_DELAY
  done
  ```
- [x] Test agent failure scenarios:
  - Agent fails to create output file
  - Agent creates empty file
  - Agent returns malformed topic name
- [x] Verify retry logic works and errors are logged appropriately via validate_agent_artifact()

**Artifacts**:
- Modified: `.claude/agents/topic-naming-agent.md`
- Modified: `.claude/commands/plan.md`
- Modified: `.claude/commands/research.md`
- Test results: agent failure handling verification

**Impact**: Eliminates 16% of agent_error (29/185); improves workflow reliability; leverages existing validation infrastructure

**References**:
- validation-utils.sh: `validate_agent_artifact()` function (lines 108-189)
- Code Standards: Three-Tier Sourcing (validation-utils.sh as Tier 3)

---

### Phase 5: Add State File Validation Checkpoints [COMPLETE]

**Priority**: High
**Effort**: Low
**Status**: Not Started
**Dependencies**: [Phase 3]

**Objective**: Complement existing variable validation with file-level integrity checks to reduce "State restoration incomplete" errors.

**Tasks**:
- [x] Read current implementations:
  - `.claude/lib/core/state-persistence.sh` (file operations)
  - `.claude/lib/core/error-handling.sh` (validate_state_restoration function)
- [x] Add file-level validation to state-persistence.sh (complements existing variable validation):
  ```bash
  # Validate state file integrity before restoration (FILE-LEVEL only)
  # Variable validation handled by validate_state_restoration() in error-handling.sh
  # Args: $1 = state file path
  # Returns: 0 if valid, 1 if invalid
  validate_state_file() {
    local state_file="$1"

    # File exists and is readable
    [[ -f "$state_file" ]] || {
      echo "State file does not exist: $state_file" >&2
      return 1
    }
    [[ -r "$state_file" ]] || {
      echo "State file not readable: $state_file" >&2
      return 1
    }

    # File has minimum content (not empty or truncated)
    local file_size
    file_size=$(wc -c < "$state_file")
    [[ "$file_size" -gt 50 ]] || {
      echo "State file too small (possible corruption): $file_size bytes" >&2
      return 1
    }

    return 0
  }
  ```
- [x] Update `load_workflow_state` to use two-phase validation:
  ```bash
  load_workflow_state() {
    local state_file="$STATE_FILE"

    # Phase 1: FILE validation (before attempting to source)
    if ! validate_state_file "$state_file"; then
      log_command_error "state_error" "State file validation failed" "File: $state_file"
      echo "Attempting state file recovery..." >&2
      # Recovery logic: recreate with minimal metadata
      echo "WORKFLOW_ID=recovered_$(date +%s)" > "$state_file"
      echo "COMMAND_NAME=$COMMAND_NAME" >> "$state_file"
      return 1
    fi

    # Proceed with normal restoration
    # ...existing code...

    # Phase 2: VARIABLE validation (after sourcing, uses existing function)
    # Commands should call: validate_state_restoration "WORKFLOW_ID" "COMMAND_NAME" || exit 1
  }
  ```
- [x] Update all commands to use two-phase validation pattern:
  ```bash
  # After load_workflow_state
  validate_state_restoration "WORKFLOW_ID" "COMMAND_NAME" || {
    echo "ERROR: State restoration failed" >&2
    exit 1
  }
  ```
- [x] Test state file corruption scenarios:
  - Empty state file (caught by file validation)
  - Truncated state file (caught by file validation)
  - Missing required variables (caught by existing validate_state_restoration)
  - Non-existent state file (caught by file validation)
- [x] Verify validation prevents restoration errors and logs appropriately

**Artifacts**:
- Modified: `.claude/lib/core/state-persistence.sh`
- Modified: Multiple command files (add validate_state_restoration calls)
- Test results: state file validation coverage verification

**Impact**: Reduces state_error by improving recovery from corruption; prevents cascade failures; complements existing variable validation

**References**:
- error-handling.sh: `validate_state_restoration()` function (variable-level validation)
- Error Handling Pattern: Defensive programming patterns (lines 499-556)

---

### Phase 6: Audit Error Logging Compliance Across All Commands [COMPLETE]

**Priority**: High
**Effort**: Low
**Status**: Not Started
**Dependencies**: None

**Objective**: Verify all commands comply with existing mandatory error logging pattern (Command Authoring Standards lines 89-160).

**Tasks**:
- [x] Run existing error logging compliance linter:
  ```bash
  bash .claude/scripts/lint/check-error-logging-coverage.sh --all > /tmp/error-logging-violations.txt
  ```
- [x] Review violations report and create command remediation list
- [x] For each command with violations, update to follow existing mandatory pattern:
  ```bash
  # Bash Block 1: Setup - Error Logging + Argument Capture

  # Tier 1: error-handling.sh (fail-fast)
  source "$CLAUDE_LIB/core/error-handling.sh" 2>/dev/null || {
    echo "Error: Cannot load error-handling library" >&2
    exit 1
  }
  ensure_error_log_exists

  # Set workflow metadata
  COMMAND_NAME="/command-name"
  WORKFLOW_ID="workflow_$(date +%s)"
  USER_ARGS="$*"

  # Use existing helper for ERR trap
  setup_bash_error_trap

  # Argument capture logic
  # ...existing argument parsing...
  ```
- [x] Priority commands to audit (highest error counts):
  - [x] `/build` (21 execution_error, 21 state_error)
  - [x] `/errors` (10 execution_error)
  - [x] `/plan` (10 execution_error, 4 state_error)
  - [x] `/revise` (7 execution_error, 6 state_error)
  - [x] `/research` (6 execution_error, 2 state_error)
  - [x] `/repair` (6 execution_error)
  - [x] `/todo` (already audited in Phase 2)
  - [x] Remaining commands with violations
- [x] Test early-stage error scenarios for each fixed command:
  - Invalid arguments
  - Missing required environment variables
  - File permission errors during argument capture
- [x] Re-run linter to verify all violations resolved
- [x] Verify all errors logged to errors.jsonl from command start

**Artifacts**:
- Modified: Multiple command files (`.claude/commands/*.md`) if violations found
- Validation report: error logging compliance before/after comparison
- Test results: early-stage error logging verification

**Impact**: Ensures compliance with existing mandatory pattern; eliminates unlogged failures; improves error visibility for /errors and /repair workflows

**References**:
- Command Authoring Standards: Error Logging Integration (lines 89-160)
- error-handling.sh: `setup_bash_error_trap()` helper function
- Linter: `check-error-logging-coverage.sh` (existing enforcement tool)

**Note**: This phase audits compliance with EXISTING mandatory pattern, not creating new infrastructure. Documentation already contains required pattern; no documentation updates needed.

---

### Phase 7: Update Error Log Status [COMPLETE]

**Priority**: Critical
**Effort**: Low
**Status**: Not Started
**Dependencies**: [Phase 1, Phase 2, Phase 3, Phase 4, Phase 5, Phase 6]

**Objective**: Update error log entries from FIX_PLANNED to RESOLVED

**Tasks**:
- [x] Verify all fixes are working (tests pass, no new errors generated):
  ```bash
  # Run full test suite
  bash .claude/tests/run-all-tests.sh

  # Verify no new errors in last 10 minutes
  /errors --since 10m --summary
  ```
- [x] Update error log entries to RESOLVED status:
  ```bash
  source .claude/lib/core/error-handling.sh
  PLAN_PATH="/home/benjamin/.config/.claude/specs/995_repair_todo_20251201_143930/plans/001-repair-todo-20251201-143930-plan.md"
  RESOLVED_COUNT=$(mark_errors_resolved_for_plan "$PLAN_PATH")
  echo "Resolved $RESOLVED_COUNT error log entries"
  ```
- [x] Verify no FIX_PLANNED errors remain for this plan:
  ```bash
  REMAINING=$(query_errors --status FIX_PLANNED | jq -r '.repair_plan_path' | grep -c "$(basename "$(dirname "$(dirname "$PLAN_PATH")")")" || echo "0")
  [ "$REMAINING" -eq 0 ] && echo "All errors resolved" || echo "WARNING: $REMAINING errors still FIX_PLANNED"
  ```
- [x] Generate final repair summary:
  ```bash
  echo "=== Repair Summary ==="
  echo "Plan: $PLAN_PATH"
  echo "Errors Resolved: $RESOLVED_COUNT"
  echo "Remaining FIX_PLANNED: $REMAINING"
  echo "Phases Completed: 7/7"
  echo "Success Criteria Met: [verify all checkboxes above]"
  ```

**Artifacts**:
- Updated: `.claude/data/logs/errors.jsonl` (error status updates)
- Output: Repair completion summary

**Impact**: Marks repair workflow complete; enables future error analysis to exclude resolved issues

## Risk Assessment

### High Risk
- **Phase 3**: Modifying sourcing order across all commands may introduce regressions
  - **Mitigation**: Test each command after modification; run full test suite before committing
  - **Rollback**: Git revert if tests fail; fix commands individually

### Medium Risk
- **Phase 5**: State file validation may incorrectly flag valid files as corrupted
  - **Mitigation**: Test validation logic extensively with real state files before deployment
  - **Rollback**: Disable validation if false positives occur

### Low Risk
- **Phase 1**: Bash conditional syntax fix is isolated to /todo command
  - **Mitigation**: Test /todo thoroughly before moving to next phase
  - **Rollback**: Git revert single file if issues occur

## Testing Strategy

### Unit Tests
- Bash conditional linter verification (Phase 1)
- Error logging coverage tests (Phase 2)
- State file validation function tests (Phase 5)

### Integration Tests
- Full command execution tests for all modified commands
- State persistence round-trip tests (save → load → verify)
- Agent retry logic tests (Phase 4)

### Regression Tests
- Run existing test suites for all modified commands
- Verify no new errors generated during implementation
- Check error log for unexpected error types

### Validation
- Run all standards validators: `bash .claude/scripts/validate-all-standards.sh --all`
- Verify pre-commit hooks pass
- Query errors to confirm zero new failures: `/errors --since 1h --summary`

## Notes

- This plan addresses both immediate /todo issues and systemic problems affecting 72% of all errors
- Implementation leverages existing infrastructure to achieve 35-50% effort reduction:
  - validation-utils.sh library for agent artifact validation (Phase 4)
  - error-handling.sh helpers (validate_state_restoration, setup_bash_error_trap) (Phases 2, 5, 6)
  - Existing linters for compliance verification (Phases 3, 6)
- Phase dependencies ensure fixes build on each other:
  - Phase 4 depends on Phase 3 (validation-utils.sh sourcing)
  - Phase 5 depends on Phase 3 (three-tier sourcing for error-handling.sh)
- Priority is set based on error frequency and impact (High: 72% of errors, Medium: 17% of errors, Low: <1% of errors)
- Effort estimates revised to reflect infrastructure reuse:
  - Low (0.5-2 hours): Phases 1, 2, 4, 5, 6, 7
  - Medium (3-6 hours): Phase 3
- Total estimated effort: ~8-13 hours (revised from 15-20h)
- Success criteria aligned with research recommendations and standards conformance
- Phase 6 changed from "create new infrastructure" to "audit existing compliance" (fully redundant pattern eliminated)
