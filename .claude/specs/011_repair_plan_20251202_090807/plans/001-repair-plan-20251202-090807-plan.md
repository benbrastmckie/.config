# /plan Errors Repair Implementation Plan

## Metadata
- **Date**: 2025-12-02
- **Feature**: Repair /plan command error logging and state management issues
- **Scope**: Fix PATH MISMATCH validation, JSON array state persistence, test environment detection, and state restoration failures
- **Estimated Phases**: 6
- **Estimated Hours**: 8
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Status**: [COMPLETE]
- **Complexity Score**: 48.0
- **Structure Level**: 0
- **Research Reports**:
  - [Error Analysis Report](../reports/001-plan-errors-repair.md)

## Overview

This repair plan addresses critical issues in the /plan command that are blocking workflow execution and polluting error logs with false positives. The research report analyzed 33 errors from the /plan command over 11 days and identified 7 distinct error patterns with 5 root causes requiring remediation.

The most urgent issues are false-positive PATH MISMATCH detections when CLAUDE_PROJECT_DIR is a subdirectory of HOME, and JSON array validation failures in state persistence. Additionally, 64% of logged errors originate from test environments, making it difficult to identify real production issues.

## Research Summary

Key findings from error analysis report:

- **Pattern 2 (High Priority)**: PATH MISMATCH validation incorrectly flags paths when CLAUDE_PROJECT_DIR is subdirectory of HOME (e.g., /home/benjamin/.config), causing immediate workflow initialization failures
- **Pattern 3 (High Priority)**: State persistence library rejects valid JSON arrays for _JSON-suffixed keys, blocking state transitions (15% of errors)
- **Pattern 5 (High Priority)**: Critical variables (TOPIC_PATH, RESEARCH_DIR) not restored from state, likely due to Pattern 3 JSON validation blocking state saves
- **Pattern 1 + 4 (Medium Priority)**: 64% of errors from test suite runs polluting production error logs, making debugging difficult
- **Pattern 7 (Medium Priority)**: Directory creation failures during research phase need better error handling

Research identified correlation between workflow output errors and logged errors, validating root cause hypotheses through actual command execution traces.

## Success Criteria

- [ ] PATH MISMATCH false positives eliminated (CLAUDE_PROJECT_DIR subdirectory of HOME works correctly)
- [ ] JSON array values persist successfully for _JSON-suffixed state keys
- [ ] Critical variables (TOPIC_PATH, RESEARCH_DIR) restore successfully from state files
- [ ] Test environment errors tagged separately from production errors (80%+ test error reduction)
- [ ] All /plan command tests pass without state restoration failures
- [ ] Error log contains only production errors or explicitly tagged test errors
- [ ] State file validation and recovery mechanisms functioning
- [ ] Error log entries for fixed issues marked RESOLVED

## Technical Design

### Architecture Overview

This repair targets three interconnected subsystems:

1. **Path Validation Logic** (.claude/commands/plan.md Block 1b): Validate CLAUDE_PROJECT_DIR configuration before checking STATE_FILE paths
2. **State Persistence Library** (.claude/lib/core/state-persistence.sh): Update type validation to permit JSON arrays for _JSON-suffixed keys
3. **Error Logging Infrastructure** (.claude/lib/core/error-handling.sh): Add test environment detection to separate test vs production errors

### Key Design Decisions

**Decision 1: Add CLAUDE_PROJECT_DIR Subdirectory Check Before PATH MISMATCH Validation**

Rationale: Current logic flags STATE_FILE paths starting with $HOME as errors without checking if $CLAUDE_PROJECT_DIR legitimately starts with $HOME. When managing .config/ as project root, this is a valid configuration.

Implementation:
```bash
# In plan.md Block 1b, BEFORE existing STATE_FILE validation
if [[ "$CLAUDE_PROJECT_DIR" =~ ^${HOME}/ ]]; then
  # Skip PATH MISMATCH check - PROJECT_DIR legitimately under HOME
  :
elif [[ "$STATE_FILE" =~ ^${HOME}/ ]] && ! [[ "$CLAUDE_PROJECT_DIR" =~ ^${HOME}/ ]]; then
  # Only flag as error if PROJECT_DIR is NOT under HOME
  log_command_error "state_error" "PATH MISMATCH detected" "..."
  exit 1
fi
```

**Decision 2: Allow JSON Arrays for _JSON-Suffixed State Keys**

Rationale: State persistence library correctly validates that non-JSON keys should not contain JSON content, but incorrectly rejects JSON content for keys explicitly designed to hold JSON (e.g., COMPLETED_STATES_JSON, REPORT_PATHS_JSON).

Implementation:
```bash
# In state-persistence.sh append_workflow_state function
if [[ "$key" =~ _JSON$ ]]; then
  # Allow JSON content for _JSON-suffixed keys
  echo "${key}='${value}'" >> "$STATE_FILE"
elif [[ "$value" =~ [\[\{] ]]; then
  # Reject JSON for non-JSON keys (existing behavior)
  log_command_error "state_error" "Type validation failed: JSON detected" "..."
  return 1
fi
```

**Decision 3: Test Environment Detection via TEST_MODE Variable**

Rationale: Test suite errors are expected failures validating error handling paths. Logging these as production errors pollutes the error log, making it difficult to identify real issues. Adding environment detection allows suppression or separate tagging.

Implementation:
```bash
# In error-handling.sh log_command_error function
if [[ "${TEST_MODE:-0}" == "1" ]] || [[ "${BASH_SOURCE[*]}" =~ test ]]; then
  environment="test"
else
  environment="production"
fi

# Add environment field to JSON log entry
jq -n \
  --arg env "$environment" \
  --arg error_type "$error_type" \
  '{environment: $env, error_type: $error_type, ...}'
```

**Decision 4: State File Validation Before Restoration**

Rationale: State restoration failures (TOPIC_PATH, RESEARCH_DIR missing) suggest state file corruption or incomplete saves. Adding validation before load_workflow_state enables graceful degradation and better error messages.

Implementation:
```bash
# New function in state-persistence.sh
validate_state_file() {
  local state_file="$1"

  # Check file exists and is readable
  [[ -f "$state_file" ]] && [[ -r "$state_file" ]] || return 1

  # Check file is valid bash syntax
  bash -n "$state_file" 2>/dev/null || return 1

  # Check for minimum required variables
  grep -q "WORKFLOW_ID=" "$state_file" || return 1

  return 0
}
```

### Standards Alignment

- **Bash Sourcing**: All phases use three-tier sourcing pattern with fail-fast handlers for Tier 1 libraries
- **Error Logging**: All validation failures call log_command_error before exit
- **Output Suppression**: Library sourcing uses 2>/dev/null with explicit error handlers
- **Testing Protocols**: Each phase includes test validation with coverage requirements
- **Clean-Break Development**: No deprecation periods for internal tooling changes, atomic fixes with old code deletion

## Implementation Phases

### Phase 1: Fix PATH MISMATCH Validation Logic [COMPLETE]
dependencies: []

**Objective**: Update path validation to correctly handle CLAUDE_PROJECT_DIR as subdirectory of HOME

**Complexity**: Low

Tasks:
- [x] Read /home/benjamin/.config/.claude/commands/plan.md to locate Block 1b path validation logic
- [x] Add CLAUDE_PROJECT_DIR subdirectory check BEFORE existing STATE_FILE validation
- [x] Update conditional logic: only flag error if STATE_FILE uses HOME AND CLAUDE_PROJECT_DIR does NOT use HOME
- [x] Remove escaped negation `\!` syntax error (use `! [[` or separate condition)
- [x] Add inline comment documenting subdirectory check: "Skip PATH MISMATCH when PROJECT_DIR is subdirectory of HOME"
- [x] Verify fix with manual test: `HOME=/home/benjamin CLAUDE_PROJECT_DIR=/home/benjamin/.config bash .claude/commands/plan.md`

Testing:
```bash
# Test Case 1: PROJECT_DIR subdirectory of HOME (should pass)
export HOME="/home/benjamin"
export CLAUDE_PROJECT_DIR="/home/benjamin/.config"
export STATE_FILE="/home/benjamin/.config/.claude/tmp/workflow_plan_12345.sh"

# Run plan command initialization (Block 1b)
# Expected: No PATH MISMATCH error

# Test Case 2: PROJECT_DIR not under HOME (should fail if STATE_FILE uses HOME)
export HOME="/home/benjamin"
export CLAUDE_PROJECT_DIR="/opt/project"
export STATE_FILE="/home/benjamin/.claude/tmp/workflow_plan_12345.sh"

# Run plan command initialization (Block 1b)
# Expected: PATH MISMATCH error logged

# Test Case 3: STATE_FILE correctly uses PROJECT_DIR (should pass)
export HOME="/home/benjamin"
export CLAUDE_PROJECT_DIR="/opt/project"
export STATE_FILE="/opt/project/.claude/tmp/workflow_plan_12345.sh"

# Run plan command initialization (Block 1b)
# Expected: No PATH MISMATCH error
```

**Expected Duration**: 1 hour

### Phase 2: Allow JSON Arrays in State Persistence [COMPLETE]
dependencies: [1]

**Objective**: Update state-persistence.sh to permit JSON arrays for _JSON-suffixed keys

**Complexity**: Medium

Tasks:
- [x] Read /home/benjamin/.config/.claude/lib/core/state-persistence.sh to locate append_workflow_state function
- [x] Identify current type validation logic (line rejecting JSON content)
- [x] Add _JSON suffix check BEFORE existing JSON validation: `if [[ "$key" =~ _JSON$ ]]; then`
- [x] Allow JSON arrays/objects for _JSON-suffixed keys: `echo "${key}='${value}'" >> "$STATE_FILE"`
- [x] Preserve existing JSON rejection for non-JSON keys
- [x] Add inline comment: "Allow JSON content for keys explicitly designed to hold JSON (_JSON suffix)"
- [x] Update function documentation to describe _JSON suffix convention
- [x] Search codebase for other uses of _JSON suffix to ensure consistency: `grep -r "_JSON=" .claude/`

Testing:
```bash
# Test Case 1: JSON array for _JSON-suffixed key (should succeed)
append_workflow_state "$STATE_FILE" "COMPLETED_STATES_JSON" '["plan","research"]'
echo "Expected: State saved successfully"
grep "COMPLETED_STATES_JSON" "$STATE_FILE"

# Test Case 2: JSON array for non-JSON key (should fail)
append_workflow_state "$STATE_FILE" "TOPIC_NAME" '["invalid"]'
echo "Expected: Type validation error logged"

# Test Case 3: String value for _JSON-suffixed key (should succeed)
append_workflow_state "$STATE_FILE" "METADATA_JSON" 'simple_string'
echo "Expected: State saved (string allowed)"

# Test Case 4: JSON object for _JSON-suffixed key (should succeed)
append_workflow_state "$STATE_FILE" "CONFIG_JSON" '{"key":"value"}'
echo "Expected: State saved successfully"
```

**Expected Duration**: 2 hours

### Phase 3: Add State File Validation and Recovery [COMPLETE]
dependencies: [2]

**Objective**: Implement validation before state restoration with graceful degradation

**Complexity**: Medium

Tasks:
- [x] Add validate_state_file function to /home/benjamin/.config/.claude/lib/core/state-persistence.sh
- [x] Implement file existence, readability, and bash syntax validation
- [x] Check for minimum required variables (WORKFLOW_ID, COMMAND_NAME)
- [x] Update load_workflow_state to call validate_state_file before sourcing
- [x] Add detailed restoration logging: log each restored variable with value
- [x] Implement fallback behavior: if state file invalid, log error and exit with clear message
- [x] Add validate_state_restoration helper function to check critical variables after load
- [x] Update /home/benjamin/.config/.claude/commands/plan.md to call validate_state_restoration after load_workflow_state

Testing:
```bash
# Test Case 1: Valid state file (should restore successfully)
create_valid_state_file "$STATE_FILE"
load_workflow_state "$WORKFLOW_ID" false
validate_state_restoration "WORKFLOW_ID" "TOPIC_PATH" "RESEARCH_DIR"
echo "Expected: All variables restored, validation passes"

# Test Case 2: Corrupted state file (should fail gracefully)
echo "invalid bash syntax {" > "$STATE_FILE"
load_workflow_state "$WORKFLOW_ID" false
echo "Expected: Validation error, clear message, exit 1"

# Test Case 3: Missing critical variables (should detect and report)
create_state_file_missing_topic_path "$STATE_FILE"
load_workflow_state "$WORKFLOW_ID" false
validate_state_restoration "WORKFLOW_ID" "TOPIC_PATH" "RESEARCH_DIR"
echo "Expected: Validation fails, reports missing TOPIC_PATH"

# Test Case 4: State file with JSON arrays (Phase 2 fix verification)
append_workflow_state "$STATE_FILE" "COMPLETED_STATES_JSON" '["plan"]'
load_workflow_state "$WORKFLOW_ID" false
echo "COMPLETED_STATES_JSON value: ${COMPLETED_STATES_JSON}"
echo "Expected: JSON array restored correctly"
```

**Expected Duration**: 2 hours

### Phase 4: Add Test Environment Detection to Error Logging [COMPLETE]
dependencies: []

**Objective**: Separate test environment errors from production errors in error log

**Complexity**: Low

Tasks:
- [x] Read /home/benjamin/.config/.claude/lib/core/error-handling.sh to locate log_command_error function
- [x] Add environment detection logic: check TEST_MODE environment variable and BASH_SOURCE path
- [x] Add "environment" field to JSON log entry structure (values: "test" or "production")
- [x] Update ensure_error_log_exists to document environment field in log schema
- [x] Update all test scripts in /home/benjamin/.config/.claude/tests/ to set TEST_MODE=1 at start
- [x] Add test environment marker to test_*.sh files: `export TEST_MODE=1`
- [x] Update query_errors function to support --environment filter flag
- [x] Document TEST_MODE convention in error-handling.sh function header comments

Testing:
```bash
# Test Case 1: Production environment (should tag as production)
unset TEST_MODE
log_command_error "validation_error" "Test message" ""
last_error=$(tail -n1 .claude/data/logs/errors.jsonl)
echo "$last_error" | jq -r '.environment'
echo "Expected: production"

# Test Case 2: Test environment via TEST_MODE (should tag as test)
export TEST_MODE=1
log_command_error "execution_error" "Test failure" ""
last_error=$(tail -n1 .claude/data/logs/errors.jsonl)
echo "$last_error" | jq -r '.environment'
echo "Expected: test"

# Test Case 3: Test environment via BASH_SOURCE (should tag as test)
unset TEST_MODE
# Simulate call from test script
BASH_SOURCE=("/home/user/.claude/tests/test_plan.sh")
log_command_error "agent_error" "Agent timeout" ""
last_error=$(tail -n1 .claude/data/logs/errors.jsonl)
echo "$last_error" | jq -r '.environment'
echo "Expected: test"

# Test Case 4: Query production errors only
query_errors --environment production --since 1h
echo "Expected: Only production errors returned"
```

**Expected Duration**: 1.5 hours

### Phase 5: Integration Testing and Validation [COMPLETE]
dependencies: [1, 2, 3, 4]

**Objective**: Verify all fixes work together and resolve the original error patterns

**Complexity**: Medium

Tasks:
- [x] Run /plan command with CLAUDE_PROJECT_DIR=/home/benjamin/.config (validate Phase 1 fix)
- [x] Verify no PATH MISMATCH errors logged during workflow initialization
- [x] Check state file contains _JSON-suffixed keys with JSON array values (validate Phase 2 fix)
- [x] Resume interrupted /plan workflow and verify critical variables restored (validate Phase 3 fix)
- [x] Run full test suite and verify test errors tagged with environment=test (validate Phase 4 fix)
- [x] Query production errors: `/errors --environment production --since 1h` (should show only real errors)
- [x] Run workflow state restoration test: create state, exit, resume, validate variables present
- [x] Check error log for false positive patterns identified in research report (should be eliminated)
- [x] Validate error logging coverage meets 80% threshold: `bash .claude/scripts/lint/check-error-logging-coverage.sh`

Testing:
```bash
# Integration Test 1: Full /plan workflow with subdirectory PROJECT_DIR
export HOME="/home/benjamin"
export CLAUDE_PROJECT_DIR="/home/benjamin/.config"
/plan test-feature
echo "Expected: No PATH MISMATCH errors, workflow completes successfully"

# Integration Test 2: State persistence with JSON arrays
/plan complex-workflow  # Workflow generates _JSON-suffixed state keys
STATE_FILE=$(ls .claude/tmp/workflow_plan_*.sh | head -1)
grep "COMPLETED_STATES_JSON" "$STATE_FILE"
grep "REPORT_PATHS_JSON" "$STATE_FILE"
echo "Expected: JSON arrays present in state file"

# Integration Test 3: State restoration after interruption
/plan resumable-workflow  # Start workflow
kill -TERM $!  # Simulate interruption
/plan --resume  # Resume workflow
echo "Expected: TOPIC_PATH and RESEARCH_DIR restored, workflow continues"

# Integration Test 4: Test error segregation
export TEST_MODE=1
bash .claude/tests/integration/test_plan_command.sh
query_errors --environment test --since 5m
echo "Expected: Test errors present with environment=test tag"

query_errors --environment production --since 5m
echo "Expected: No test errors in production query results"

# Integration Test 5: Error pattern elimination
query_errors --command /plan --type state_error --since 1d \
  | jq -r '.error_message' \
  | grep -c "PATH MISMATCH"
echo "Expected: 0 (all PATH MISMATCH false positives eliminated)"

query_errors --command /plan --type state_error --since 1d \
  | jq -r '.error_message' \
  | grep -c "Type validation failed: JSON detected"
echo "Expected: 0 (all JSON validation failures eliminated)"
```

**Expected Duration**: 1.5 hours

### Phase 6: Update Error Log Status [COMPLETE]
dependencies: [1, 2, 3, 4, 5]

**Objective**: Update error log entries from FIX_PLANNED to RESOLVED

**Complexity**: Low

Tasks:
- [x] Verify all fixes are working (tests pass, no new errors generated)
- [x] Update error log entries to RESOLVED status:
  ```bash
  source .claude/lib/core/error-handling.sh
  RESOLVED_COUNT=$(mark_errors_resolved_for_plan "/home/benjamin/.config/.claude/specs/011_repair_plan_20251202_090807/plans/001-repair-plan-20251202-090807-plan.md")
  echo "Resolved $RESOLVED_COUNT error log entries"
  ```
- [x] Verify no FIX_PLANNED errors remain for this plan:
  ```bash
  REMAINING=$(query_errors --status FIX_PLANNED | jq -r '.repair_plan_path' | grep -c "011_repair_plan_20251202_090807" || echo "0")
  [ "$REMAINING" -eq 0 ] && echo "All errors resolved" || echo "WARNING: $REMAINING errors still FIX_PLANNED"
  ```
- [x] Generate summary report: error types fixed, total errors resolved, remaining production errors
- [x] Update research report with implementation results
- [x] Document any edge cases discovered during testing

Testing:
```bash
# Verify error resolution
query_errors --command /plan --status RESOLVED --since 7d
echo "Expected: Error entries for PATH MISMATCH, JSON validation, state restoration marked RESOLVED"

# Verify no FIX_PLANNED errors remain
query_errors --status FIX_PLANNED | jq -r '.repair_plan_path' | grep "011_repair_plan_20251202_090807"
echo "Expected: No results (all errors resolved)"

# Verify production error log cleanliness
query_errors --environment production --command /plan --since 7d --summary
echo "Expected: Only legitimate production errors, no test pollution or false positives"

# Generate resolution metrics
echo "Resolution Summary:"
echo "- PATH MISMATCH false positives: $(query_errors --status RESOLVED | grep -c 'PATH MISMATCH')"
echo "- JSON validation failures: $(query_errors --status RESOLVED | grep -c 'Type validation failed')"
echo "- State restoration failures: $(query_errors --status RESOLVED | grep -c 'Critical variables not restored')"
echo "- Total errors resolved: $(query_errors --status RESOLVED | wc -l)"
```

**Expected Duration**: 0.5 hours

## Testing Strategy

### Test Coverage Requirements

- **Unit Tests**: 80%+ coverage for modified functions (validate_state_file, environment detection logic)
- **Integration Tests**: Full /plan workflow with all fixes active
- **Regression Tests**: Verify original error patterns no longer occur

### Test Execution Plan

1. **Phase 1-4 Testing**: Each phase includes inline test cases validating specific fix
2. **Phase 5 Integration Testing**: Full workflow tests with all fixes combined
3. **Phase 6 Verification**: Error log queries confirming resolution

### Success Metrics

- 0 PATH MISMATCH false positives in production error log
- 0 JSON validation failures for _JSON-suffixed keys
- 0 state restoration failures for critical variables (TOPIC_PATH, RESEARCH_DIR)
- 80%+ reduction in test error pollution (from 21 errors to <5 in production log)
- All /plan command tests pass without errors

## Documentation Requirements

### Files to Update

1. **/.claude/commands/plan.md**: Document PATH MISMATCH fix in Block 1b inline comments
2. **/.claude/lib/core/state-persistence.sh**: Document _JSON suffix convention in append_workflow_state header
3. **/.claude/lib/core/error-handling.sh**: Document TEST_MODE environment variable and environment field in log schema
4. **/.claude/docs/concepts/patterns/error-handling.md**: Add test environment detection pattern example
5. **/.claude/tests/README.md**: Document TEST_MODE=1 requirement for all test scripts

### Documentation Standards

- Inline comments describe WHAT code does (not WHY it was designed that way)
- Function headers document parameters, return values, and usage examples
- README updates follow existing structure and format
- No historical commentary (clean-break development standard)

## Dependencies

### External Dependencies

- jq (JSON parsing for error log queries)
- bash 4.0+ (for associative arrays and regex operators)
- git (for error log commit history)

### Internal Dependencies

- /.claude/lib/core/state-persistence.sh (Phases 2, 3)
- /.claude/lib/core/error-handling.sh (Phases 1, 3, 4)
- /.claude/lib/workflow/validation-utils.sh (Phase 3)
- /.claude/commands/plan.md (Phases 1, 3)
- All test scripts in /.claude/tests/ (Phase 4)

### Prerequisite Checks

```bash
# Verify required tools installed
command -v jq >/dev/null 2>&1 || echo "ERROR: jq not installed"
command -v git >/dev/null 2>&1 || echo "ERROR: git not installed"

# Verify bash version
[[ "${BASH_VERSINFO[0]}" -ge 4 ]] || echo "ERROR: bash 4.0+ required"

# Verify error log exists
[[ -f ".claude/data/logs/errors.jsonl" ]] || echo "WARNING: Error log not initialized"

# Verify state persistence library exists
[[ -f ".claude/lib/core/state-persistence.sh" ]] || echo "ERROR: state-persistence.sh missing"

# Verify error handling library exists
[[ -f ".claude/lib/core/error-handling.sh" ]] || echo "ERROR: error-handling.sh missing"
```

## Risk Assessment

### High-Risk Changes

1. **State Persistence Type Validation**: Changing JSON validation logic could break other commands using state persistence
   - Mitigation: Test all commands using _JSON-suffixed keys before deployment
   - Rollback: Revert append_workflow_state changes, use space-delimited strings instead of JSON

2. **PATH MISMATCH Validation Logic**: Incorrect conditional could allow invalid paths or block valid ones
   - Mitigation: Comprehensive test coverage for all PROJECT_DIR/HOME configurations
   - Rollback: Revert to original validation with documented false positive case

### Medium-Risk Changes

1. **Test Environment Detection**: Incorrect detection could suppress production errors or tag them as test
   - Mitigation: Conservative detection logic (require explicit TEST_MODE=1 or test path in BASH_SOURCE)
   - Rollback: Remove environment field, revert to unified error logging

### Low-Risk Changes

1. **State File Validation**: Adding validation before restoration has minimal risk (fail-fast behavior)
2. **Error Log Status Updates**: Marking errors RESOLVED is informational only, does not affect command execution

## Notes

- Phase 1 and Phase 4 have no dependencies and can be implemented in parallel
- Phase 2 must complete before Phase 3 (state validation depends on JSON array support)
- Phase 5 requires all preceding phases complete for integration testing
- Phase 6 is mandatory for repair plans to update error log status
- All bash blocks follow three-tier sourcing pattern with fail-fast handlers for Tier 1 libraries
- Error logging integrated in all validation failure paths (80%+ coverage target)
