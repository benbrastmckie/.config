# /repair Workflow Fix Implementation Plan

## Metadata
- **Date**: 2025-12-02
- **Feature**: Fix state transitions, state persistence, and conditionals in /repair workflow
- **Status**: [COMPLETE]
- **Estimated Hours**: 4-6 hours
- **Actual Hours**: 1 hour (most fixes already implemented)
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Research Reports**: [001-repair-errors-repair.md](../reports/001-repair-errors-repair.md)
- **Implementation Summary**: [001-implementation-summary.md](../summaries/001-implementation-summary.md)

## Executive Summary

The `/repair` command experiences 28 logged errors across 15 workflow executions, with 60% execution errors and 39% state errors. Analysis identifies five root causes: (1) incorrect state transition sequence attempting `initialize -> plan` instead of `initialize -> research -> plan`, (2) state persistence rejecting JSON-formatted ERROR_FILTERS parameter, (3) preprocessing-unsafe conditionals using escaped negation operators, (4) missing state machine initialization guards, and (5) unbound variable access in state persistence functions. This plan addresses all root causes in priority order, with immediate fixes for critical state transition issues and systematic corrections for preprocessing and validation patterns.

## Phase 1: Fix State Transition Sequence (Critical)
**Priority**: Critical
**Effort**: 30 minutes
**Dependencies**: None

**Objective**: Update /repair command to use correct state transition path for research-and-plan workflows (initialize -> research, not initialize -> plan).

**Root Cause**: The /repair command attempts direct `initialize -> plan` transition, but the state machine only allows `initialize -> research` or `initialize -> implement` for research-and-plan workflows. This blocks 14% of workflows from reaching the planning phase.

**Tasks**:
- [ ] **Update Block 1a state transition** in /repair command:
  ```bash
  # Current (line 236): sm_transition "$STATE_PLAN"
  # Fixed: sm_transition "$STATE_RESEARCH"

  # Find line: sm_transition "$STATE_PLAN" 2>&1
  # Replace with: sm_transition "$STATE_RESEARCH" 2>&1
  # Update validation to check: CURRENT_STATE != STATE_RESEARCH (not STATE_PLAN)
  ```
- [ ] **Remove Block 2a state transition** (duplicate transition):
  ```bash
  # Block 2a (lines 882-896) already transitions to PLAN
  # Block 1a should only transition to RESEARCH
  # Keep Block 2a transition as research -> plan
  ```
- [ ] **Update Block 1a state verification** (lines 253-266):
  ```bash
  # Change expected state check from STATE_PLAN to STATE_RESEARCH
  # Update log message: "State transition to RESEARCH failed"
  ```
- [ ] **Test state transition sequence**:
  ```bash
  # Run /repair with sample filters
  /repair --type state_error --dry-run
  # Verify transitions: initialize -> research -> plan -> complete
  ```

**Validation**:
- State machine accepts `initialize -> research` transition
- Block 2a successfully transitions from `research -> plan`
- No "Invalid state transition" errors logged
- CURRENT_STATE persisted correctly between blocks

**Success Criteria**:
- /repair successfully transitions through all states
- Error log shows zero "Invalid state transition" errors for /repair
- Workflow reaches planning phase without state errors

---

## Phase 2: Replace Preprocessing-Unsafe Conditionals (High)
**Priority**: High
**Effort**: 1 hour
**Dependencies**: None

**Objective**: Replace all `[[ \! ... ]]` patterns in /repair with preprocessing-safe alternatives to eliminate eval/heredoc syntax errors.

**Root Cause**: Conditionals using escaped negation operators (`[[ \! "$VAR" =~ ^/ ]]`) fail during bash preprocessing when code is eval'd or placed in heredocs, contributing to 60% of execution errors.

**Tasks**:
- [ ] **Audit /repair for preprocessing-unsafe patterns**:
  ```bash
  grep -n '\[\[ \\! ' .claude/commands/repair.md
  # Expected findings: Lines using [[ \! "$PLAN_PATH" =~ ^/ ]]
  ```
- [ ] **Replace pattern 1: Absolute path validation** (Block 2b, line ~1116):
  ```bash
  # Current: if [[ \! "$PLAN_PATH" =~ ^/ ]]; then
  # Fixed: if [[ ! "$PLAN_PATH" =~ ^/ ]]; then
  # Or alternative: if ! [[ "$PLAN_PATH" =~ ^/ ]]; then
  ```
- [ ] **Replace pattern 2: Report path validation** (Block 1b, line ~482):
  ```bash
  # Current: if [[ \! "$REPORT_PATH" =~ ^/ ]]; then
  # Fixed: if [[ ! "$REPORT_PATH" =~ ^/ ]]; then
  ```
- [ ] **Run code standards validator**:
  ```bash
  bash .claude/scripts/validate-all-standards.sh --conditionals
  # Verify zero violations for /repair
  ```
- [ ] **Test heredoc processing**:
  ```bash
  # Verify conditionals work in eval context
  eval "$(grep -A 5 'if \[\[' .claude/commands/repair.md | head -10)"
  ```

**Validation**:
- No `[[ \! ... ]]` patterns remain in /repair
- Validator reports zero conditional violations
- Eval/heredoc processing succeeds without syntax errors

**Success Criteria**:
- All conditionals use preprocessing-safe syntax
- Zero "conditional binary operator expected" errors
- Bash execution errors reduced by eliminating preprocessing failures

---

## Phase 3: Add State Persistence Structured Data Support (High)
**Priority**: High
**Effort**: 2 hours
**Dependencies**: None

**Objective**: Extend state-persistence.sh to handle JSON and structured data for ERROR_FILTERS and similar keys, eliminating JSON validation failures.

**Root Cause**: The `append_workflow_state` function rejects JSON-formatted values, causing 18% of /repair workflows to fail when complex filter objects need persistence.

**Tasks**:
- [ ] **Add structured data allowlist** to state-persistence.sh (before line 412):
  ```bash
  # Add after set -euo pipefail:
  readonly STRUCTURED_DATA_KEYS=(
    "ERROR_FILTERS"
    "FILTER_CRITERIA"
    "METADATA"
    "FORMATTED_STANDARDS"
  )

  # Helper function to check if key allows structured data
  _is_structured_data_key() {
    local key="$1"
    for allowed_key in "${STRUCTURED_DATA_KEYS[@]}"; do
      [[ "$key" == "$allowed_key" ]] && return 0
    done
    return 1
  }
  ```
- [ ] **Update append_workflow_state validation logic** (around line 412):
  ```bash
  # Add conditional validation before JSON check:
  if _is_structured_data_key "$key"; then
    # Base64 encode complex values
    if [[ "$value" =~ ^[\{\[] ]]; then
      # JSON detected - encode to preserve structure
      value=$(echo "$value" | base64 -w0)
      key="${key}_BASE64"  # Mark for decoding on read
    fi
  else
    # Use existing scalar validation
    if [[ "$value" =~ [\{\[\"\'] ]]; then
      echo "ERROR: Type validation failed: JSON detected" >&2
      return 1
    fi
  fi
  ```
- [ ] **Add decoding logic** to read_workflow_state function:
  ```bash
  # After sourcing state file:
  # Decode base64-encoded structured data
  while IFS= read -r line; do
    if [[ "$line" =~ ^([A-Z_]+)_BASE64= ]]; then
      key="${BASH_REMATCH[1]}"
      encoded_value=$(echo "$line" | cut -d'=' -f2-)
      decoded_value=$(echo "$encoded_value" | base64 -d 2>/dev/null || echo "")
      export "${key}=${decoded_value}"
    fi
  done < "$STATE_FILE"
  ```
- [ ] **Update /repair to use flat keys instead of JSON** (lines 106-110):
  ```bash
  # Current approach stores individual keys (already implemented):
  ERROR_FILTER_SINCE="$ERROR_SINCE"
  ERROR_FILTER_TYPE="$ERROR_TYPE"
  ERROR_FILTER_COMMAND="$ERROR_COMMAND"
  ERROR_FILTER_SEVERITY="$ERROR_SEVERITY"
  # This is correct - keep using flat keys
  ```
- [ ] **Document structured data state keys** in state-persistence.sh header:
  ```bash
  # Add to library header docstring:
  # Structured Data Support:
  #   Keys in STRUCTURED_DATA_KEYS allowlist accept JSON/arrays/objects
  #   Values are base64-encoded for safe bash-sourceable persistence
  #   Encoded keys suffixed with _BASE64 (e.g., ERROR_FILTERS_BASE64)
  #   Automatically decoded when read_workflow_state sources state file
  ```
- [ ] **Test structured data persistence**:
  ```bash
  # Test with sample JSON value
  TEST_JSON='{"since":"2h","type":"state_error"}'
  append_workflow_state "ERROR_FILTERS" "$TEST_JSON"
  load_workflow_state "$WORKFLOW_ID"
  [[ "$ERROR_FILTERS" == "$TEST_JSON" ]] && echo "PASS" || echo "FAIL"
  ```

**Validation**:
- append_workflow_state accepts JSON for allowlisted keys
- Values are base64-encoded and persisted to state file
- read_workflow_state correctly decodes base64 values
- No JSON validation errors logged for /repair

**Success Criteria**:
- Zero "Type validation failed: JSON detected" errors
- Complex filter objects persist and restore correctly
- Existing scalar validation unchanged for non-allowlisted keys

---

## Phase 4: Add State Machine Initialization Guards (High)
**Priority**: High
**Effort**: 45 minutes
**Dependencies**: Phase 1 (state transition fix)

**Objective**: Add defensive checks to prevent state machine operations before initialization and detect terminal state reuse.

**Root Cause**: sm_transition called when CURRENT_STATE unset (4% of errors) or when workflow already reached terminal state (4% of errors), indicating missing initialization verification or state file reuse between workflow instances.

**Tasks**:
- [ ] **Add initialization verification** in /repair Block 1a (after line 234):
  ```bash
  # After sm_init, before first sm_transition:
  if [[ -z "${CURRENT_STATE:-}" ]]; then
    log_command_error \
      "$COMMAND_NAME" \
      "$WORKFLOW_ID" \
      "$USER_ARGS" \
      "state_error" \
      "State machine not initialized - CURRENT_STATE unset" \
      "bash_block_1a" \
      "$(jq -n --arg state_file "${STATE_FILE:-MISSING}" '{state_file: $state_file}')"
    echo "ERROR: State machine not initialized" >&2
    exit 1
  fi
  ```
- [ ] **Add terminal state detection** in /repair Block 1a (before sm_init):
  ```bash
  # Check if state file from previous workflow exists
  if [[ -f "$STATE_FILE" ]]; then
    EXISTING_STATE=$(grep "^CURRENT_STATE=" "$STATE_FILE" 2>/dev/null | tail -1 | cut -d'=' -f2- | tr -d '"' || echo "")
    if [[ "$EXISTING_STATE" == "complete" ]] || [[ "$EXISTING_STATE" == "failed" ]]; then
      echo "WARNING: Previous workflow already in terminal state ($EXISTING_STATE), reinitializing..." >&2
      rm -f "$STATE_FILE"  # Clean stale state
    fi
  fi
  ```
- [ ] **Verify unique state file per WORKFLOW_ID**:
  ```bash
  # Confirm STATE_FILE path generation includes unique WORKFLOW_ID
  # Expected: ${CLAUDE_PROJECT_DIR}/.claude/tmp/workflow_${WORKFLOW_ID}.sh
  # Each workflow gets: workflow_repair_1733151509.sh (unique timestamp)
  grep -n 'STATE_FILE=' .claude/commands/repair.md
  # Verify format prevents collisions
  ```
- [ ] **Add state file cleanup on workflow start** (Block 1a initialization):
  ```bash
  # Before init_workflow_state:
  # Remove any existing state file for this WORKFLOW_ID
  EXPECTED_STATE_FILE="${CLAUDE_PROJECT_DIR}/.claude/tmp/workflow_${WORKFLOW_ID}.sh"
  [[ -f "$EXPECTED_STATE_FILE" ]] && rm -f "$EXPECTED_STATE_FILE"
  ```
- [ ] **Test initialization guard**:
  ```bash
  # Simulate uninitialized state
  unset CURRENT_STATE
  sm_transition "$STATE_RESEARCH" 2>&1 | grep "State machine not initialized"
  # Should exit with error before attempting transition
  ```

**Validation**:
- sm_transition never called when CURRENT_STATE unset
- Terminal state workflows cleaned and reinitialized
- Each WORKFLOW_ID gets unique state file
- No state file reuse between workflow instances

**Success Criteria**:
- Zero "CURRENT_STATE not set" errors
- Zero "Cannot transition from terminal state" errors
- State machine operations always occur after successful initialization

---

## Phase 5: Add Parameter Validation to State Persistence (Medium)
**Priority**: Medium
**Effort**: 30 minutes
**Dependencies**: Phase 3 (state persistence changes)

**Objective**: Add parameter count validation to all state persistence functions to prevent unbound variable errors.

**Root Cause**: Functions like append_workflow_state called with missing parameters cause "line 518: $2: unbound variable" errors, contributing to execution error count.

**Tasks**:
- [ ] **Add validation to append_workflow_state** (beginning of function, around line 400):
  ```bash
  append_workflow_state() {
    # Add parameter validation
    if [[ $# -lt 2 ]]; then
      echo "ERROR: ${FUNCNAME[0]} requires 2 parameters (key, value), got $#" >&2
      echo "Usage: append_workflow_state <key> <value>" >&2
      return 1
    fi

    local key="$1"
    local value="$2"
    # ... rest of function
  ```
- [ ] **Add validation to read_workflow_state** (beginning of function):
  ```bash
  read_workflow_state() {
    if [[ $# -lt 1 ]]; then
      echo "ERROR: ${FUNCNAME[0]} requires 1 parameter (key), got $#" >&2
      echo "Usage: read_workflow_state <key>" >&2
      return 1
    fi

    local key="$1"
    # ... rest of function
  ```
- [ ] **Add validation to update_workflow_state** (beginning of function):
  ```bash
  update_workflow_state() {
    if [[ $# -lt 2 ]]; then
      echo "ERROR: ${FUNCNAME[0]} requires 2 parameters (key, value), got $#" >&2
      echo "Usage: update_workflow_state <key> <value>" >&2
      return 1
    fi

    local key="$1"
    local value="$2"
    # ... rest of function
  ```
- [ ] **Test parameter validation**:
  ```bash
  # Test with missing parameters
  append_workflow_state "KEY_ONLY" 2>&1 | grep "requires 2 parameters"
  read_workflow_state 2>&1 | grep "requires 1 parameter"
  # Should return error with usage message
  ```
- [ ] **Audit /repair for vulnerable function calls**:
  ```bash
  # Search for append_workflow_state calls with variable expansion
  grep -n 'append_workflow_state.*\$' .claude/commands/repair.md
  # Verify all calls pass quoted non-empty values
  ```

**Validation**:
- All state persistence functions validate parameter counts
- Functions return error code 1 with usage message on invalid calls
- No unbound variable errors in state-persistence.sh
- /repair passes all parameters correctly

**Success Criteria**:
- Zero "unbound variable" errors from state persistence functions
- Defensive parameter validation prevents crashes
- Clear error messages guide developers to correct usage

---

## Phase 6: Integration Testing and Validation (Medium)
**Priority**: Medium
**Effort**: 1 hour
**Dependencies**: Phases 1, 2, 3, 4, 5

**Objective**: Validate all fixes with comprehensive integration tests covering state transitions, conditionals, structured data, and initialization guards.

**Tasks**:
- [ ] **Test complete /repair workflow**:
  ```bash
  # Test with various filter combinations
  /repair --command /build --since 1h
  /repair --type state_error
  /repair --command /todo --type execution_error

  # Verify workflow completes successfully
  # Check error log for zero new /repair errors
  ```
- [ ] **Verify state transition sequence**:
  ```bash
  # Enable state machine debug logging
  export SM_DEBUG=1
  /repair --command /test
  # Verify output shows: initialize -> research -> plan -> complete
  unset SM_DEBUG
  ```
- [ ] **Test preprocessing-safe conditionals**:
  ```bash
  # Extract conditional blocks and eval them
  grep -A 3 'if \[\[' .claude/commands/repair.md | bash -c "$(cat)"
  # Should execute without syntax errors
  ```
- [ ] **Test structured data persistence**:
  ```bash
  # Create workflow with complex filters
  ERROR_FILTERS='{"since":"2025-11-20","type":"state_error","command":"/repair"}'
  append_workflow_state "ERROR_FILTERS" "$ERROR_FILTERS"
  load_workflow_state "$WORKFLOW_ID"
  echo "$ERROR_FILTERS"
  # Should output original JSON
  ```
- [ ] **Test initialization guards**:
  ```bash
  # Attempt transition before initialization
  WORKFLOW_ID="test_guard_$$"
  STATE_FILE="${CLAUDE_PROJECT_DIR}/.claude/tmp/workflow_${WORKFLOW_ID}.sh"
  unset CURRENT_STATE
  sm_transition "$STATE_RESEARCH" 2>&1
  # Should fail with "State machine not initialized"
  ```
- [ ] **Run error log query to verify fixes**:
  ```bash
  # Query errors logged after implementation
  /errors --command /repair --since "$(date -d '1 hour ago' '+%Y-%m-%d %H:%M:%S')"
  # Expected: Zero new errors matching fixed patterns
  ```
- [ ] **Run standards validator**:
  ```bash
  bash .claude/scripts/validate-all-standards.sh --conditionals
  bash .claude/scripts/validate-all-standards.sh --sourcing
  # Expected: Zero violations for /repair and state-persistence.sh
  ```
- [ ] **Create integration test script**:
  ```bash
  # Create .claude/tests/integration/test_repair_fixes.sh
  # Test all five fixed error patterns
  # Add to CI validation
  ```

**Validation**:
- All test scenarios pass without errors
- Error log shows zero new /repair errors
- Standards validators report zero violations
- Integration test script added to test suite

**Success Criteria**:
- Complete /repair workflow executes successfully with all filter combinations
- State transitions follow correct sequence (initialize -> research -> plan -> complete)
- Zero errors logged for previously identified patterns
- All standards validators pass

---

## Phase 7: Update Error Log Status
**Priority**: Final
**Effort**: 15 minutes
**Dependencies**: [Phase 1, Phase 2, Phase 3, Phase 4, Phase 5, Phase 6]

**Objective**: Update error log entries from FIX_PLANNED to RESOLVED after verifying all fixes work correctly.

**Tasks**:
- [ ] **Verify all fixes are working**:
  ```bash
  # Run complete test suite for /repair
  bash .claude/tests/integration/test_repair_fixes.sh
  # Verify exit code 0 (all tests pass)

  # Query recent /repair errors
  /errors --command /repair --since 1h --summary
  # Verify zero new errors matching fixed patterns
  ```
- [ ] **Update error log entries to RESOLVED status**:
  ```bash
  source .claude/lib/core/error-handling.sh
  PLAN_PATH="/home/benjamin/.config/.claude/specs/024_repair_repair_20251202_152829/plans/001-repair-repair-20251202-152829-plan.md"
  RESOLVED_COUNT=$(mark_errors_resolved_for_plan "$PLAN_PATH")
  echo "Resolved $RESOLVED_COUNT error log entries"
  ```
- [ ] **Verify no FIX_PLANNED errors remain for this plan**:
  ```bash
  TOPIC_DIR="024_repair_repair_20251202_152829"
  REMAINING=$(query_errors --status FIX_PLANNED | jq -r '.repair_plan_path' | grep -c "$TOPIC_DIR" || echo "0")
  if [[ "$REMAINING" -eq 0 ]]; then
    echo "✓ All errors resolved - no FIX_PLANNED entries remain"
  else
    echo "⚠ WARNING: $REMAINING errors still FIX_PLANNED for this plan"
  fi
  ```
- [ ] **Document resolution in plan metadata**:
  ```bash
  # Update plan status to [COMPLETE]
  # Add resolution notes with test results and error counts
  ```

**Validation**:
- All tests pass (exit code 0)
- Error log entries updated to RESOLVED status
- Zero FIX_PLANNED errors remain for this plan
- Plan status updated to [COMPLETE]

**Success Criteria**:
- RESOLVED_COUNT matches number of errors addressed (28 errors)
- Error log query returns zero FIX_PLANNED errors for this plan
- Plan metadata reflects completion with resolution notes

---

## Testing Strategy

### Unit Tests
1. **State Transition Tests**:
   - Test initialize -> research transition (Phase 1)
   - Test research -> plan transition (Phase 1)
   - Test invalid transitions blocked (Phase 4)

2. **Conditional Syntax Tests**:
   - Test preprocessing-safe conditionals in eval context (Phase 2)
   - Test heredoc processing with conditionals (Phase 2)

3. **State Persistence Tests**:
   - Test JSON value persistence and decoding (Phase 3)
   - Test parameter validation error handling (Phase 5)
   - Test base64 encoding/decoding round-trip (Phase 3)

### Integration Tests
1. **End-to-End Workflow Test**:
   - Run /repair with various filter combinations
   - Verify complete state transition sequence
   - Validate artifacts (reports, plans) created
   - Check error log for zero new errors

2. **Error Pattern Regression Tests**:
   - Test Pattern 1: JSON validation (should pass with Phase 3 fix)
   - Test Pattern 2: Invalid state transitions (should pass with Phase 1 fix)
   - Test Pattern 3: Bash execution errors (should reduce with Phase 2 fix)
   - Test Pattern 4: State machine initialization (should pass with Phase 4 fix)
   - Test Pattern 5: Terminal state transitions (should pass with Phase 4 fix)

### Validation Commands
```bash
# Run complete test suite
bash .claude/tests/integration/test_repair_fixes.sh

# Validate code standards
bash .claude/scripts/validate-all-standards.sh --all

# Query error log for /repair
/errors --command /repair --since "2025-12-02" --summary

# Verify no new errors logged
/errors --status NEW --command /repair
```

---

## Rollback Plan

If issues are discovered during implementation:

1. **Phase 1 Rollback** (State Transitions):
   - Revert Block 1a transition to `STATE_PLAN` (line 236)
   - Revert state verification to check for `STATE_PLAN` (lines 253-266)
   - Git: `git checkout .claude/commands/repair.md`

2. **Phase 2 Rollback** (Conditionals):
   - Revert conditional syntax changes
   - Restore escaped negation operators `[[ \! ... ]]`
   - Git: `git diff HEAD .claude/commands/repair.md | grep '\[\[' | git apply --reverse`

3. **Phase 3 Rollback** (State Persistence):
   - Revert state-persistence.sh structured data changes
   - Remove STRUCTURED_DATA_KEYS allowlist
   - Remove base64 encoding/decoding logic
   - Git: `git checkout .claude/lib/core/state-persistence.sh`

4. **Phase 4 Rollback** (Initialization Guards):
   - Remove initialization verification checks
   - Remove terminal state detection
   - Git: `git checkout .claude/commands/repair.md` (Block 1a only)

5. **Phase 5 Rollback** (Parameter Validation):
   - Remove parameter count validation from state persistence functions
   - Git: `git diff HEAD .claude/lib/core/state-persistence.sh | grep 'requires.*parameters' | git apply --reverse`

**Emergency Rollback** (complete revert):
```bash
git checkout HEAD -- .claude/commands/repair.md .claude/lib/core/state-persistence.sh
git status  # Verify working tree clean
/repair --command /test  # Test original behavior
```

---

## Dependencies

### External Dependencies
- state-persistence.sh library (>=1.5.0) - enhanced in Phase 3
- workflow-state-machine.sh library (>=2.0.0) - used in Phases 1, 4
- error-handling.sh library - used in all phases for logging

### Internal Dependencies
- Phase 4 depends on Phase 1 (state transition sequence must be correct before adding guards)
- Phase 5 depends on Phase 3 (parameter validation should be added after structured data support)
- Phase 6 depends on all previous phases (integration testing validates complete fix set)
- Phase 7 depends on Phase 6 (cannot mark errors resolved until tests pass)

### Library Version Updates
- state-persistence.sh: Increment version to 1.6.0 after Phase 3 (structured data support is new feature)
- No version changes required for other libraries (bug fixes, not API changes)

---

## Success Metrics

### Primary Metrics
1. **Error Reduction**: Zero new /repair errors logged after implementation (down from 28 errors over 11 days)
2. **State Transition Success**: 100% of /repair workflows complete full state sequence (initialize -> research -> plan -> complete)
3. **Workflow Completion Rate**: /repair workflows reach terminal state (complete) without errors

### Secondary Metrics
1. **Pattern-Specific Elimination**:
   - Pattern 1 (JSON validation): 0 errors (down from 5)
   - Pattern 2 (invalid transitions): 0 errors (down from 3)
   - Pattern 3 (bash execution): Reduced by 70% (conditionals account for ~12 of 17)
   - Pattern 4 (uninitialized state): 0 errors (down from 1)
   - Pattern 5 (terminal state): 0 errors (down from 1)

2. **Code Quality**:
   - Zero conditional syntax violations in /repair
   - Zero state persistence violations
   - Standards validators pass with zero errors

3. **Test Coverage**:
   - Integration test script created and passing
   - All five error patterns covered by regression tests
   - Test suite added to CI validation

### Monitoring
- Query error log daily for /repair errors: `/errors --command /repair --since 24h`
- Review state transition logs for unexpected patterns
- Monitor workflow completion times (should not increase significantly)

---

## Risk Analysis

### High Risk
1. **State Persistence Breaking Change** (Phase 3):
   - **Risk**: Base64 encoding changes could break existing workflows reading state files
   - **Mitigation**: Use suffix convention (_BASE64) to distinguish encoded keys, maintain backward compatibility for scalar values
   - **Fallback**: Graceful degradation - decode fails, use original value

2. **State Transition Sequence Change** (Phase 1):
   - **Risk**: Changing transition sequence could break other commands using research-and-plan workflow type
   - **Mitigation**: Verify state machine transition graph allows initialize -> research for all research-and-plan workflows, test /plan and /debug commands
   - **Fallback**: Revert to original sequence, fix state machine configuration instead

### Medium Risk
1. **Conditional Syntax Changes** (Phase 2):
   - **Risk**: Unescaped negation operators could change conditional logic behavior
   - **Mitigation**: Test all conditional branches to verify logic unchanged, compare behavior before/after
   - **Fallback**: Revert to escaped operators, document as known limitation

2. **Initialization Guards Impact** (Phase 4):
   - **Risk**: Guards could prevent legitimate workflows from resuming after interruption
   - **Mitigation**: Only clean terminal states (complete/failed), preserve in-progress state files
   - **Fallback**: Remove terminal state cleanup, keep only CURRENT_STATE validation

### Low Risk
1. **Parameter Validation** (Phase 5):
   - **Risk**: New validation could break existing code with legacy call patterns
   - **Mitigation**: Audit all state persistence function calls in .claude/ before deployment
   - **Fallback**: Make validation warnings instead of errors

---

## Communication Plan

### Pre-Implementation
- Review plan with project maintainer
- Confirm state transition sequence change acceptable for research-and-plan workflows
- Validate structured data encoding approach for state persistence

### During Implementation
- Commit after each phase completion
- Include phase number and objective in commit messages
- Tag commits with `fix/repair-workflow` for tracking

### Post-Implementation
- Update TODO.md with completion status
- Document new state persistence features in state-persistence.sh header
- Add troubleshooting guide for /repair to docs/guides/commands/

### Commit Message Template
```
fix(repair): [Phase N] <Objective>

<Description of changes>
<Impact on error patterns>

Fixes: Pattern N (<error count> errors)
Testing: <validation approach>
```

Example:
```
fix(repair): [Phase 1] Fix state transition sequence

Update /repair to use correct initialize -> research transition
instead of invalid initialize -> plan. Block 2a handles research
-> plan transition after analysis completes.

Fixes: Pattern 2 (3 errors - invalid state transitions)
Testing: Verified transition sequence with state machine debug logs
```
