# /test Command Repair Plan

## Metadata
- **Date**: 2025-12-02
- **Feature**: Fix critical errors blocking /test command execution
- **Scope**: Repair library sourcing, state machine initialization, state transitions, path handling, and preprocessing-unsafe conditionals in /test command template
- **Status**: [COMPLETE]
- **Estimated Hours**: 4-6 hours
- **Standards File**: /home/benjamin/.config/CLAUDE.md
- **Error Log Query**: --command /test
- **Errors Addressed**: 5 critical error patterns (execution_error, state_error, file_error) blocking all test workflow executions
- **Research Reports**:
  - [/test Command Error Analysis Report](../reports/001-test-errors-repair.md)

## Overview

The `/test` command is completely non-functional due to critical mismatches between the command template and current library implementations. This repair plan addresses five blocking error patterns identified through error log analysis and workflow output inspection:

1. **Missing Library Functions**: `ensure_artifact_directory()` called but not sourced
2. **Incorrect State Machine Initialization**: Invalid `sm_init()` parameter signature
3. **Invalid State Transitions**: Direct transition to `test` state from `initialize` (not allowed)
4. **State File Path Corruption**: Double-concatenation in state persistence paths
5. **Preprocessing-Unsafe Conditionals**: Regex conditionals causing syntax errors

**Severity**: CRITICAL - Command cannot execute basic initialization
**Root Cause**: Command template out of sync with evolved library architecture
**Impact**: All test workflows blocked, no test coverage available for implemented features

## Phase 1: Add Missing Library Sourcing

**Objective**: Source `unified-location-detection.sh` to make `ensure_artifact_directory()` available

**Dependencies**: none

**Tasks**:
- [ ] Read current `/test` command sourcing block (lines 77-97)
- [ ] Add `unified-location-detection.sh` to three-tier sourcing pattern:
  ```bash
  source "${CLAUDE_LIB}/core/unified-location-detection.sh" 2>/dev/null || {
    echo "ERROR: Cannot load unified-location-detection library" >&2
    exit 1
  }
  ```
- [ ] Verify sourcing block follows mandatory three-tier pattern per code standards
- [ ] Ensure fail-fast error handler is present for Tier 1 library
- [ ] Validate no output suppression conflicts with error logging

**Validation**:
```bash
# Verify function availability after sourcing
source .claude/commands/test.md # (extract bash block)
type ensure_artifact_directory &>/dev/null && echo "PASS" || echo "FAIL"
```

**Estimated Time**: 30 minutes

---

## Phase 2: Fix State Machine Initialization Signature

**Objective**: Update `sm_init()` call to match current library signature

**Dependencies**: [Phase 1]

**Tasks**:
- [ ] Read current `sm_init()` call in `/test` command (lines 272-283)
- [ ] Read current `sm_init()` signature from `workflow-state-machine.sh`
- [ ] Update `sm_init()` call with correct parameters:
  ```bash
  # Current (INCORRECT):
  # sm_init "$WORKFLOW_ID" "test" "test-and-debug" "$MAX_TEST_ITERATIONS" "[]"

  # Fixed (CORRECT):
  sm_init \
    "Test execution for $(basename "$PLAN_FILE")" \  # workflow_desc (descriptive string)
    "/test" \                                         # command_name
    "test-and-debug" \                                # workflow_type
    "2" \                                             # research_complexity (1-4, use 2 for test)
    "[]" \                                            # research_topics_json
    2>/dev/null || {
      log_command_error "state_error" \
        "State machine initialization failed" \
        "Workflow ID: $WORKFLOW_ID, Type: test-and-debug"
      exit 1
    }
  ```
- [ ] Remove `MAX_TEST_ITERATIONS` variable (replaced with complexity=2)
- [ ] Update error logging to include correct parameter context

**Validation**:
```bash
# Verify sm_init succeeds and creates state file
source .claude/lib/workflow/workflow-state-machine.sh
sm_init "Test workflow" "/test" "test-and-debug" "2" "[]" && echo "PASS" || echo "FAIL"
```

**Estimated Time**: 45 minutes

---

## Phase 3: Add Valid State Transition Path

**Objective**: Fix invalid state transition by adding intermediate `implement` state transition

**Dependencies**: [Phase 2]

**Tasks**:
- [ ] Read current state transition call (line 294)
- [ ] Read `STATE_TRANSITIONS` map from `workflow-state-machine.sh` to verify valid paths
- [ ] Add `implement` state transition before `test` transition:
  ```bash
  # Valid state path for test-only workflow:
  # initialize -> implement -> test -> complete

  # Transition to implement (discovery phase)
  sm_transition "$STATE_IMPLEMENT" "entering implement phase for test discovery" 2>/dev/null || {
    log_command_error "state_error" \
      "State transition to IMPLEMENT failed" \
      "Current state: $(sm_get_state)"
    exit 1
  }

  # Now transition to test
  sm_transition "$STATE_TEST" "starting test execution phase" 2>/dev/null || {
    log_command_error "state_error" \
      "State transition to TEST failed" \
      "Current state: $(sm_get_state)"
    exit 1
  }
  ```
- [ ] Update error logging to use `sm_get_state()` for current state reporting
- [ ] Verify transition descriptions are clear and accurate

**Validation**:
```bash
# Verify state transitions follow valid path
sm_init "Test" "/test" "test-and-debug" "2" "[]"
sm_transition "$STATE_IMPLEMENT" "test" && sm_transition "$STATE_TEST" "test" && echo "PASS" || echo "FAIL"
```

**Estimated Time**: 45 minutes

---

## Phase 4: Investigate and Fix State File Path Corruption

**Objective**: Fix double-concatenation in state file path handling

**Dependencies**: [Phase 3]

**Tasks**:
- [ ] Read error message showing path corruption: `/home/.../tmp/workflow_/home/.../specs/.../.state/test_state.sh.sh`
- [ ] Read STATE_ID_FILE creation logic (lines 307-308):
  ```bash
  STATE_ID_FILE="${HOME}/.claude/tmp/${WORKFLOW_ID}_state_id.txt"
  echo "${TOPIC_PATH}/.state/test_state.sh" > "$STATE_ID_FILE"
  ```
- [ ] Read `init_workflow_state()` implementation in `state-persistence.sh` to identify path concatenation bug
- [ ] Determine if bug is in `/test` command or `state-persistence.sh`:
  - If in command: Fix STATE_ID_FILE content to use relative path or correct format
  - If in library: Create separate repair plan for `state-persistence.sh` (broader impact)
- [ ] Test path handling with absolute paths to verify fix
- [ ] Remove duplicate `.sh` extension if root cause is in file naming

**Validation**:
```bash
# Verify state file path is correct (single path, no double-concatenation)
STATE_ID_FILE="/tmp/test_state_id.txt"
echo "/path/to/.state/test_state.sh" > "$STATE_ID_FILE"
source .claude/lib/core/state-persistence.sh
init_workflow_state
# Check resulting state file path contains no double-concatenation
```

**Estimated Time**: 1.5-2 hours (investigation + fix + testing)

---

## Phase 5: Replace Preprocessing-Unsafe Conditionals

**Objective**: Convert all regex conditionals to result variable pattern per code standards

**Dependencies**: [Phase 1]

**Tasks**:
- [ ] Search for all regex conditionals in `/test` command:
  ```bash
  grep -n '\[\[.*=~' .claude/commands/test.md
  ```
- [ ] Identify line 188 and any other instances
- [ ] Replace each regex conditional with result variable pattern:
  ```bash
  # UNSAFE (line 188):
  if [[ "$PLAN_FILE" =~ ^/ ]]; then

  # SAFE (standards-compliant):
  result=0
  [[ "$PLAN_FILE" =~ ^/ ]] || result=1
  if [ "$result" -eq 0 ]; then
  ```
- [ ] Verify all conditionals use `[ ... ]` (POSIX) not `[[ ... ]]` for result checks
- [ ] Test each conditional replacement in isolation to verify behavior unchanged
- [ ] Run preprocessing simulation to verify no syntax errors

**Validation**:
```bash
# Verify no regex conditionals remain in [[ ... ]] blocks
! grep -P '\[\[.*=~.*\]\].*then' .claude/commands/test.md && echo "PASS" || echo "FAIL"

# Verify all conditionals are preprocessing-safe
bash .claude/scripts/lint/lint_bash_conditionals.sh .claude/commands/test.md && echo "PASS" || echo "FAIL"
```

**Estimated Time**: 1 hour

---

## Phase 6: Integration Testing and Validation

**Objective**: Verify all fixes work together and `/test` command executes successfully

**Dependencies**: [Phase 1, Phase 2, Phase 3, Phase 4, Phase 5]

**Tasks**:
- [ ] Create minimal test plan file for integration test:
  ```bash
  mkdir -p /tmp/test_repair_integration/plans
  echo "# Test Plan" > /tmp/test_repair_integration/plans/test-plan.md
  echo "## Phase 1: Test Phase" >> /tmp/test_repair_integration/plans/test-plan.md
  ```
- [ ] Run `/test` command against test plan:
  ```bash
  # Should initialize without errors and reach test-executor agent delegation
  # (test-executor may fail if no tests found, but initialization must succeed)
  ```
- [ ] Verify each fix:
  - [ ] `ensure_artifact_directory()` called successfully (no "command not found")
  - [ ] `sm_init()` succeeds with correct parameters (no signature error)
  - [ ] State transitions follow valid path: initialize -> implement -> test
  - [ ] State file path is correct (no double-concatenation or `.sh.sh` extension)
  - [ ] No preprocessing syntax errors from regex conditionals
- [ ] Check error log for new errors during integration test
- [ ] Verify workflow state persists correctly across blocks

**Validation**:
```bash
# Full integration test
cd /tmp/test_repair_integration
/test plans/test-plan.md 2>&1 | tee /tmp/test_repair_output.log

# Verify no CRITICAL errors in output
! grep -i "ERROR.*command not found" /tmp/test_repair_output.log && echo "PASS: Library sourcing" || echo "FAIL"
! grep -i "ERROR.*State transition.*failed" /tmp/test_repair_output.log && echo "PASS: State transitions" || echo "FAIL"
! grep -i "syntax error" /tmp/test_repair_output.log && echo "PASS: Conditionals" || echo "FAIL"
```

**Estimated Time**: 1.5 hours

---

## Phase 7: Documentation and Standards Compliance

**Objective**: Document fixes, update test command guide, and verify standards compliance

**Dependencies**: [Phase 6]

**Tasks**:
- [ ] Update `/test` command documentation (`.claude/docs/guides/commands/test-command-guide.md`):
  - Document corrected library sourcing requirements
  - Document state transition path for test-only workflows
  - Add troubleshooting section for common errors
- [ ] Run all standards validators:
  ```bash
  bash .claude/scripts/validate-all-standards.sh --sourcing
  bash .claude/scripts/validate-all-standards.sh --conditionals
  bash .claude/scripts/validate-all-standards.sh --all
  ```
- [ ] Verify pre-commit hook passes for modified `/test` command
- [ ] Add integration test for `/test` command to prevent regression:
  ```bash
  # Create test_test_command_integration.sh
  # Validates library sourcing, state transitions, and execution path
  ```
- [ ] Update command authoring standards if new patterns discovered

**Validation**:
```bash
# Standards compliance
bash .claude/scripts/validate-all-standards.sh --all && echo "PASS" || echo "FAIL"

# Pre-commit hook simulation
git add .claude/commands/test.md
.claude/hooks/pre-commit && echo "PASS" || echo "FAIL"
git reset HEAD .claude/commands/test.md
```

**Estimated Time**: 1 hour

---

## Phase 8: Update Error Log Status

**Objective**: Update error log entries from FIX_PLANNED to RESOLVED

**Dependencies**: [Phase 1, Phase 2, Phase 3, Phase 4, Phase 5, Phase 6, Phase 7]

**Tasks**:
- [ ] Verify all fixes are working (tests pass, no new errors generated)
- [ ] Update error log entries to RESOLVED status:
  ```bash
  source .claude/lib/core/error-handling.sh
  RESOLVED_COUNT=$(mark_errors_resolved_for_plan "/home/benjamin/.config/.claude/specs/023_repair_test_20251202_150525/plans/001-repair-test-20251202-150525-plan.md")
  echo "Resolved $RESOLVED_COUNT error log entries"
  ```
- [ ] Verify no FIX_PLANNED errors remain for this plan:
  ```bash
  REMAINING=$(query_errors --status FIX_PLANNED | jq -r '.repair_plan_path' | grep -c "023_repair_test_20251202_150525" || echo "0")
  [ "$REMAINING" -eq 0 ] && echo "All errors resolved" || echo "WARNING: $REMAINING errors still FIX_PLANNED"
  ```

**Validation**:
```bash
# Verify error log updated correctly
query_errors --plan "023_repair_test_20251202_150525" | jq -r '.status' | sort -u
# Should only show: RESOLVED
```

**Estimated Time**: 15 minutes

---

## Success Criteria

**Functional Requirements**:
- [ ] `/test` command initializes without "command not found" errors
- [ ] State machine initialization succeeds with correct parameters
- [ ] State transitions follow valid path (initialize -> implement -> test)
- [ ] State file paths are correct (no double-concatenation)
- [ ] All regex conditionals are preprocessing-safe
- [ ] Integration test passes end-to-end

**Quality Requirements**:
- [ ] All standards validators pass (sourcing, conditionals, error logging)
- [ ] Pre-commit hook passes for modified files
- [ ] Error log entries updated to RESOLVED status
- [ ] Documentation updated with troubleshooting guide
- [ ] Integration test added to prevent regression

**Performance Requirements**:
- [ ] Command initialization completes in <2 seconds
- [ ] State transitions complete in <1 second
- [ ] No unnecessary file I/O or logging overhead

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| State file path fix requires library changes | Medium | High | Create separate repair plan for state-persistence.sh if needed |
| Additional preprocessing-unsafe conditionals discovered | Medium | Medium | Comprehensive grep search, linter validation |
| Test-executor agent incompatibilities | Low | Medium | Verify agent signature matches updated state machine |
| Breaking changes to other commands | Low | High | Audit /implement and /build for similar issues |

---

## Rollback Plan

If fixes cause regressions:

1. **Immediate Rollback**: Revert `/test` command to previous version via git
2. **Verify Revert**: Run integration test suite to confirm stability
3. **Root Cause Analysis**: Analyze what went wrong, update repair plan
4. **Phased Retry**: Apply fixes one phase at a time with validation gates

---

## Related Issues

**Similar Issues in Other Commands**:
- `/implement` command: May have similar state transition issues (audit recommended)
- `/build` command: Uses test-executor agent, verify compatibility
- All commands using `sm_init()`: Verify parameter signatures match

**Technical Debt Items**:
- No automated template validation against library APIs
- No integration test suite for slash commands
- Library API versioning not enforced

**Follow-Up Work**:
- Create `/test` command integration test (Phase 7)
- Audit all commands for library sourcing completeness
- Add pre-commit validator for command template compatibility

---

## Artifacts

**Input Artifacts**:
- `/home/benjamin/.config/.claude/commands/test.md` - Command template to fix
- `/home/benjamin/.config/.claude/lib/workflow/workflow-state-machine.sh` - State machine library
- `/home/benjamin/.config/.claude/lib/core/state-persistence.sh` - State persistence library
- `/home/benjamin/.config/.claude/lib/core/unified-location-detection.sh` - Location detection library
- `/home/benjamin/.config/.claude/specs/023_repair_test_20251202_150525/reports/001-test-errors-repair.md` - Research report

**Output Artifacts**:
- `/home/benjamin/.config/.claude/commands/test.md` - Fixed command template
- `/home/benjamin/.config/.claude/docs/guides/commands/test-command-guide.md` - Updated documentation
- `/home/benjamin/.config/.claude/tests/integration/test_test_command_integration.sh` - New integration test
- `/home/benjamin/.config/.claude/data/logs/errors.jsonl` - Updated error log (RESOLVED status)

---

## Notes

**Key Insights from Research**:
1. Command template divergence from library evolution is root cause
2. No validation exists to catch template/library mismatches at authoring time
3. State machine API changes require coordinated template updates
4. Preprocessing-unsafe conditionals remain common anti-pattern

**Implementation Strategy**:
- Fix blocking errors first (Phases 1-3): Enable basic execution
- Investigate complex issues (Phase 4): State file path corruption may require library fix
- Apply standards fixes (Phase 5): Preprocessing-safe conditionals
- Validate thoroughly (Phases 6-7): Integration testing and documentation
- Close loop (Phase 8): Update error log status

**Long-Term Recommendations**:
1. Automated template validation pre-commit hook
2. Integration test suite for all slash commands
3. Library API semantic versioning and deprecation warnings
4. Command template auto-generation from specs
