# Delegation Standard

**Version**: 2.0  
**Status**: Active  
**Created**: 2025-12-29  
**Purpose**: Unified delegation standard defining return format, delegation patterns, and safety mechanisms

---

## Overview

This standard defines how commands and agents safely delegate work to subagents, including:

- **Return Format**: Standardized JSON structure for all subagent returns
- **Delegation Patterns**: Safe patterns to prevent hangs, cycles, and timeouts
- **Validation Framework**: Comprehensive validation for returns and delegation context

**Problems Solved**:
- Delegation hangs (Task 191 Root Causes #1, #3, #6)
- Infinite delegation loops (Task 191 Root Cause #2)
- Missing timeouts (Task 191 Root Cause #4)
- Coordination gaps (Task 191 Root Cause #5)

---

## Return Format

All subagents MUST return this standardized JSON structure:

```json
{
  "status": "completed|failed|partial|blocked",
  "summary": "Brief 2-5 sentence summary (max 100 tokens)",
  "artifacts": [
    {
      "type": "research|plan|implementation|summary|documentation",
      "path": "relative/path/from/project/root",
      "summary": "Optional one-sentence description"
    }
  ],
  "metadata": {
    "session_id": "sess_{timestamp}_{random}",
    "duration_seconds": 123,
    "agent_type": "agent_name",
    "delegation_depth": 1,
    "delegation_path": ["orchestrator", "command", "agent"]
  },
  "errors": [
    {
      "type": "timeout|validation|execution|tool_unavailable",
      "message": "Human-readable error description",
      "code": "ERROR_CODE",
      "recoverable": true,
      "recommendation": "Suggested fix or next step"
    }
  ],
  "next_steps": "Optional recommended next actions"
}
```

### Field Specifications

#### status (required)
**Type**: String enum  
**Values**: `completed` | `failed` | `partial` | `blocked`

- `completed`: All work finished successfully
- `failed`: Work failed, no usable results
- `partial`: Some work completed, partial results available (e.g., timeout)
- `blocked`: Cannot proceed, requires external resolution

#### summary (required)
**Type**: String  
**Length**: 2-5 sentences, max 100 tokens (~400 characters)

**Guidelines**:
- Focus on outcomes, not process
- Be specific about what was created or changed
- Mention key decisions or blockers
- No emojis or formatting markup

#### artifacts (required, can be empty array)
**Type**: Array of artifact objects

Each artifact:
```json
{
  "type": "research|plan|implementation|summary|documentation",
  "path": "relative/path/from/root",
  "summary": "Optional one-sentence description"
}
```

**Validation**:
- Paths must be relative from project root
- All paths must exist or be created during execution
- Type must match artifact purpose

#### metadata (required)
**Type**: Object with required fields

**Required Fields**:
- `session_id`: Unique identifier (format: `sess_{timestamp}_{random}`)
- `duration_seconds`: Execution time in seconds
- `agent_type`: Name of the agent returning results
- `delegation_depth`: Current depth in delegation chain (prevents cycles)
- `delegation_path`: Array of agent names in delegation chain

#### errors (optional, empty array if no errors)
**Type**: Array of error objects

Each error:
```json
{
  "type": "timeout|validation|execution|tool_unavailable",
  "message": "Human-readable description",
  "code": "ERROR_CODE",
  "recoverable": true,
  "recommendation": "Suggested fix"
}
```

**When to Include**:
- Status is `failed` or `partial`: MUST include errors
- Status is `blocked`: MUST include error explaining blocker
- Status is `completed`: errors array should be empty

#### next_steps (optional)
**Type**: String (1-2 sentences)

Include to recommend follow-up actions, suggest alternatives after failure, or indicate dependencies.

---

## Delegation Patterns

### Core Principles

#### 1. Session ID Tracking
Every delegation MUST have a unique session ID.

**Format**: `sess_{timestamp}_{random_6char}`  
**Example**: `sess_20251226_abc123`

**Usage**:
- Generated by caller before invoking subagent
- Passed to subagent in delegation context
- Returned by subagent in metadata
- Used for tracking in orchestrator registry

#### 2. Delegation Depth Limits
**Maximum delegation depth**: 3 levels

**Depth Counting**:
- Orchestrator → Command: depth = 0 (not counted)
- Command → Subagent: depth = 1
- Subagent → Specialist: depth = 2
- Specialist → Helper: depth = 3 (max)
- Helper → Another Agent: **BLOCKED** (exceeds limit)

**Enforcement**:
- Caller increments depth before delegating
- Caller checks: `if depth >= 3: return error`
- Subagent receives depth in delegation context
- Subagent returns depth in metadata

#### 3. Delegation Path Tracking
Track the full delegation path to detect cycles.

**Path Format**: Array of agent names  
**Example**: `["orchestrator", "implement", "task-executor", "implementer"]`

**Cycle Detection**:
```python
def check_cycle(delegation_path, target_agent):
    if target_agent in delegation_path:
        raise CycleError(f"Cycle detected: {delegation_path} → {target_agent}")
    return False
```

#### 4. Timeout Enforcement
All delegations MUST have timeouts.

**Default Timeouts**:
- Research: 3600s (1 hour)
- Planning: 1800s (30 minutes)
- Implementation: 7200s (2 hours)
- Simple operations: 300s (5 minutes)

**Timeout Handling**:
- Never wait indefinitely
- Return partial results if available
- Mark task as IN PROGRESS (not failed)
- Provide actionable recovery message

#### 5. Return Validation
All subagent returns MUST be validated.

**Validation Steps**:
1. Check return is valid JSON
2. Validate against return format schema
3. Check session_id matches expected
4. Validate all required fields present
5. Check status is valid enum value

---

## Standard Delegation Workflow

### Stage 1: Prepare Delegation

```xml
<stage name="PrepareDelegation">
  <action>Prepare delegation context</action>
  <process>
    1. Generate unique session_id
    2. Get current delegation_depth from context (default 0)
    3. Get current delegation_path from context (default [])
    4. Increment depth: new_depth = depth + 1
    5. Check depth limit: if new_depth >= 3: return error
    6. Append self to path: new_path = path + [self_name]
    7. Check for cycles: if target in new_path: return error
    8. Determine timeout based on operation type
    9. Store session_id for later validation
  </process>
</stage>
```

### Stage 2: Invoke Subagent

```xml
<stage name="InvokeSubagent">
  <action>Invoke subagent with delegation context</action>
  <process>
    1. Route to appropriate subagent
    2. Pass delegation context
    3. Pass task-specific parameters
    4. Set timeout from delegation context
    5. Begin monitoring (if orchestrator)
  </process>
</stage>
```

### Stage 3: Receive Results

```xml
<stage name="ReceiveResults">
  <action>Wait for and receive subagent results</action>
  <process>
    1. Poll for completion (max timeout seconds)
    2. Receive return object from subagent
    3. Handle timeout if no response
    4. Handle exceptions if invocation failed
  </process>
  <timeout_handling>
    If timeout (no response after {timeout}s):
      1. Log timeout error with session_id
      2. Check for partial artifacts on disk
      3. Return partial status with artifacts found
      4. Provide recovery message
      5. Do NOT mark task as failed
  </timeout_handling>
</stage>
```

### Stage 4: Validate Return

```xml
<stage name="ValidateReturn">
  <action>Validate return against standard format</action>
  <process>
    1. Validate JSON structure
    2. Validate against return format schema
    3. Check session_id matches expected
    4. Validate all required fields present
    5. Validate status is valid enum
    6. Validate summary within length limits
    7. Validate artifacts have valid paths
  </process>
  <validation_failure>
    If validation fails:
      1. Log validation error with details
      2. Return failed status
      3. Include original return for debugging
      4. Recommend subagent fix
  </validation_failure>
</stage>
```

### Stage 5: Process Results

```xml
<stage name="ProcessResults">
  <action>Extract and process validated results</action>
  <process>
    1. Extract status from return
    2. Extract summary for user/caller
    3. Extract artifacts for linking
    4. Extract errors if status != completed
    5. Extract next_steps if present
    6. Prepare for next stage (postflight/return)
  </process>
  <status_handling>
    If status == "completed":
      - All work finished successfully
      - Proceed to postflight with artifacts
    If status == "partial":
      - Some work completed
      - Keep task IN PROGRESS
      - Save partial results
    If status == "failed":
      - No usable results
      - Handle errors
      - Provide recovery steps
    If status == "blocked":
      - Cannot proceed
      - Identify blocker
      - Request user intervention
  </status_handling>
</stage>
```

---

## Delegation Context Schema

Every delegation MUST include this context:

```json
{
  "session_id": "sess_{timestamp}_{random}",
  "delegation_depth": 1,
  "delegation_path": ["orchestrator", "command", "agent"],
  "timeout": 3600,
  "caller": "command_name",
  "task_context": {
    "task_number": 191,
    "language": "lean",
    "complexity": "high"
  }
}
```

**Required Fields**:
- `session_id`: Unique identifier for this delegation
- `delegation_depth`: Current depth (0-2, max 3)
- `delegation_path`: Array of agent names in delegation chain
- `timeout`: Maximum wait time in seconds

**Optional Fields**:
- `caller`: Name of calling agent/command
- `task_context`: Additional context for the task

---

## Validation Framework

### Return Validation

```python
def validate_return(return_obj, expected_session_id):
    # 1. Check JSON structure
    assert isinstance(return_obj, dict), "Return must be JSON object"
    
    # 2. Check required fields
    required = ["status", "summary", "artifacts", "metadata"]
    for field in required:
        assert field in return_obj, f"Missing required field: {field}"
    
    # 3. Validate status
    valid_statuses = ["completed", "failed", "partial", "blocked"]
    assert return_obj["status"] in valid_statuses, f"Invalid status"
    
    # 4. Check session ID
    actual_session = return_obj["metadata"]["session_id"]
    assert actual_session == expected_session_id, "Session ID mismatch"
    
    # 5. Validate summary length
    summary = return_obj["summary"]
    assert len(summary) > 0, "Summary cannot be empty"
    assert len(summary) <= 500, "Summary too long (max 500 chars)"
    
    return True
```

### Delegation Validation

All commands that invoke subagents MUST:

1. **Generate session_id** before invoking subagent
2. **Pass delegation context** (depth, path) to prevent cycles
3. **Set timeout** (default 3600s) for subagent invocation
4. **Validate return format** against this schema
5. **Extract artifacts** from validated return
6. **Handle errors** based on status and error array
7. **Update state** based on return status

---

## Error Codes

Standardized error codes for consistent error handling:

- `TIMEOUT`: Operation exceeded time limit
- `VALIDATION_FAILED`: Input validation failed
- `TOOL_UNAVAILABLE`: Required tool not available
- `BUILD_ERROR`: Compilation or build failed
- `FILE_NOT_FOUND`: Required file missing
- `CYCLE_DETECTED`: Delegation would create cycle
- `MAX_DEPTH_EXCEEDED`: Delegation depth limit (3) exceeded
- `STATUS_SYNC_FAILED`: Failed to update state
- `GIT_COMMIT_FAILED`: Failed to create git commit
- `UNKNOWN_ERROR`: Unexpected error occurred

---

## Examples

### Example 1: Successful Completion

```json
{
  "status": "completed",
  "summary": "Research completed on LeanSearch API integration. Found official REST endpoints with authentication. Recommend implementing search and theorem lookup first.",
  "artifacts": [
    {
      "type": "research",
      "path": ".claude/specs/195_lean_tools/reports/research-001.md",
      "summary": "Detailed API specifications"
    }
  ],
  "metadata": {
    "session_id": "sess_20251226_abc123",
    "duration_seconds": 1250,
    "agent_type": "researcher",
    "delegation_depth": 1,
    "delegation_path": ["orchestrator", "research", "researcher"]
  },
  "errors": [],
  "next_steps": "Create implementation plan for LeanSearch integration"
}
```

### Example 2: Partial Completion (Timeout)

```json
{
  "status": "partial",
  "summary": "Implementation phase 1 completed but timed out after 1 hour. Successfully updated return format standard. Remaining: update commands with return handling.",
  "artifacts": [
    {
      "type": "implementation",
      "path": ".claude/context/core/standards/delegation.md",
      "summary": "Consolidated delegation standard"
    }
  ],
  "metadata": {
    "session_id": "sess_20251226_def456",
    "duration_seconds": 3600,
    "agent_type": "implementer",
    "delegation_depth": 2,
    "delegation_path": ["orchestrator", "implement", "task-executor", "implementer"]
  },
  "errors": [
    {
      "type": "timeout",
      "message": "Implementation exceeded 3600s timeout",
      "code": "TIMEOUT",
      "recoverable": true,
      "recommendation": "Run /implement again to resume from phase 2"
    }
  ],
  "next_steps": "Resume implementation with /implement command"
}
```

### Example 3: Failed Execution

```json
{
  "status": "failed",
  "summary": "Failed to implement Lean proof due to lean-lsp-mcp unavailability. Checked configuration and attempted fallback. Both approaches failed.",
  "artifacts": [],
  "metadata": {
    "session_id": "sess_20251226_ghi789",
    "duration_seconds": 45,
    "agent_type": "lean-implementation-agent",
    "delegation_depth": 1,
    "delegation_path": ["orchestrator", "implement", "lean-implementation-agent"]
  },
  "errors": [
    {
      "type": "tool_unavailable",
      "message": "lean-lsp-mcp not available in .mcp.json",
      "code": "TOOL_UNAVAILABLE",
      "recoverable": true,
      "recommendation": "Install lean-lsp-mcp: uvx lean-lsp-mcp"
    }
  ],
  "next_steps": "Install lean-lsp-mcp and retry implementation"
}
```

---

## Bulk Operation Delegation Patterns

### Overview

Bulk operations (--recover, --sync, --abandon) delegate to status-sync-manager with arrays of task numbers. These operations support range syntax and require special handling for partial failures.

### Delegation Pattern for Bulk Recovery

```json
{
  "operation": "unarchive_tasks",
  "task_numbers": [343, 344, 345, 337],
  "session_id": "sess_1735460684_a1b2c3",
  "delegation_depth": 1,
  "delegation_path": ["orchestrator", "task", "status-sync-manager"]
}
```

**Return Format**:
```json
{
  "status": "completed",
  "summary": "Recovered 4 tasks from archive",
  "artifacts": [],
  "metadata": {
    "session_id": "sess_1735460684_a1b2c3",
    "task_numbers": [343, 344, 345, 337],
    "success_count": 4,
    "failure_count": 0,
    "files_updated": ["TODO.md", "state.json", "archive/state.json"]
  },
  "errors": []
}
```

### Delegation Pattern for Bulk Sync with Git Blame

```json
{
  "operation": "sync_tasks",
  "task_ranges": [343, 344, 345],  // or "all" for all tasks
  "conflict_resolution": "git_blame",
  "session_id": "sess_1735460684_a1b2c3",
  "delegation_depth": 1,
  "delegation_path": ["orchestrator", "task", "status-sync-manager"]
}
```

**Git Blame Conflict Resolution**:
- For each field that differs between TODO.md and state.json:
  1. Run `git blame` on both files to get commit timestamps
  2. Compare timestamps: latest commit wins
  3. Log conflict resolution: "Task 343: status from state.json (2026-01-07) > TODO.md (2026-01-06)"
  4. Apply resolved value to both files

**Return Format**:
```json
{
  "status": "completed",
  "summary": "Synced 3 tasks, resolved 2 conflicts using git blame",
  "artifacts": [],
  "metadata": {
    "session_id": "sess_1735460684_a1b2c3",
    "synced_tasks": 3,
    "conflicts_resolved": 2,
    "conflict_details": [
      {
        "task_number": 343,
        "field": "status",
        "winner": "state.json",
        "timestamp_state": "2026-01-07T10:00:00Z",
        "timestamp_todo": "2026-01-06T09:00:00Z"
      }
    ],
    "files_updated": ["TODO.md", "state.json"]
  },
  "errors": []
}
```

### Delegation Pattern for Bulk Abandonment

```json
{
  "operation": "archive_tasks",
  "task_numbers": [343, 344, 345],
  "reason": "abandoned",
  "session_id": "sess_1735460684_a1b2c3",
  "delegation_depth": 1,
  "delegation_path": ["orchestrator", "task", "status-sync-manager"]
}
```

**Return Format**:
```json
{
  "status": "completed",
  "summary": "Abandoned 3 tasks to archive",
  "artifacts": [],
  "metadata": {
    "session_id": "sess_1735460684_a1b2c3",
    "task_numbers": [343, 344, 345],
    "success_count": 3,
    "files_updated": ["TODO.md", "state.json", "archive/state.json"]
  },
  "errors": []
}
```

### Rollback Mechanism for Task Division

When dividing a task into subtasks, rollback is required if any subtask creation fails:

**Delegation Pattern**:
```json
{
  "operation": "divide_task",
  "task_number": 326,
  "optional_prompt": "Focus on UI, backend, tests",
  "session_id": "sess_1735460684_a1b2c3",
  "delegation_depth": 1,
  "delegation_path": ["orchestrator", "task", "task-divider"]
}
```

**Rollback on Failure**:
1. Track created subtasks during loop
2. If any subtask creation fails:
   - Delete all created subtasks from TODO.md and state.json
   - Restore next_project_number to original value
   - Return error with rollback details
3. If all subtasks created successfully:
   - Update parent task dependencies
   - Return success

**Return Format (Success)**:
```json
{
  "status": "completed",
  "summary": "Divided task 326 into 3 subtasks",
  "artifacts": [],
  "metadata": {
    "session_id": "sess_1735460684_a1b2c3",
    "parent_task": 326,
    "subtasks": [327, 328, 329],
    "files_updated": ["TODO.md", "state.json"]
  },
  "errors": []
}
```

**Return Format (Failure with Rollback)**:
```json
{
  "status": "failed",
  "summary": "Failed to divide task 326, rolled back 2 created subtasks",
  "artifacts": [],
  "metadata": {
    "session_id": "sess_1735460684_a1b2c3",
    "parent_task": 326,
    "subtasks_created": [327, 328],
    "subtasks_rolled_back": [327, 328]
  },
  "errors": [
    {
      "type": "execution",
      "message": "Failed to create subtask 3: validation error",
      "code": "SUBTASK_CREATION_FAILED",
      "recoverable": true,
      "recommendation": "Fix validation error and retry division"
    }
  ]
}
```

### Status-Sync-Manager New Operations

The status-sync-manager subagent now supports these additional operations:

| Operation | Description | Bulk Support |
|-----------|-------------|--------------|
| `create_task` | Create single task entry | No |
| `update_status` | Update task status | No |
| `update_task_metadata` | Update task metadata fields | No |
| `archive_tasks` | Move tasks to archive/ | Yes (ranges/lists) |
| `unarchive_tasks` | Recover tasks from archive/ | Yes (ranges/lists) |
| `sync_tasks` | Sync TODO.md ↔ state.json with git blame | Yes (ranges/lists or "all") |

**Bulk Operation Characteristics**:
- Support range syntax: "343-345" expands to [343, 344, 345]
- Support list syntax: "337, 343-345" expands to [337, 343, 344, 345]
- Atomic updates: All tasks or none (two-phase commit)
- Partial failure handling: Report success_count and failure_count
- Git blame conflict resolution: Latest commit wins (for sync_tasks)

---

## Related Documentation

- Status Management: `.claude/context/core/system/state-management.md`
- Artifact Management: `.claude/context/core/system/artifact-management.md`
- Task 191 Research: `.claude/specs/191_fix_subagent_delegation_hang/reports/research-001.md`
# Delegation Guide

## Session ID Tracking

Every delegation has a unique session ID:
```
Format: sess_{timestamp}_{random_6char}
Example: sess_1735460684_a1b2c3
```

Generated by orchestrator in Stage 4 (PrepareContext).

## Delegation Context Structure

```json
{
  "session_id": "sess_1735460684_a1b2c3",
  "delegation_depth": 1,
  "delegation_path": ["orchestrator", "{command}", "{agent}"],
  "timeout": 3600,
  "task_context": {
    "task_number": 244,
    "description": "...",
    "language": "lean"
  }
}
```

## Delegation Depth Limits

```
Level 0: User → Orchestrator
Level 1: Orchestrator → Command → Agent
Level 2: Agent → Utility Agent (status-sync-manager, git-workflow-manager)
Level 3: Utility → Sub-Utility (rare, e.g., atomic-task-numberer)
```

**Maximum depth**: 3 levels  
**Enforcement**: Orchestrator Stage 2 (PreflightValidation)

## Cycle Detection

Before delegating, check if target agent is already in delegation_path.

**Example**:
```
delegation_path: ["orchestrator", "implement", "task-executor"]
target: "task-executor"
Result: ❌ CYCLE DETECTED - Block delegation
```

## Timeout Configuration

| Command | Default Timeout | Max Timeout |
|---------|----------------|-------------|
| /research | 3600s (1 hour) | 7200s (2 hours) |
| /plan | 1800s (30 min) | 3600s (1 hour) |
| /implement | 7200s (2 hours) | 14400s (4 hours) |
| /revise | 1800s (30 min) | 3600s (1 hour) |
| /review | 3600s (1 hour) | 7200s (2 hours) |

## Delegation Registry

Orchestrator maintains in-memory registry:

```json
{
  "sess_1735460684_a1b2c3": {
    "command": "implement",
    "subagent": "task-executor",
    "task_number": 191,
    "start_time": "2025-12-26T10:00:00Z",
    "timeout": 7200,
    "deadline": "2025-12-26T12:00:00Z",
    "status": "running",
    "delegation_depth": 1,
    "delegation_path": ["orchestrator", "implement", "task-executor"]
  }
}
```

Updated in Stage 4 (PrepareContext) and Stage 7 (PostflightCleanup).

## JSON Return Format Enforcement

**Problem**: When orchestrator invokes subagents via task tool, Claude does NOT automatically follow the JSON return format specified in the agent's markdown file. This causes validation failures in orchestrator Stage 4 because subagents return plain text instead of required JSON structure.

**Solution**: Orchestrator Stage 3 (RegisterAndDelegate) appends explicit JSON format instruction to all subagent invocations.

### JSON Format Instruction

```
CRITICAL RETURN FORMAT REQUIREMENT:
You MUST return ONLY valid JSON matching the schema in subagent-return-format.md.
Do NOT return plain text, markdown narrative, or any other format.

Required JSON structure:
{
  "status": "completed|partial|failed|blocked",
  "summary": "Brief 2-5 sentence summary (<100 tokens)",
  "artifacts": [{type, path, summary}, ...],
  "metadata": {session_id, duration_seconds, agent_type, delegation_depth, delegation_path},
  "errors": [{type, message, recoverable, recommendation}, ...],
  "next_steps": "What user should do next"
}

VALIDATION: Your return will be validated by orchestrator Stage 4. If you return
plain text instead of JSON, validation will fail with "Return is not valid JSON" error.
```

### Usage Pattern

**Task-based commands** (research, plan, implement, revise):
```python
prompt = f"Task: {task_number}" + JSON_FORMAT_INSTRUCTION
```

**Direct commands** (meta, review, todo, errors):
```python
prompt = $ARGUMENTS + JSON_FORMAT_INSTRUCTION
# If $ARGUMENTS is empty: prompt = "" + JSON_FORMAT_INSTRUCTION
```

### Enforcement Points

1. **Orchestrator Stage 3**: Appends JSON_FORMAT_INSTRUCTION to all task tool invocations
2. **Orchestrator Stage 4**: Validates return is valid JSON with required fields
3. **Subagent Specification**: Each agent's markdown file defines JSON return format
4. **Validation Failure**: If subagent returns plain text, orchestrator Stage 4 fails with clear error

### Benefits

- **Prevents "phantom research"**: Ensures subagents return structured data
- **Enables validation**: Orchestrator can verify artifacts exist and are non-empty
- **Consistent format**: All subagents return same JSON structure
- **Clear errors**: Validation failures provide actionable error messages

## Safety Guarantees

1. **No Infinite Loops**: Cycle detection prevents A→B→A patterns
2. **No Runaway Depth**: Max depth of 3 prevents deep chains
3. **No Indefinite Waits**: Timeout enforcement with graceful degradation
4. **Session Tracking**: Unique IDs enable debugging and monitoring
5. **JSON Format Enforcement**: Explicit instruction ensures subagents return valid JSON
