# Code Quality Standards

**Scope**: All code generated by OpenCode agents

## Core Philosophy

**Modular**: Small, focused, reusable components
**Functional**: Pure functions, immutability, composition
**Maintainable**: Self-documenting, testable, predictable

## Critical Patterns

✅ **Always Use**:

- Pure functions (same input = same output)
- Immutability (create new data, don't modify)
- Composition (build complex from simple)
- Small functions (< 50 lines)
- Explicit dependencies (dependency injection)

❌ **Never Use**:

- Mutation of existing data
- Side effects in pure functions
- Deep nesting (use early returns)
- God modules
- Global state

## Pure Functions

```javascript
// ✅ Pure
const add = (a, b) => a + b;
const formatUser = (user) => ({ ...user, fullName: `${user.firstName} ${user.lastName}` });

// ❌ Impure (side effects)
let total = 0;
const addToTotal = (value) => {
  total += value;
  return total;
};
```

## Immutability

```javascript
// ✅ Immutable
const addItem = (items, item) => [...items, item];
const updateUser = (user, changes) => ({ ...user, ...changes });

// ❌ Mutable
const addItem = (items, item) => {
  items.push(item);
  return items;
};
```

## Naming Conventions

| Type       | Format                | Example                    |
| ---------- | --------------------- | -------------------------- |
| Files      | lowercase-with-dashes | `user-service.ts`          |
| Functions  | verbPhrases           | `getUser`, `validateEmail` |
| Predicates | is/has/can prefixes   | `isValid`, `hasPermission` |
| Variables  | camelCase             | `userCount`                |
| Constants  | UPPER_SNAKE_CASE      | `MAX_RETRIES`              |
| Types      | PascalCase            | `UserProfile`              |

## Error Handling

```javascript
// ✅ Explicit error handling
function parseJSON(text) {
  try {
    return { success: true, data: JSON.parse(text) };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// ✅ Validate at boundaries
function createUser(userData) {
  const validation = validateUserData(userData);
  if (!validation.isValid) {
    return { success: false, errors: validation.errors };
  }
  return { success: true, user: saveUser(userData) };
}
```

## Dependency Injection

```javascript
// ✅ Dependencies explicit
function createUserService(database, logger) {
  return {
    createUser: (userData) => {
      logger.info("Creating user");
      return database.insert("users", userData);
    },
  };
}

// ❌ Hidden dependencies
import db from "./database.js";
function createUser(userData) {
  return db.insert("users", userData);
}
```

## Golden Rule

**If you can't easily test it, refactor it.**
